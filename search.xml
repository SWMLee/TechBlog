<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Angular i18n使用说明</title>
      <link href="/2019/12/18/TechnicalArticles/angular-i18n-demo/"/>
      <url>/2019/12/18/TechnicalArticles/angular-i18n-demo/</url>
      
        <content type="html"><![CDATA[<p>angular 项目，在实际使用开发时，难免会遇到需要使用多国语言的需求，也就是 angular 的国际化 i18n 的需求。</p><p>那么如何做到呢？</p><p>本文主要通过对一个常见的注册页面，实现多国语言版本的切换，来说明 angular i18n 的用法。代码已放到<a href="https://github.com/Sanotsu/angular-i18n-demo" target="_blank" rel="noopener">github</a>。</p><h1 id="创建一个-angular-项目，并编写英文版注册页面"><a href="#创建一个-angular-项目，并编写英文版注册页面" class="headerlink" title="创建一个 angular 项目，并编写英文版注册页面"></a>创建一个 angular 项目，并编写英文版注册页面</h1><h2 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h2><p>创建就是直接终端输入<code>ng new angular-i18n-demo</code>即可。<br>因为只是说明 i18n 的使用，不会过多复杂，不需要其他的模块例如 router、service 等。</p><p>目前前端开发，不使用一些样式（说白了就是 UI 组件）就很累，所以创建好 angular 项目之后，添加 angular material，使得注册页面稍微好看一点。<br>在 angular 项目根目录终端输入<code>ng add @angular/material</code>即可。</p><h2 id="2、编写页面"><a href="#2、编写页面" class="headerlink" title="2、编写页面"></a>2、编写页面</h2><p>不需要实现注册功能，构建一个注册页面就好了。因为已经使用了 angular material，就稍微用几个模块。</p><h3 id="2-1、在-app-module-ts-引入-angular-material-模块"><a href="#2-1、在-app-module-ts-引入-angular-material-模块" class="headerlink" title="2.1、在 app.module.ts 引入 angular material 模块"></a>2.1、在 app.module.ts 引入 angular material 模块</h3><p>在 app.module.ts 的@NgModule 装饰器下的 imports 属性中，添加以下内容：</p><pre><code>BrowserAnimationsModule,MatToolbarModule,MatCardModule,MatInputModule,MatButtonModule,MatIconModule</code></pre><p>然后逐一导入，在顶部应该会有：</p><pre><code>import { BrowserAnimationsModule } from &#39;@angular/platform-browser/animations&#39;;import {   MatInputModule,   MatCardModule,   MatToolbarModule,   MatButtonModule,   MatIconModule} from &#39;@angular/material&#39;;</code></pre><h3 id="2-2-在-app-目录下，创建一个注册的组件"><a href="#2-2-在-app-目录下，创建一个注册的组件" class="headerlink" title="2.2 在 app 目录下，创建一个注册的组件"></a>2.2 在 app 目录下，创建一个注册的组件</h3><p>如下图：</p><p><img alt="新建注册组件" data-src="/../images/TA/angular-i18n-demo/%E6%96%B0%E5%BB%BA%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6.png" class="lazyload"></p><p>我这个是直接使用指令<code>ng g component register</code>生成，angular-cli 工具的操作，它会直接把这个组件也添加到模块文件：</p><p><img alt="自动添加到app.module.ts文件" data-src="/../images/TA/angular-i18n-demo/%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%88%B0app.module.ts%E6%96%87%E4%BB%B6.png" class="lazyload"></p><h3 id="2-3-添加代码："><a href="#2-3-添加代码：" class="headerlink" title="2.3 添加代码："></a>2.3 添加代码：</h3><p>修改<code>register.component.html</code>代码如下：</p><pre><code>&lt;div class=&#39;my-div&#39;&gt;  &lt;mat-toolbar&gt;    &lt;mat-icon&gt;create&lt;/mat-icon&gt;&amp;nbsp;&amp;nbsp; Registration  &lt;/mat-toolbar&gt;  &lt;mat-card&gt;    &lt;mat-card-content&gt;      &lt;form&gt;        &lt;div class=&quot;word-align&quot;&gt;First Name&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;First name&quot; name=&quot;fname&quot; required&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;        &lt;div class=&quot;word-align&quot;&gt;Last Name&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;Last Name&quot; name=&quot;lname&quot; required&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;        &lt;div class=&quot;word-align&quot;&gt;Address&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;Address&quot; name=&quot;address&quot; required&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;        &lt;div class=&quot;word-align&quot;&gt;Email&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;Email&quot; name=&quot;email&quot;&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;        &lt;div class=&quot;word-align&quot;&gt;Password&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;Password&quot; name=&quot;password&quot;&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;        &lt;div class=&quot;word-align&quot;&gt;Confirm Password&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;Confirm Password&quot; name=&quot;confirmPassword&quot;&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;      &lt;/form&gt;    &lt;/mat-card-content&gt;    &lt;mat-card-actions&gt;      &lt;button mat-raised-button (click)=&quot;register()&quot; color=&quot;primary&quot;&gt;REGISTER&lt;/button&gt;    &lt;/mat-card-actions&gt;  &lt;/mat-card&gt;</code></pre><p>修改<code>register.component.scss</code>代码如下：</p><pre><code>// div居中.my-div {  width: 40%;  margin-left: 30%;}// 设定form中label等宽.word-align {  display: inline-block;  text-align: justify;  text-justify: distribute-all-lines; /*ie6-8*/  text-align-last: justify; /* ie9*/  -moz-text-align-last: justify; /*ff*/  -webkit-text-align-last: justify; /*chrome 20+*/  width: 70px;  margin-right: 0px;}</code></pre><p>因为我们不会去实现注册功能，所以在<code>register.component.ts</code>中，只需要添加一个空白注册函数就好了：</p><pre><code>import { Component, OnInit } from &#39;@angular/core&#39;;@Component({  selector: &#39;app-register&#39;,  templateUrl: &#39;./register.component.html&#39;,  styleUrls: [&#39;./register.component.scss&#39;]})export class RegisterComponent implements OnInit {  constructor() { }  ngOnInit() {  }  register() { } // 新建一个空白注册函数}</code></pre><h3 id="2-4-将注册页面显示出来"><a href="#2-4-将注册页面显示出来" class="headerlink" title="2.4 将注册页面显示出来"></a>2.4 将注册页面显示出来</h3><p>现在运行这个 angular 项目，首页看到的还是默认的界面。<br>删除 app.component.html 原本的所有东西，添加一句各个注册组件的 selector：</p><pre><code>&lt;app-register&gt;&lt;/app-register&gt;</code></pre><p>我用<code>ng server -o --port 1234</code>启动，在浏览器中应该看到如下画面：</p><p><img alt="默认的注册画面" data-src="/../images/TA/angular-i18n-demo/%E9%BB%98%E8%AE%A4%E7%9A%84%E6%B3%A8%E5%86%8C%E7%94%BB%E9%9D%A2.png" class="lazyload"></p><p>到这里，常规的注册页面就完成了，是个英文版本，i18n 准备工作就好了，下面开始实现变简体中文。</p><h1 id="修改注册页面为简体中文版本"><a href="#修改注册页面为简体中文版本" class="headerlink" title="修改注册页面为简体中文版本"></a>修改注册页面为简体中文版本</h1><p>在 angular 官方文档中，我们可以看到<a href="https://angular.cn/guide/i18n#template-translations" target="_blank" rel="noopener">i18n 模板翻译分为 4 个阶段</a>,主要就是</p><ol><li>在组件模板中标记需要翻译的静态文本信息。</li><li>创建翻译文件：使用 Angular CLI 的 xi18n 命令，把标记过的文本提取到一个符合行业标准的翻译源文件中。</li><li>编辑所生成的翻译文件：把提取出的文本翻译成目标语言。</li><li>把翻译完成的文件合并回应用</li></ol><p>一步一步来。</p><h2 id="1、组件模板中标记需要翻译的静态文本信息"><a href="#1、组件模板中标记需要翻译的静态文本信息" class="headerlink" title="1、组件模板中标记需要翻译的静态文本信息"></a>1、组件模板中标记需要翻译的静态文本信息</h2><p>常规的标签直接在标签中添加 i18n 关键字即可，如下图：</p><p><img alt="i18n翻译常规标签" data-src="/../images/TA/angular-i18n-demo/i18n%E7%BF%BB%E8%AF%91%E5%B8%B8%E8%A7%84%E6%A0%87%E7%AD%BE.png" class="lazyload"></p><p>要翻译的内容的元素标签中其他内容时，可以使用 ng-container 将文本包裹起来，示例如下：</p><p><img alt="i18n翻译标签内文本" data-src="/../images/TA/angular-i18n-demo/i18n%E7%BF%BB%E8%AF%91%E6%A0%87%E7%AD%BE%E5%86%85%E6%96%87%E6%9C%AC.png" class="lazyload"></p><p>如果是要翻译某个标签的属性值，则需要添加 i18n-&lt;属性名&gt;标签，示例如下：</p><p><img alt="i18n翻译标签内属性" data-src="/../images/TA/angular-i18n-demo/i18n%E7%BF%BB%E8%AF%91%E6%A0%87%E7%AD%BE%E5%86%85%E5%B1%9E%E6%80%A7.png" class="lazyload"></p><p>更多用法参看 angular 官网<a href="https://angular.cn/guide/i18n#template-translations" target="_blank" rel="noopener">i18n 模板翻译</a></p><h2 id="2、创建翻译源文件"><a href="#2、创建翻译源文件" class="headerlink" title="2、创建翻译源文件"></a>2、创建翻译源文件</h2><p>将模板做好标记后，使用指令<code>ng xi18n --output-path &lt;path&gt;</code>,生成翻译源文件，&lt;path&gt;则是文件位置。</p><p>此外还有属性：</p><ul><li>–i18nFormat：明确指定想用的格式（默认 XLIFF 1.2）</li><li>–out-file： 为提取工具生成的翻译源文件改名（默认为 messages ）</li><li>–i18n-locale：指定应用的基本地区（对 angular 没有，但可能对其他需求有用）</li><li>等等</li></ul><p>我的指令是<code>ng xi18n --output-path src/locale --out-file register.zh-Hans.xlf</code>，生成的翻译源文件如下图：</p><p><img alt="生成的翻译源文件" data-src="/../images/TA/angular-i18n-demo/%E7%94%9F%E6%88%90%E7%9A%84%E7%BF%BB%E8%AF%91%E6%BA%90%E6%96%87%E4%BB%B6.png" class="lazyload"></p><h2 id="3、翻译文本节点"><a href="#3、翻译文本节点" class="headerlink" title="3、翻译文本节点"></a>3、翻译文本节点</h2><p>打开生成的翻译源文件，找到文中的<trans-unit>标签，可以看到里面有一个<source>标签，这标签里面的文字，就是需要多国语言需要翻译的文字。</trans-unit></p><p>现在要做的就是，复制<source>标签这一行，放到原本<source>这一行下面，并把它的标签名名为 target，并把它的内容改为需要翻译的语言文字。</p><p>例如，我现在要做的是把英文翻译成简体中文，那么修改示例如下：</p><p><img alt="修改翻译源文件" data-src="/../images/TA/angular-i18n-demo/%E4%BF%AE%E6%94%B9%E7%BF%BB%E8%AF%91%E6%BA%90%E6%96%87%E4%BB%B6.png" class="lazyload"></p><p>注意所有的<source>标签都添加对应的<target>标签。</target></p><p><strong>特别注意：</strong></p><ul><li>翻译源文件里面有很多的 id，而且还特别长.</li><li>这是因为在“1、组件模板中标记需要翻译的静态文本信息”时，没有给每一个标记 i18n 的地方添加 id，所以工具自动生成了随机 id。</li><li>这个 id 最好不要修改，一旦修改可能在文字替换时就对应不上。</li><li>如果模板文件有修改，则可能需要重新再生成一份翻译源文件，因为这些随机 id 可能已经变了。</li></ul><p>当然，如果不嫌麻烦，可以给每个模板文件有标记 i18n 的地方，都给他添加 id，那么生成的翻译源文件的 id 就不会变。</p><p>模板中添加 id 使用示例：</p><pre><code> &lt;div class=&quot;word-align&quot; i18n=&quot;@@firstName&quot;&gt;First Name&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;</code></pre><p><del>(因为工具会生成随机 id，且如果需要翻译的文字太多，逐一设置 id 比较麻烦，所以我没有这样设 id)</del></p><h2 id="4、修改-angular-json-配置文件"><a href="#4、修改-angular-json-配置文件" class="headerlink" title="4、修改 angular.json 配置文件"></a>4、修改 angular.json 配置文件</h2><h3 id="4-1、添加编译配置"><a href="#4-1、添加编译配置" class="headerlink" title="4.1、添加编译配置"></a>4.1、添加编译配置</h3><p>打开 angular.json 文件，找到属性 projects–&gt;{angular-i18n-demo(angular 项目名)}–&gt;architect–&gt;build–&gt;configurations;在 production 同级属性，添加对不同语言的编译配置，如下图：</p><p><img alt="添加i8n多国语言编译配置" data-src="/../images/TA/angular-i18n-demo/%E6%B7%BB%E5%8A%A0i8n%E5%A4%9A%E5%9B%BD%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE.png" class="lazyload"></p><p>配置内容简单说明：</p><ul><li>使用 AOT 方式编译</li><li>文件输出路径</li><li>i18n 文件位置</li><li>i18n 使用的格式</li><li>i18n 的位置</li><li>如果翻译有缺失报警告</li><li>添加基本路径</li></ul><p>最后一条需要多说一点，就是翻译后，例如英文版本编译后访问的地址是<code>http://localhost:4200/register</code>，如果要看到中文版，则需要访问<code>http://localhost:4200/register/zh-Hans</code></p><h3 id="4-2、添加测试运行配置"><a href="#4-2、添加测试运行配置" class="headerlink" title="4.2、添加测试运行配置"></a>4.2、添加测试运行配置</h3><p>同样在 angular.json 文件，就在添加编译配置的父级 build 下一个属性 server，在 server–&gt;configurations 属性，在 production 同级属性，添加以下内容：</p><p><img alt="添加测试运行配置" data-src="/../images/TA/angular-i18n-demo/%E6%B7%BB%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE.png" class="lazyload"></p><p><strong>注意：ng serve 运行时只能一次运行一种语言的翻译，无法同时加载多种语言。</strong></p><h2 id="5、测试运行，查看效果"><a href="#5、测试运行，查看效果" class="headerlink" title="5、测试运行，查看效果"></a>5、测试运行，查看效果</h2><p>到这里，我们就有了一个简体中文版本的注册页面可以看了。<br>启动项目，在项目根目录启动终端输入</p><pre><code>ng serve --configuration=zh-Hans -o --port 1234</code></pre><p>项目启动成功，则可以看到简体中文版注册页面了，如下图:</p><p><img alt="简体中文版注册页面" data-src="/../images/TA/angular-i18n-demo/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E7%89%88%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2.png" class="lazyload"></p><p>注意看 url，之前的英文版是直接的<code>http://localhost:1234</code>，现在简体中文版是<code>http://localhost:1234/zh-Hans</code></p><p>如果觉得每次测试运行查看修改输入文字太长，可以修改 package.json 文件，在 script 属性下，新加一句</p><pre><code>&quot;zh-Hans&quot;: &quot;ng serve --configuration=zh-Hans -o --port 1234&quot;</code></pre><p>就可以使用<code>npm run zh-Hans</code>启动了。</p><p>后续将 angular 项目便已打包部署到服务器例如 nginx，则可以设计点击按钮切换 url，切换语言，<br>就和 MDN 一样效果。</p><p>例如<code>https://developer.mozilla.org/en-US/docs/Glossary/JavaScript</code>是英文，<br>直接修改 url 为<code>https://developer.mozilla.org/zh-CN/docs/Glossary/JavaScript</code>就变成简体了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到这里，angular i18n 多国语言使用说明就基本完了，更多的细节可以去 angular 官方<a href="https://angular.cn/guide/i18n" target="_blank" rel="noopener">国际化 i18n</a>升华。</p><p>总结一下基本步骤：</p><ol><li>准备好需要翻译的页面模板；</li><li>根据需要翻译的页面模板，创建对应的翻译源文件；</li><li>修改翻译源文件，添加<target>标签即内容；</target></li><li>修改 angular 项目的配置；</li><li>运行查看结果。</li></ol><p>源代码已放到<a href="https://github.com/Sanotsu/angular-i18n-demo" target="_blank" rel="noopener">github</a>，已经整理添加了中文繁体、中文简体、英语、百度翻译版本日语，可参考配置 angular i18n 多国语言。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
          <category> angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
            <tag> i18n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Node.js项目打包为一个可执行文件</title>
      <link href="/2019/12/18/TechnicalArticles/pack-nodejs-project/"/>
      <url>/2019/12/18/TechnicalArticles/pack-nodejs-project/</url>
      
        <content type="html"><![CDATA[<p>实际上，nodejs 项目本来不需要做什么打包编译动作的，因为 js 本来也就不是编译型语言，只是个解释型语言，所以只要有 nodejs 运行环境，代码拷过去就能运行。</p><p>但是难免有些机器可能并没有安装 nodejs 运行环境，或者项目代码指定了 nodejs 的运行环境版本与实际不符合，就会多一个步骤去规整化运行环境的问题。</p><p>这本来不是个问题，那么简单打包后，变成一个可执行文件，就可以不用担心运行环境的问题了。</p><p><strong>本文目的：将 Node 项目打包为可执行文件，可以在没有安装 Node.js 运行环境的设备上运行。</strong></p><p>主要介绍两种将 nodejs 项目打包的工具，pkg 和 nexe。</p><h1 id="使用-pkg-打包-nodejs-项目（网上推荐较多）"><a href="#使用-pkg-打包-nodejs-项目（网上推荐较多）" class="headerlink" title="使用 pkg 打包 nodejs 项目（网上推荐较多）"></a>使用 pkg 打包 nodejs 项目（网上推荐较多）</h1><h2 id="注意-pkg-支持的-nodejs-版本问题"><a href="#注意-pkg-支持的-nodejs-版本问题" class="headerlink" title="注意 pkg 支持的 nodejs 版本问题"></a>注意 pkg 支持的 nodejs 版本问题</h2><p><strong>注意：pkg 各个版本所支持的 Node 版本有所不同（主要集中在长期支持版本）。</strong><br>例如最新版本之 pkg4.4 不支持 Node9 版本。</p><p>如何查看 pkg 支持的 nodejs 版本？</p><p>访问 pkg 源码 <a href="https://github.com/zeit/pkg/blob/master/package.json" target="_blank" rel="noopener">package.json</a>,在”dependencies”属性中，查看”pkg-fetch”的版本。这个 pkg-fetch 可以获取的 nodejs 版本，就是 pkg 工具包可以打包的版本。</p><p>例如现在的 pkg 默认是 4.4.2，对应的 pkg-fetch 是 2.6.4，找到 pkg-fetch 对应版本的源文件中的 patches.json 文件，地址[<a href="https://github.com/zeit/pkg-fetch/blob/master/patches/patches.json],得到以下数据：" target="_blank" rel="noopener">https://github.com/zeit/pkg-fetch/blob/master/patches/patches.json],得到以下数据：</a></p><p><img alt="查看pkg支持的nodejs版本" data-src="/../images/TA/pack-nodejs-project/%E6%9F%A5%E7%9C%8Bpkg%E6%94%AF%E6%8C%81%E7%9A%84nodejs%E7%89%88%E6%9C%AC.png" class="lazyload"></p><p>如果安装的 pkg 版本，和实际需要打包的 nodejs 项目的版本不同，则可能会出现类似<code>pkg error no available node version satisfies &#39;node 9&#39;</code>的报错信息。</p><p>为了节约大家的时间，秉承用新不用旧，我简单列举以下(2019/12/17 记)：</p><p>nodejs 版本为 v12、v10、v8、v6、v4、v0.12，用 pkg4.4 版本；<br>nodejs 版本为 v9，用 pkg4.3 版本；<br>nodejs 版本为 v7，用 pkg4.2 版本；</p><p>我好像没找到 pkg-fetch 中的 patches.json 有支持 nodejs v11、v5 版本的，所有就不列示了。</p><p>一般习惯，还是使用长期支持版本的 nodejs 开发为好，这样也可以直接使用最新版本的 pkg 而忽略版本问题了。</p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="全局安装："><a href="#全局安装：" class="headerlink" title="全局安装："></a>全局安装：</h3><pre><code>npm install -g pkg</code></pre><p>安装成功，输入<code>pkg -h</code>就可以看到指令信息了。</p><h3 id="一般操作说明如下："><a href="#一般操作说明如下：" class="headerlink" title="一般操作说明如下："></a>一般操作说明如下：</h3><p>pkg 的基本语法是<code>pkg [options] &lt;input&gt;</code>，那么</p><p><strong>[option] 简单说明：</strong></p><p>-t:指定打包的目标平台和 Node 版本，如-t node12-linux-x64,node12-win-x64,node12-macos-x64.<br>-c：指定一个 JSON 配置文件，用来配置额外的打包脚本或资源。<br>–options:指定 Node 或 V8 运行时选项，打包后默认执行，通过–option name 取消。<br>-o：指定输出可执行文件名称，若使用了-t 指定多个目标，则需要使用—out-path 指定输出路径。<br>-d：输出打包日志，以便排查问题。<br>-b：从 node 源代码编译 node 二进制文件，默认会下载官方预编译的文件，使用该选项便不会有前面说明的 Node 版本支持问题，初次编译会耗用大量时间。</p><p><strong>&lt;input&gt;可通过三种方式指定:</strong></p><p>项目的入口文件如：pkg app.js;<br>项目的 package.json 文件，pkg 会使用 package.json 中配置 bin 属性作为入口文件。<br>项目的路径，pkg 会寻找路径中的 package.json。</p><h3 id="打包项目："><a href="#打包项目：" class="headerlink" title="打包项目："></a>打包项目：</h3><p>我简单的生成一个 express 项目，然后用来说明打包过程</p><p>创建 express 项目（如果没有安装过 express-generator，需要先安装<code>npm install express-generator -g</code>，再使用）</p><pre><code>express node-express-demo</code></pre><p>1、首先在 package.json 中配置 bin 属性作为入口。添加以下属性（express 项目默认入口文件就是./bin/www）：</p><pre><code> &quot;bin&quot;: &quot;./bin/www&quot;</code></pre><p>如存在不能自动打包的文件（如：require（变量）、非 Javascript 文件），则需要通过 pkg 属性手动配置。同样在 package.json 中添加 pkg 属性，类似：</p><pre><code> &quot;pkg&quot;: {    &quot;scripts&quot;: [&quot;xxx&quot;,&quot;xx&quot;],    &quot;assets&quot;: [&quot;xxx&quot;,&quot;xx&quot;]  }</code></pre><p>再执行 pkg 打包命令（注意你的 os 平台和 nodejs 版本，例如我的是 ubuntu 下 nodejs12.16 版本）：</p><pre><code>david@ubuntu:~/TTT/node-express-demo$ pkg -t node12-linux-x64 -o pkg-ned -b package.json&gt; pkg@4.4.2&gt; Building base binary from source:  built-v12.13.1-linux-x64&gt; Cloning Node.js repository from GitHub...  git                          [====================] 100%&gt; Checking out v12.13.1&gt; Applying patches&gt; Compiling Node.js from sources...  make                         [====================] 100%david@ubuntu:~/TTT/node-express-demo$</code></pre><p><strong>这个首次编译打包等待时间可能会有好长，好长，好长，耐心等待一下。别看着没进度就忍不住把它终止了。</strong><br>但这是第一次执行时，后续同样的编译需求，则直接使用缓存的编译环境资源，就几秒钟了。</p><p>pkg 无法自动打包二进制模块文件，该类文件与平台有关，若依赖中包含此类文件需手动复制到打包后可执行文件目录下<br>如 node-java 有编译 nodejavabridge_bindings.node 文件，需从 node_modules/java/build/Release 中复制出来。</p><p>运行打包后文件，程序可正常运行。</p><p>为方便使用，将 pkg 打包命令写入到 package.json,打包时运行 <code>npm run pkg</code>。</p><p>在 package.json 的 script 属性下，加入一句，例如：</p><pre><code>&quot;pkg&quot;: &quot;pkg -t node12-linux-x64 -o pkg-ned -b package.json&quot;</code></pre><p>打包成功后，可以在 nodejs 项目的根目录下看见生成了 pkg-ned 文件，直接运行示例如下：</p><p><img alt="pkg打包文件运行结果" data-src="/../images/TA/pack-nodejs-project/pkg%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" class="lazyload"></p><p>待解决问题：<br>我之前使用成品的项目打包时没有遇到，但是这次直接使用的 express-generator 生成的模板项目打包，则出现了，运行打包后可执行文件，首页访问报错的问题，如下图：</p><p><img alt="pkg打包文件运行访问首页报错" data-src="/../images/TA/pack-nodejs-project/pkg%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E8%AE%BF%E9%97%AE%E9%A6%96%E9%A1%B5%E6%8A%A5%E9%94%99.png" class="lazyload"></p><p>这个问题待我找到原因再补充上。</p><h1 id="使用-nexe-打包-nodejs-项目（实际测试较好用）"><a href="#使用-nexe-打包-nodejs-项目（实际测试较好用）" class="headerlink" title="使用 nexe 打包 nodejs 项目（实际测试较好用）"></a>使用 nexe 打包 nodejs 项目（实际测试较好用）</h1><p>nexe 可以通过命令行将 Node 项目打包为可执行文件。<br><strong>值得一说的是，nexe 预编译之 Node 只有偶数版本，所以例如使用 v9 版本，只能自行编译。</strong></p><p>安装 nexe：<br>npm install -g nexe</p><p>安装成功后，终端输入 <code>nexe -h</code>就可以看到命令格式了。</p><p>一般使用格式是</p><pre><code>nexe &lt;entry-file&gt; [options]</code></pre><p><strong>简单说明[options]:</strong><br>-i：指定 Node 项目入口文件<br>-o：指定输出可执行文件路径名称<br>-t：指定編譯平臺 Node 版本（支援版本）<br>-n：指定主模块名称<br>-r：添加资源文件<br>-a：指定已构建的 nexe 二进制文件<br>–build：从源码编译 Node</p><p>最简单的使用 ，在 nodejs 项目下运行 <code>nexe &lt;入口文件&gt;</code>，例如我的是 .bin/www，但是 nodejs 版本是 9.x</p><pre><code>david@ubuntu:~/TTT/node-express-demo$ nvm use 9.11.2Now using node v9.11.2 (npm v5.6.0)david@ubuntu:~/TTT/node-express-demo$ nexe ./bin/wwwℹ nexe 3.3.2✔ Downloading pre-built Node.js✔ Finished in 1.037sError: https://github.com/nexe/nexe/releases/download/v3.0.0/linux-x64-9.11.2 is not available, create it using the --build flagSee nexe -h for usage..david@ubuntu:~/TTT/node-express-demo$</code></pre><p>因为没有 nodev9 不是预编译版本，所以报错。因此就需要使用–build，如下：</p><pre><code>nexe -i app.js -o nexe-ned -t linux-x64-9.11.2 --build</code></pre><p>需要等待一些时间，还需要联网。整个过程就是下载对应的 node 资源，然后编译，写文件。当然，这也是第一次执行时，后续同样的编译需求，则直接使用缓存的编译环境资源。</p><p>具体显示流程如下：</p><pre><code>david@ubuntu:~/TTT/node-express-demo$ nexe -i ./bin/www -o nexe-ned -t linux-x64-9.11.2 --buildℹ nexe 3.3.2✔ Node source extracted to: /home/david/.nexe/9.11.2✔ Node binary compiled✔ Entry: &#39;bin/www&#39; written to: nexe-ned✔ Finished in 2057.42sdavid@ubuntu:~/TTT/node-express-demo$</code></pre><p>运行效果如下：</p><p><img alt="运行nexe打包后文件" data-src="/../images/TA/pack-nodejs-project/%E8%BF%90%E8%A1%8Cnexe%E6%89%93%E5%8C%85%E5%90%8E%E6%96%87%E4%BB%B6.png" class="lazyload"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总结起来，感觉使用 nexe 效果更好一点：<br>首先没有版本限制，只是看能不能预编译(LTS 版本有预编译)；<br>额外的配置需求相对较少；<br>测试模板项目测试没有出现意外；<br>首次编译打包的时间相对较短很多。</p><p>当然这只是我的个人看法，也有人询问过 nexe 和 pkg 的<a href="https://github.com/zeit/pkg/issues/42" target="_blank" rel="noopener">区别</a>,也引用如下：</p><blockquote><p>nexe:</p><ul><li>Bundles the application if desired using webpack.</li><li>Downloads node source (or a prebuilt binary)</li><li>Adds your application bundle as a native module (like fs, http, path etc)</li><li>Applies arbitrary source patches.</li><li>Maybe compiles downloaded source</li><li>Inserts bundle into pre-sized binary</li><li>Code is run as main when executable is run (instead of the repl)</li></ul></blockquote><blockquote><p>pkg:</p><ul><li>Bundles the application with a custom v8 script compiler into a snapshot</li><li>Downloads the node source (or a prebuilt binary)</li><li>Applies arbitrary source patches</li><li>Maybe compiles downloaded source</li><li>Appends snapshotted output to the end of the binary</li><li>Snapshot (cachedData from v8) is loaded/run when binary executes.</li></ul></blockquote><p><del>(以上可窥见 pkg 打包文件首页访问出错原因)</del></p><p>不过两者都是不错的 nodejs 打包工具了，有需求都可能尝试一下。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> pkg </tag>
            
            <tag> nexe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Verdaccio 搭建 npm 私有仓储</title>
      <link href="/2019/12/18/TechnicalArticles/verdaccio-private-registry/"/>
      <url>/2019/12/18/TechnicalArticles/verdaccio-private-registry/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 2018 年 1 月份的时候，我有开始搭建 npm 私有仓库，那个时候的 Sinopia 也已经停止维护 3 年了，而 verdaccio 还可能不是特别受欢迎，只有 1700 个 star，搭建 npm 私有仓库的工具还有不少。</p><p><img alt="2018年1月的verdaccio" data-src="/../images/TA/verdaccio-private-registry/2018%E5%B9%B41%E6%9C%88%E7%9A%84verdaccio.png" class="lazyload"></p><p>但在我今天写此文的时候，已经有 8.5K 的 star 了，版本也从 2.7.1 更新到了 4.4，而且基本上没有别的比较好的选择可以替代了。</p><p><del>无营养的话，两年前 sinopia 有 4318 个 star，现在还是增加为 5.3k 了，即便一直没更新，优秀的作品依旧优秀。</del></p><h1 id="安裝使用-Verdaccio（本文是在-Ubuntu-下）"><a href="#安裝使用-Verdaccio（本文是在-Ubuntu-下）" class="headerlink" title="安裝使用 Verdaccio（本文是在 Ubuntu 下）"></a>安裝使用 Verdaccio（本文是在 Ubuntu 下）</h1><p>1、安裝 verdaccio</p><p>verdaccio 是个发布在 npm 上的命令行工具。可以通过 npm 直接下载安装：</p><pre><code>npm install -g verdaccio</code></pre><p>2、開啓服務<br>verdaccio 在文件系统上存储数据，没有额外依赖，而且提供了一套默认配置，我们可以直接启动仓储服务。</p><p>在终端直接输入：</p><pre><code>verdaccio</code></pre><p><img alt="启动verdaccio" data-src="/../images/TA/verdaccio-private-registry/%E5%90%AF%E5%8A%A8verdaccio.png" class="lazyload"></p><p>终端上的日志显示了默认配置文件路径和 verdaccio 工作的地址端口。</p><p>3、查看安裝成功效果<br>浏览器打开<a href="http://localhost:4873/" target="_blank" rel="noopener">http://localhost:4873/</a> ，页面如下：</p><p><img alt="verdaccio启动成功画面" data-src="/../images/TA/verdaccio-private-registry/verdaccio%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E7%94%BB%E9%9D%A2.png" class="lazyload"></p><p>不得不说，这比两年前有自我辨识度，之前看起来就像是山寨 npmjs。</p><p>4、修改 npm 默认仓库地址</p><p>不过目前直接使用的 npm install 还是会去找 npmjs 的，所以，如果需要将默认寻找的地址改为自己的私有仓库，则需要修改 npm 默认的仓库地址，修改如下：</p><pre><code>npm set registry http://localhost:4873/</code></pre><p>查看有没有修改成功，使用<code>npm get registry</code>，查看显示的地址即可。</p><p>5、卸载 verdaccio</p><p>当然，如果不想用了，就是一个 npm 下载的工具包而已，直接卸载即可：</p><pre><code>npm uninstall -g verdaccio</code></pre><h1 id="常规的配置说明"><a href="#常规的配置说明" class="headerlink" title="常规的配置说明"></a>常规的配置说明</h1><p>配置文件一般在<code>home/{user}/.config/verdaccio/config.yaml</code>，把{user}替换成你的主机用户名。</p><p>简单说明如下（注意与实际配置对比参看）：</p><pre><code>- storage: 设置托管或缓存包的存放目录- auth: 权限控制  - htpasswd: 启用 htpasswd 插件管理权限  - file: 制定 htpasswd 文件路径，htpasswd 中存储者用户名和加密过的秘钥  - max\*users: 最多允许注册用户数- uplinks: 设置外部仓储，如果 verdaccio 找不到请求的包（非 verdaccio 托管），就会查找外部仓储。常见的有  - {name}: 外部仓储名称    - url: 访问路径    - timeout: 超时    - maxage: 默认值 2m，2m 钟内不会就同样的请求访问外部仓储    - fail\*timeout: 如果外部访问失败，在多长时间内不回重试    - headers: 添加自定义 http 头当外部仓储访问请求中，例如 authorization: &quot;Basic YourBase64EncodedCredentials==&quot;    - cache: 是否启用缓存，默认启用。      # 常用仓储有      npmjs:        url: https://registry.npmjs.org      yarnjs:        url: https://registry.yarnpkg.com      cnpmjs:        url: https://registry.npm.taobao.org- packages: 包访问或发布控制  - {regexp}: 包名匹配正则。    - access: 访问控制，可选值有      - \$all（用户不限制）,      - \$anonymous（用户不限制）,      - \$authenticated（所有登录用户）,        username( 用户名，需指定具体用户，可指定多个用户，用户间空格隔开，如 secret super-secret-area ultra-secret-area)。    - publish: 发布控制，    - proxy: 代理控制，设置的值必选现在 uplinks 中定义。    # 常用的包名正则有：    \*\*            # 匹配任意包    @\*/\_          # 匹配任意 scope 包    @npmuser/\_     # 匹配 scope 为 npmuser 的包    npmuser-\*      # 匹配包名有 npmuser- 前缀的包    # 包名正则规范通 gitignore 一致，verdaccio 内部使用 minimatch 实现的，如果需要书写更复杂的正则，可以参考 [minimatch](https://www.npmjs.com/package/minimatch/) 文档。- web: 前端展示页面控制  - title: 设置页面标题  - logo: 指定 logo 图片文件路径- publish: 发布包是的全局配置  - allow_offline: 在外部仓储离线时是否允许发布。在发布包是 verdaccio 会检查依赖包有效性，这个过程中需要访问外部仓储。- url_prefix: 设置资源文件路径前缀。默认不需要设置，但如果使用 nginx 代理并改写了请求路径，就需要指定了。  - listen: 设置服务运行地址端口，默认为 http://localhost:4873    支持的配置有：    localhost:4873              # default value    http://localhost:4873       # same thing    0.0.0.0:4873                # listen on all addresses (INADDR_ANY)    https://example.org:4873    # if you want to use https    [::1]:4873                  # ipv6    unix:/tmp/verdaccio.sock    # unix socket- https: HTTPS 证书配置  - key: path/to/server.key  - cert: path/to/server.crt  - ca: path/to/server.pem- log: 日志控制  - type: file, stdout, stderr, 其中 stdout 需要同时指定 path  - level: trace | debug | info | http (default) | warn | error | fatal  - format: json | pretty | pretty-timestamped- http_proxy: 设置以 http 形式访问外部仓储时使用的代理- https_proxy: 设置以 https 形式访问外部仓储时使用的代理- no_proxy: 不使用代理的请求路径- max_body_size: 请求时上传的 json 允许的最大值- notify: 当有包发布成功时，verdaccio 会发送通知。通知实际上是一次 http 请求。支持配置多套通知  - method: 请求方法 GET,POST 等 HTTP Method  - packagePattern: 包匹配正则， 这儿为 js 正则，仅当发布的包名匹配正则时才发送通知  - packagePatternFlags: js 正则标志位，如 i 忽略大小写  - headers: 自定义请求头  - endpoint: 请求地址  - content: handlebar 格式 html 模板，可以使用变量详见 Package Metadata</code></pre><h1 id="上传私有包"><a href="#上传私有包" class="headerlink" title="上传私有包"></a>上传私有包</h1><p>1、创建包</p><p>新建一个文件夹，并<code>npm init</code>，再创建一个 index.js 文件，内容如下图，将此包示例为个人私有包。</p><p><img alt="私有package示例文件" data-src="/../images/TA/verdaccio-private-registry/%E7%A7%81%E6%9C%89package%E7%A4%BA%E4%BE%8B%E6%96%87%E4%BB%B6.png" class="lazyload"></p><p>2、发布包</p><p>首先在私有仓库服务器注册一个用户，此处注册成功会自动登入仓库，输入注册语句（之前访问<code>http://localhost:4873</code>上面有显示）：</p><pre><code>david@ubuntu:~$ npm adduser --registry http://localhost:4873Username: davidPassword:Email: (this IS public) 183318×××@qq.comLogged in as david on http://localhost:4873/.david@ubuntu:~$</code></pre><p>如果之前有注册用户，此处可以直接登入</p><pre><code>david@ubuntu:~$ npm login --registry http://localhost:4873Username: davidPassword:Email: (this IS public) 183318×××@qq.comLogged in as david on http://localhost:4873/.david@ubuntu:~$</code></pre><p>登入成功之后，在刚刚创建的私有包的根目录下，运行发布包命令 npm publish，即可将包发布到私有仓库。</p><p><strong>如果没有设定本机默认的 npm 仓库是指定的私有仓库，最好还是指定仓库位置，否则有可能是发布到 npmjs 上去。</strong></p><pre><code>david@ubuntu:~/TTT/privatePackage$ npm publish --registry http://localhost:4873npm noticenpm notice 📦  privatepackage@1.0.0npm notice === Tarball Contents ===……省略一些npm notice……npm notice+ privatepackage@1.0.0david@ubuntu:~/TTT/privatePackage$</code></pre><p>发布成功之后，再访问<code>http://localhost:4873</code>页面，就能看到已发布的私有包了。</p><p><img alt="私有仓库可见私有包" data-src="/../images/TA/verdaccio-private-registry/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%8F%AF%E8%A7%81%E7%A7%81%E6%9C%89%E5%8C%85.png" class="lazyload"></p><p>当然后续下载使用，就和访问 npmjs 公共包是一样的。</p><h1 id="其他常用操作与配置"><a href="#其他常用操作与配置" class="headerlink" title="其他常用操作与配置"></a>其他常用操作与配置</h1><h2 id="使用-pm2-启动"><a href="#使用-pm2-启动" class="headerlink" title="使用 pm2 启动"></a>使用 pm2 启动</h2><p>verdaccio 毕竟还是一个 nodejs 程序，直接在命令行输入<code>verdaccio</code>启动了，保不齐因为何种原因崩溃。这类守护型工具，常用的就例如 forever 或者 pm2。<br>以 pm2 为例，用最简单的<code>pm2 start {program}</code>来启动。</p><p>全局安装：</p><pre><code>npm install pm2 -g</code></pre><p>使用 pm2 start。 start 后跟 verdaccio 全局安装的启动地址：</p><pre><code>pm2 start {/home/david/.nvm/versions/node/v12.6.0/lib/node_modules/verdaccio/bin/verdaccio}</code></pre><p>如果不知道自己 mpnjs 全局安装的 package 的位置，输入<code>npm config ls -l</code>；找到参数 prefix.</p><p>例如我的就是<code>prefix = &quot;/home/david/.nvm/versions/node/v12.6.0&quot;</code>.那么我的 start 的路径就是：<code>/home/david/.nvm/versions/node/v12.6.0/lib/node_modules/verdaccio/bin/verdaccio</code>，如下图：</p><p><img alt="pm2启动verdaccio" data-src="/../images/TA/verdaccio-private-registry/pm2%E5%90%AF%E5%8A%A8verdaccio.png" class="lazyload"></p><h2 id="浏览器显示公共包"><a href="#浏览器显示公共包" class="headerlink" title="浏览器显示公共包"></a>浏览器显示公共包</h2><p>之前有说明，如果你把 verdaccio 私有仓库设为默认仓库，如果某个 package 在私有仓库没有找到，可以设定在链接的外部仓库去寻找，例如我全局安装了一个 doctoc 工具，<code>npm install -g doctoc</code>。</p><pre><code>david@ubuntu:~$ npm i -g doctoc/home/david/.nvm/versions/node/v12.6.0/bin/doctoc -&gt; /home/david/.nvm/versions/node/v12.6.0/lib/node_modules/doctoc/doctoc.js+ doctoc@1.4.0updated 1 package in 7.961sdavid@ubuntu:~$</code></pre><p>因为我最开始，已经把 npm 的默认仓库地址改为私有地址了，又在配置文件中默认连接了 npmjs，所以执行这一句之后，<strong>首先在 verdaccio 的 storage 的位置找，找不到 doctoc，然后会去 npmjs (配置文件中的 uplinks 参数)去寻找，找到之后下载下来，也存放了一份到 storage 的位置。</strong></p><p>现在去配置文件设置的 storage 的地址，应该是可以看到 doctoc 工具包，同样可以看到之前上传的 privatepackage 私有包：</p><p><img alt="私有仓库下的私有包和公有包" data-src="/../images/TA/verdaccio-private-registry/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E4%B8%8B%E7%9A%84%E7%A7%81%E6%9C%89%E5%8C%85%E5%92%8C%E5%85%AC%E6%9C%89%E5%8C%85.png" class="lazyload"></p><p>当然，从安装结果可以看到，只是个索引，真实位置还是在 npm 全局安装的位置。</p><p>但是访问<code>http://localhost:4873</code>默认是不会显示的，一定程度来讲，共有的包也不必要显示在自家私有仓库内。</p><p>如果非要显示，也是可以的，修改显示的列表文件。</p><p>找到<code>.verdaccio-db.json</code>文件，默认就在私有仓库的设定 storage 的位置，verdaccio 默认位置<code>~/.local/share/verdaccio/storage/.verdaccio-db.json</code>.打开之后，把需要显示的包名，添加到 list 变量的对象中，<br>如下图：</p><p><img alt="修改.verdaccio-db.json文件" data-src="/../images/TA/verdaccio-private-registry/%E4%BF%AE%E6%94%B9.verdaccio-db.json%E6%96%87%E4%BB%B6.png" class="lazyload"></p><p>然后在重启 verdaccio。如果使用了 pm2，按上述说明作业，直接 <code>pm2 restart verdaccio</code>即可。如果还没有使用 pm2，直接关闭 verdaccio 的命令窗口在启动就好。</p><p>再访问<code>http://localhost:4873</code>，就可以看到 doctoc 包了，如下图：</p><p><img alt="公共包可见" data-src="/../images/TA/verdaccio-private-registry/%E5%85%AC%E5%85%B1%E5%8C%85%E5%8F%AF%E8%A7%81.png" class="lazyload"></p><p>以上实践有效，如果有问题，可提出交流，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> verdaccio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular Schematics 简明教程</title>
      <link href="/2019/12/12/TechnicalArticles/angular-schematics-tutorial/"/>
      <url>/2019/12/12/TechnicalArticles/angular-schematics-tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="angular-schematics-101-基本内容说明"><a href="#angular-schematics-101-基本内容说明" class="headerlink" title="angular schematics 101 :基本内容说明"></a>angular schematics 101 :基本内容说明</h1><h2 id="基础三问-angular-schematics-是什么-有什么用-怎么用"><a href="#基础三问-angular-schematics-是什么-有什么用-怎么用" class="headerlink" title="基础三问:angular schematics 是什么?有什么用?怎么用?"></a>基础三问:angular schematics 是什么?有什么用?怎么用?</h2><a id="more"></a><h3 id="angular-schematics-是什么"><a href="#angular-schematics-是什么" class="headerlink" title="angular schematics 是什么?"></a>angular schematics 是什么?</h3><p>首先要知道什么是 schematics(原理图):<br>angular 官方文档说明:</p><blockquote><p>①: 原理图是一个基于模板的支持复杂逻辑的代码生成器。它是一组通过生成代码或修改代码来转换软件项目的指令。 原理图会打包成集合（collection）并用 npm 安装。<br>②: 原理图的集合可以作为一个强大的工具，以创建、修改和维护任何软件项目，特别是当要自定义 Angular 项目以满足你自己组织的特定需求时。例如，你可以借助原理图来用预定义的模板或布局生成常用的 UI 模式或特定的组件。你也可以使用原理图来强制执行架构规则和约定，让你的项目保持一致性和互操作性。</p></blockquote><p>所以 <strong>简单来讲,angular schematics 就是 angular 生态圈中,针对 angular 项目的代码生成器。</strong></p><h3 id="所以-angular-schematics-只是模板代码生成器"><a href="#所以-angular-schematics-只是模板代码生成器" class="headerlink" title="所以 angular schematics 只是模板代码生成器?"></a>所以 angular schematics 只是模板代码生成器?</h3><p>不可否则,schematics 最主要的作用就是代码生成器.有很多模板代码结构内容都是一样的,例如 component,每次新建一个 component,都需要复制上一份的代码进行修改.</p><p>angular-cli 默认有一些可以按照模板生成的组件,例如 componet、router、service、interceptor 等等，这也是很多插件工具一键生成模板代码的依据。但是并不是所有代码都适合所有开发者。例如有些使用者常与 CURD 打交道，所以希望生成的 service 直接包含所有的 CRUD 函数，输入不同的名称对应生成不同产品。等等各自自适应、自构建的模板。</p><p>除此之外，它还能用于按照一定规则修改程式代码、快速按照所需模块等，就如引用的 angular 官方文档说明的第 ② 点。毕竟至少对应到了 ng generate 、 ng add 和 ng update 指令。</p><h3 id="简单上手-angular-schematics：创建一个-hello"><a href="#简单上手-angular-schematics：创建一个-hello" class="headerlink" title="简单上手 angular schematics：创建一个 hello"></a>简单上手 angular schematics：创建一个 hello</h3><p>1、全局安装 schematics cli（需要 node 6.9 以上版本）</p><pre><code>npm install -g @angular-devkit/schematics-cli</code></pre><p>安装完成之后，可以在终端输入<code>schmatics</code>命令，能显示 schematics 的指令说明则表示安装成功。</p><p>2、创建一个空的原理图</p><pre><code>schematics blank --name=hello</code></pre><p>生成的原理图中基本内容结构可参看官网说明<a href="https://angular.cn/guide/schematics-authoring#collection-contents" target="_blank" rel="noopener">集合的内容</a>和<a href="https://angular.cn/guide/schematics-authoring#named-schematics" target="_blank" rel="noopener">命名原理图</a><br>简单说明如下：<br><img alt="schematics說明.png" data-src="/../images/TA/angular-schematics-tutorial/screenshots/schematics%E8%AF%B4%E6%98%8E.png" class="lazyload"><br><img alt="保持一致" data-src="/../images/TA/angular-schematics-tutorial/screenshots/%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4.png" class="lazyload"></p><p>collection.json 配置一般一个原理图就只配置一次，所以大部分内容都是在 index.ts 中实现，所以，一定先清楚这个文件的内容：<br>具体可以参看官方说明<a href="https://angular.cn/guide/schematics-authoring#schematics-concepts" target="_blank" rel="noopener">原理图的概念</a><br>简单说明如下：<br><img alt="原理图基本概念說明" data-src="/../images/TA/angular-schematics-tutorial/screenshots/%E5%8E%9F%E7%90%86%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E.png" class="lazyload"></p><p>3、运行原理图<br>因为创建的是一个空白原理图，运行是不会有任何输出显示的。</p><p>3.1 在当前位置运行：<br>先构建：</p><pre><code>npm run build</code></pre><p>再运行</p><pre><code>schematics .:hello</code></pre><p>简单说明：<br>ts 代码在编译之后转换成 js 代码才能运行，在原理图中，在执行<code>npm run build</code>之后，<br>会出现其他的 XXX.d.ts、XXX.js、XXX.js.map。<br>运行时，<code>.:hello</code>的<code>.</code>是当前位置，<code>hello</code>则是在 collection.json 中配置的原理图的名字。<br>当然，一份 collection.json 中可以配置多个原理图，所以要指定使用的是哪一个。</p><p>“Nothing to be done.”显然没有任何意义，我们可以在 index.ts 中加入一句打印，看看效果：</p><pre><code>export function hello(_options: any): Rule {  return (tree: Tree, _context: SchematicContext) =&gt; {    console.log(&quot;hello&quot;);    return tree;  };}</code></pre><p>那么再次编译运行之后，就可以看到输入的是：</p><pre><code>david@ubuntu:~/TTT/hello$ schematics .:hellohelloNothing to be done.david@ubuntu:~/TTT/hello$</code></pre><p>3.2 在相对路劲下运行<br>如果现在不在 hello 下运行了，那么就不能直接.:<schematics-name>了，需要找到该原理图的 collection.json 文件，并指定使用哪一个。<br>例如在 hello 同级目录下新建个 test 文件夹，在 test 中运行则是：</schematics-name></p><pre><code>david@ubuntu:~/TTT/test$ schematics ../hello/src/collection.json:hellohelloNothing to be done.david@ubuntu:~/TTT/test$</code></pre><p>以上就是 angular schematics 的基础说明和运行，是不是毫无实际意义？没错。接下来，我们开始进入有点实际作用的内容。</p><h1 id="angular-schematics-实现-ng-generator-使用模板生成组件"><a href="#angular-schematics-实现-ng-generator-使用模板生成组件" class="headerlink" title="angular schematics 实现 ng generator 使用模板生成组件"></a>angular schematics 实现 ng generator 使用模板生成组件</h1><p>本节会实现，在 angular 项目中，使用 ng generator 指令生成一个通用的 component 组件，和一般向后台请求数据需要包含 CRUD 函数的 service 组件。here we go。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>新建一个空白 schematics，如下：</p><pre><code>schematics blank --name=angular-schematics-tutorial</code></pre><p>将原本的内容：</p><p><img alt="空白項目修改前" data-src="/../images/TA/angular-schematics-tutorial/screenshots/%E7%A9%BA%E7%99%BD%E9%A0%85%E7%9B%AE%E4%BF%AE%E6%94%B9%E5%89%8D.png" class="lazyload"></p><p>修改为：</p><p><img alt="修改后" data-src="/../images/TA/angular-schematics-tutorial/screenshots/%E4%BF%AE%E6%94%B9%E5%90%8E.png" class="lazyload"><br>为了方便，不用每次修改都运行 build，在此项目的 package.json 的 script 加入一行：</p><pre><code>&quot;build:watch&quot;: &quot;tsc -p tsconfig.json --watch&quot;</code></pre><p>使得该项目一致在 watch 状态下，然后运行</p><pre><code>npm run build:watch</code></pre><p>准备工作完成，进入正题。</p><h2 id="实现创建通用-component-组件"><a href="#实现创建通用-component-组件" class="headerlink" title="实现创建通用 component 组件"></a>实现创建通用 component 组件</h2><p>一般每个命令原理图都包含以下内容：</p><blockquote><p>index.ts： 定义命名原理图中转换逻辑的代码。<br>schema.json： 原理图变量定义。<br>schema.d.ts： 原理图变量。<br>files/： 要复制的可选组件/模板文件。</p></blockquote><p>我们的也不例外。</p><h3 id="创建-component-文件模板-template"><a href="#创建-component-文件模板-template" class="headerlink" title="创建 component 文件模板 template"></a>创建 component 文件模板 template</h3><p>一般 angular component 会包含 4 个文件：XXX.html，XXX.scss，XXX.spec.ts，XXX.ts。所以，先准备好这些模板。</p><p>在/component 文件夹下新建 files 文件夹，并创建以下 4 个文件，效果如下：</p><p><img alt="component的模板文件" data-src="/../images/TA/angular-schematics-tutorial/screenshots/component%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6.png" class="lazyload"></p><p>简单说明两个函数：</p><blockquote><p>classify() 方法接受一个值，并返回标题格式（title case）的值。比如，如果提供的名字是 my service，它就会返回 MyService。<br>dasherize() 方法接受一个值，并以中线分隔并小写的形式返回值。比如，如果提供的名字是 MyService，它就会返回 “my-service” 的形式。</p></blockquote><p>此 component 模块的效果就是，在新建一个 component 时，输入 component 的名字，例如 apple，则会在该 angular 项目的 src/app/下，新建一个文件夹 apple，下面 4 个文件 apple.component.html， apple.component.scss，apple.component.spec.ts，apple.component.ts。</p><p>模板内容分别如下：<br><code>__name@dasherize__.component.html.template文件：</code></p><pre><code>&lt;p&gt;  &lt;%= dasherize(name) %&gt; works!&lt;/p&gt;</code></pre><p><code>__name@dasherize__.component.spec.ts.template文件：</code></p><pre><code>/* tslint:disable:no-unused-variable */import { async, ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;import { By } from &#39;@angular/platform-browser&#39;;import { DebugElement } from &#39;@angular/core&#39;;import { &lt;%= classify(name) %&gt;Component } from &#39;./&lt;%= dasherize(name) %&gt;.component&#39;;describe(&#39;&lt;%= classify(name) %&gt;Component&#39;, () =&gt; {  let component: &lt;%= classify(name) %&gt;Component;  let fixture: ComponentFixture&lt;&lt;%= classify(name) %&gt;Component&gt;;  beforeEach(async(() =&gt; {    TestBed.configureTestingModule({      declarations: [&lt;%= classify(name) %&gt;Component]    })      .compileComponents();  }));  beforeEach(() =&gt; {    fixture = TestBed.createComponent(&lt;%= classify(name) %&gt;Component);    component = fixture.componentInstance;    fixture.detectChanges();  });  it(&#39;should create&#39;, () =&gt; {    expect(component).toBeTruthy();  });});</code></pre><p><code>__name@dasherize__.component.ts.template文件：</code></p><pre><code>import { Component, OnInit } from &#39;@angular/core&#39;;@Component({  selector: &#39;app-&lt;%= dasherize(name) %&gt;&#39;,  templateUrl: &#39;./&lt;%= dasherize(name) %&gt;.component.html&#39;,  styleUrls: [&#39;./&lt;%= dasherize(name) %&gt;.component.scss&#39;]})export class &lt;%=classify(name)%&gt;Component implements OnInit {  constructor() { }  ngOnInit() {  }}</code></pre><p>scss 部分就没有必要了。<br>此部分内容，可参考 angular-cli 源代码内容：<a href="https://github.com/angular/angular-cli/tree/master/packages/schematics/angular/component/files/__name%40dasherize%40if-flat__" target="_blank" rel="noopener">angular-cli component 组件模板</a></p><h3 id="配置-schema-json-定义该原理图可用选项"><a href="#配置-schema-json-定义该原理图可用选项" class="headerlink" title="配置 schema.json,定义该原理图可用选项"></a>配置 schema.json,定义该原理图可用选项</h3><p>在 component 文件夹下新建 schema.json，并输入以下内容：</p><pre><code>{    &quot;$schema&quot;: &quot;http://json-schema.org/schema&quot;,    &quot;id&quot;: &quot;componentSchema&quot;,    &quot;title&quot;: &quot;component options schema.&quot;,    &quot;type&quot;: &quot;object&quot;,    &quot;descripiton&quot;: &quot;创建一个component范本&quot;,    &quot;properties&quot;: {        &quot;name&quot;: {            &quot;description&quot;: &quot;component的名字.&quot;,            &quot;type&quot;: &quot;string&quot;,            &quot;$default&quot;: {                &quot;$source&quot;: &quot;argv&quot;,                &quot;index&quot;: 0            },            &quot;x-prompt&quot;: &quot;你想创建的component的名字:&quot;        }    },    &quot;required&quot;: [        &quot;name&quot;    ]}</code></pre><p>属性说明：</p><blockquote><p>id：这个模式定义在集合中的唯一 id。<br>title：一个人类可读的模式描述。<br>type：由这些属性提供的类型描述符。<br>properties：一个定义该原理图可用选项的对象。<br>required：必填的选项</p></blockquote><p>注意属性(proerties)选项：<br>　　$default 的设定，上面的表示，如果没有指定输入的选项，那么输入的第一个就是 name<br>　　 x-prompt：如果没有输入选项，则提示语提示输入</p><p><strong>创建好 schema.json 之后，一定要记得在 collection.json 中配置 schema 属性</strong></p><p><img alt="在collection中配置schema" data-src="/../images/TA/angular-schematics-tutorial/screenshots/%E5%9C%A8collection%E4%B8%AD%E9%85%8D%E7%BD%AEschema.png" class="lazyload"></p><h3 id="创建-schema-d-ts-定义的各个选项的值"><a href="#创建-schema-d-ts-定义的各个选项的值" class="headerlink" title="创建 schema.d.ts,定义的各个选项的值"></a>创建 schema.d.ts,定义的各个选项的值</h3><p>一般的，可以手动创建 schema.d.ts，如本生成 component 的原理图，它的 schema.json 中属性只有一个必填的 name，那么编写的 schema.d.ts 内容就如下：</p><pre><code>export interface Schema {    name: string;}</code></pre><p>实际上，这个文件可以使用指令生成，在 schema.json 的同级目录下，开启终端输入指令，如下：</p><pre><code>npx -p dtsgenerator dtsgen schema.json -o schema.d.ts</code></pre><p>效果如下<br><img alt="自动生成schema.d.ts文件.png" data-src="/../images/TA/angular-schematics-tutorial/screenshots/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90schema.d.ts%E6%96%87%E4%BB%B6.png" class="lazyload"></p><p>但注意，<strong>生成之后把 declare 改成 export</strong>，因为需要把这接口导出使用。</p><h3 id="编写规则工厂逻辑代码"><a href="#编写规则工厂逻辑代码" class="headerlink" title="编写规则工厂逻辑代码"></a>编写规则工厂逻辑代码</h3><p>以上都定义完之后，便到了最重要的环节，编写逻辑代码实现 componet 组件的生成。</p><p>简单分析，至少我们有以下几步工作需要完成：<br>第一步：判断目标项目是不是 angular 项目。如果不在 angular 项目中去生成 angular 的 componet，那就没什么意义。这一步可以提出来通用。<br>　　同理，@schematics 对 angular 有很多的已有支持，我们这里可以用到一些便捷的方法，所以需要先安装@schematics/angular，输入指令如下：</p><pre><code>npm install @schematics/angular -S</code></pre><p>第二步：读取预设的模板 template 文件，并将使用者输入选项应用到模板。<br>第三步：合并模板文件，返回新的 tree。</p><p>修改 index.ts 代码具体如下：</p><pre><code>import {  Rule, SchematicContext, Tree,  apply, mergeWith, url,  move,  applyTemplates, SchematicsException} from &#39;@angular-devkit/schematics&#39;;import { strings } from &#39;@angular-devkit/core&#39;;import { ComponentSchema as Schema } from &#39;./schema&#39;import { buildDefaultPath } from &#39;@schematics/angular/utility/project&#39;;import { parseName } from &#39;@schematics/angular/utility/parse-name&#39;;export function genComponent(_options: Schema): Rule {  return (tree: Tree, _context: SchematicContext) =&gt; {    // 获取到在angular cli工作区下的 路劲和要生成的组件 前缀name    const { name, path } = getParsePath(tree, _options);    // 读取模板文件    const sourceTemplates = url(&#39;./files&#39;);    // 应用模板文件    const sourceParametrizedTemplates = apply(sourceTemplates, [      applyTemplates({        ..._options,        ...strings,        name      }),      move(path)    ]);    // 将传入的值(option)与模板文件合并(传入值替代模板变量值)    return mergeWith(sourceParametrizedTemplates)(tree, _context);  };}function getParsePath(tree: Tree, options: any): any {  // 读取angular.json文件并存为buffer  const workspaceConfigBuffer = tree.read(&quot;angular.json&quot;)  // 判断是不是在一个angular-cli工作区  if (!workspaceConfigBuffer) {    throw new SchematicsException(&#39;不在angular cli工作区,请在angular项目中执行!&#39;)  }  // 读取并整理angular配置  const workspaceConfig = JSON.parse(workspaceConfigBuffer.toString());  // 有传入project属性或者是默认project  const projectName = options.project || workspaceConfig.defaultProject;  // 获取project定义  const project = workspaceConfig.projects[projectName];  // 获取默认project路径  const defaultProjectPath = buildDefaultPath(project);  // parseName()可以把路径和文件名拆开,取得path和name  // 例如 src/feartures/login,会被拆分为 path:src/features 和 name:login  const parsePath = parseName(defaultProjectPath, options.name);  return parsePath;}</code></pre><p>像上述的<code>buildDefaultPath</code>，<code>parseName</code>方法就是@schematics/angular 中提供的。</p><h3 id="编写测试用例测试代码"><a href="#编写测试用例测试代码" class="headerlink" title="编写测试用例测试代码"></a>编写测试用例测试代码</h3><p>这个测试方面的内容也是个大项，这里就不多说明，简单说一下我们的测试用例。<br>我的测试就是模拟生成一个 angular 项目，然后看看是否在里面生成了 component 的那 4 个文件，若有生成，那么通过，否则就失败。<br>修改 index_spec.ts 代码如下：</p><pre><code>import * as path from &#39;path&#39;;import { SchematicTestRunner, UnitTestTree } from &#39;@angular-devkit/schematics/testing&#39;;import { Schema as ApplicationOptions, Style } from &#39;@schematics/angular/application/schema&#39;;import { Schema as WorkspaceOptions } from &#39;@schematics/angular/workspace/schema&#39;;import { strings } from &#39;@angular-devkit/core&#39;;const collectionPath = path.join(__dirname, &#39;../collection.json&#39;);describe(&#39;component&#39;, () =&gt; {  // 选项 --name的值  const name = &#39;apple&#39;;  const runner = new SchematicTestRunner(&#39;schematics&#39;, collectionPath);  // 模拟ng new创建angular项目，主要对workspace和application进行配置  // angular项目的配置  const workspaceOptions: WorkspaceOptions = {    name: &#39;workspace&#39;,              // 不重要的名字，随意取，不影响测试结果    newProjectRoot: &#39;projects&#39;,     // 项目app的根目录，可以随意取，但是验证会用到    version: &#39;6.0.0&#39;,               // 版本号，随意，不影响测试  };  const appOptions: ApplicationOptions = {    name: &#39;component&#39;,              // 项目名称    inlineStyle: false,             // 以下是项目属性，随意true/false，不影响测试结果    inlineTemplate: false,    routing: false,    style: Style.Css,    skipTests: false,    skipPackageJson: false,  };  // 调用 SchematicTestRunner 的 runExternalSchematicAsync 方法，并以给出的参数生成angular项目  let appTree: UnitTestTree;  beforeEach(async () =&gt; {    appTree = await runner.runExternalSchematicAsync(      &#39;@schematics/angular&#39;,      &#39;workspace&#39;,      workspaceOptions    ).toPromise();    appTree = await runner.runExternalSchematicAsync(      &#39;@schematics/angular&#39;,      &#39;application&#39;,      appOptions,      appTree    ).toPromise();  });  // 最基本的判断,如果生成的文件名和预期生成的文件名一致,就验证成功  it(&#39;works&#39;, async () =&gt; {    // runSchematicAsync()参数：项目名、参数、Tree    const tree = await runner.runSchematicAsync(&#39;component&#39;, { name }, appTree).toPromise();    const dasherizeName = strings.dasherize(name);    /* 以下其实可以直接4个toContain代替*/    // 预期生成的文件    const expectFiles = [      `/projects/component/src/app/${dasherizeName}/${dasherizeName}.component.ts`,      `/projects/component/src/app/${dasherizeName}/${dasherizeName}.component.html`,      `/projects/component/src/app/${dasherizeName}/${dasherizeName}.component.scss`,      `/projects/component/src/app/${dasherizeName}/${dasherizeName}.component.spec.ts`,    ]    // 如果实际模拟的angular项目中拥有预期生成的文件,则将它从expectFiles中移除    for (const v of tree.files) {      for (let i = 0; i &lt; expectFiles.length; i++) {        const e = expectFiles[i];        if (v.toString() === e) {          expectFiles.splice(i, 1);        }      }    }    //如果预期生成的文件都有生成,那么预期的应该是0=0成立    expect(0).toEqual(expectFiles.length);  });});</code></pre><p>运行测试用例就很简单了，直接<code>npm run test</code>，如果测试成功，终端应该如下输出：</p><pre><code>david@ubuntu:~/TTT/angular-schematics-tutorial$ npm run test&gt; angular-schematics-tutorial@0.0.0 test /home/david/TTT/angular-schematics-tutorial&gt; npm run build &amp;&amp; jasmine src/**/*_spec.js&gt; angular-schematics-tutorial@0.0.0 build /home/david/TTT/angular-schematics-tutorial&gt; tsc -p tsconfig.jsonRandomized with seed 66156Started.1 spec, 0 failuresFinished in 0.369 secondsRandomized with seed 66156 (jasmine --random=true --seed=66156)david@ubuntu:~/TTT/angular-schematics-tutorial$</code></pre><h3 id="实际-angular-项目运行"><a href="#实际-angular-项目运行" class="headerlink" title="实际 angular 项目运行"></a>实际 angular 项目运行</h3><p>测试用例通过可能很好，但最好还是去实际项目中测试一下，向生成一个 angular 项目：</p><pre><code>ng new angular-demo</code></pre><p>在该 angular-demo 项目中运行指令<code>angular-demo$ schematics ../angular-schematics-tutorial/src/</code>，可以看到结果如下：</p><pre><code>david@ubuntu:~/TTT/angular-demo$ schematics ../angular-schematics-tutorial/src/collection.json:component --debug=false? 你想创建的component的名字: comp/appleCREATE /src/app/comp/apple/apple.component.html (23 bytes)CREATE /src/app/comp/apple/apple.component.scss (0 bytes)CREATE /src/app/comp/apple/apple.component.spec.ts (755 bytes)CREATE /src/app/comp/apple/apple.component.ts (607 bytes)david@ubuntu:~/TTT/angular-demo$</code></pre><p>简单说明：<br><strong>其中指令 –debug=false 是为了实际生成文件，如果不加这一句，不会生成实际的文件。</strong><br>因为没有直接输入<code>--name=comp/apple</code>或者直接<code>comp/apple</code>,所以出现了输入提示语。直接输入 <code>schematics ../angular-schematics-tutorial/src/collection.json:component --name=comp/apple --debug=false</code>则不会出现提示语。</p><p>注意：如果已有同位置同名文件，再次生成会报错，提示<code>already exists.</code>。</p><p>我们查看生成的 component 组件模块内容：<br><img alt="生成的componet组件内容" data-src="/../images/TA/angular-schematics-tutorial/screenshots/%E7%94%9F%E6%88%90%E7%9A%84component%E7%BB%84%E4%BB%B6%E5%85%A7%E5%AE%B9.png" class="lazyload"></p><p>可以看到，文件有实际生成，模板内容有被替换。</p><p>恭喜，如果到这里都正确，那么已经完成了自定义原理图的制作和使用了。</p><p>所以，想要生成一个具有 CRUD 函数的 service 步骤效果就是一样的，不再赘述，具体可参看代码。</p><p>理论上，一个原理图项目(schematics)可以有很多个原理图(schematic)，但是要在 collection 中统一指定配置。</p><p>总结制作原理图的一般步骤：<br>　　 1、新建原理图使用模板文件；<br>　　 2、创建该原理图需要的 schema.json 并将该原理图配置到 collection.json；<br>　　 3、依照 schema.json 创建接口 schema.d.ts；<br>　　 4、在 index.ts 中编写实现该原理图目的的逻辑代码；<br>　　 5(非必须)、编写测试用例进行测试；<br>　　 6(测试)、利用测试用例或实际项目进行测试。</p><h1 id="angular-schematics-实现-ng-add-指令安装模块"><a href="#angular-schematics-实现-ng-add-指令安装模块" class="headerlink" title="angular schematics 实现 ng add 指令安装模块"></a>angular schematics 实现 ng add 指令安装模块</h1><p>ng add 有什么用？</p><blockquote><p>将对外部库的支持添加到您的项目中。</p></blockquote><p>如何使用？</p><blockquote><p>ng add <collection> [options]</collection></p></blockquote><p>但是实际上，这个能够直接使用 ng add 也是应该这个需要添加的库，内部实现了对此原理图的功能。</p><p>举个例子，众所周知，angular material 可以直接使用 ng add 添加到已有的 angular 专案。执行<code>ng add @angular/material</code>。</p><p>效果如下：</p><p><img alt="添加angular material到angular项目" data-src="/../images/TA/angular-schematics-tutorial/screenshots/%E6%B7%BB%E5%8A%A0angular-material%E5%88%B0%E9%A1%B9%E7%9B%AE.gif" class="lazyload"></p><p>但是，如果我想添加 Font Awesome 到 angular 项目，你就需要</p><pre><code>npm install @fortawesome/fontawesome-svg-corenpm install @fortawesome/free-solid-svg-iconsnpm install @fortawesome/angular-fontawesome@&lt;version&gt;</code></pre><p>然后手动引入模块,声明使用等等操作。</p><p>为什么不能使用 ng add？<br>你看：  </p><p><img alt="沒有schematics的库只执行了安裝" data-src="/../images/TA/angular-schematics-tutorial/screenshots/%E6%B2%92%E6%9C%89schematics%E7%9A%84%E5%BA%93%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%BA%86%E5%AE%89%E8%A3%9D.png" class="lazyload"></p><p>font awesome 不支持直接的 ng add,因为 package 中没有实现导入等作业，所以只执行了安装。</p><p>所以本节的目标，就是编写一个原理图，实现 ng add 的时候<br>1、一次性安装以上 3 个 package，<br>2、在 app.module.ts 中引入 FontAwesomeModule<br>3、在 app.component.ts 声明并在 app.component.html 实例化。</p><h2 id="创建-ng-add-的-schema-json-并配置"><a href="#创建-ng-add-的-schema-json-并配置" class="headerlink" title="创建 ng add 的 schema.json 并配置"></a>创建 ng add 的 schema.json 并配置</h2><p>在与之前 component 文件夹同级的路径下，创建 ng-add 文件夹。</p><p>在 ng-add 文件夹下创建 schema.json 文件，并编写如下内容：</p><pre><code>{    &quot;$schema&quot;: &quot;http://json-schema.org/schema&quot;,    &quot;id&quot;: &quot;NgAddSchema&quot;,    &quot;title&quot;: &quot;Ng-Add Schema&quot;,    &quot;type&quot;: &quot;object&quot;,    &quot;description&quot;: &quot;给angular项目添加 Font-Awesome。&quot;,    &quot;properties&quot;: {        &quot;project&quot;: {            &quot;type&quot;: &quot;string&quot;,            &quot;description&quot;: &quot;给angular项目添加 Font-Awesome。&quot;        }    }}</code></pre><p>在 collection.json 中的 “schematics”添加子项，内容如下：</p><pre><code>&quot;ng-add&quot;: {  &quot;description&quot;: &quot;给angular项目中添加 Font-Awesome库。&quot;,  &quot;factory&quot;: &quot;./ng-add&quot;,  &quot;schema&quot;: &quot;./ng-add/schema.json&quot;}</code></pre><p>注意名称保持 ng-add。</p><h2 id="生成并导出-schema-d-ts-文件"><a href="#生成并导出-schema-d-ts-文件" class="headerlink" title="生成并导出 schema.d.ts 文件"></a>生成并导出 schema.d.ts 文件</h2><p>schema.d.ts 文件内容大概如下：</p><pre><code>/** * Ng-Add Schema * 给angular项目添加 Font-Awesome。 */export interface NgAddSchema {    /**     * 给angular项目添加 Font-Awesome。     */    project?: string;}</code></pre><h2 id="编写规则工厂实现逻辑代码"><a href="#编写规则工厂实现逻辑代码" class="headerlink" title="编写规则工厂实现逻辑代码"></a>编写规则工厂实现逻辑代码</h2><p>在文件夹 ng-add 下新建 index.ts 文件，并写入以下代码：</p><pre><code>import { Rule, SchematicContext, Tree, SchematicsException } from &#39;@angular-devkit/schematics&#39;;import { buildDefaultPath } from &#39;@schematics/angular/utility/project&#39;;import { NodePackageInstallTask } from &#39;@angular-devkit/schematics/tasks&#39;;import { NgAddSchema } from &#39;./schema&#39;;import { addImportToModule } from &#39;@schematics/angular/utility/ast-utils&#39;;import { InsertChange } from &#39;@schematics/angular/utility/change&#39;;import * as ts from &#39;@schematics/angular/third_party/github.com/Microsoft/TypeScript/lib/typescript&#39;;export default function (_options: NgAddSchema): Rule {    return (_tree: Tree, _context: SchematicContext) =&gt; {        // 如果不是 Angular 项目则抛出错误        const workspaceConfigBuffer = _tree.read(&#39;angular.json&#39;);        if (!workspaceConfigBuffer) {            throw new SchematicsException(&#39;Not an Angular CLI workspace&#39;);        }        // 取得 project 的根目录        const workspaceConfig = JSON.parse(workspaceConfigBuffer.toString());        const projectName = _options.project || workspaceConfig.defaultProject;        const project = workspaceConfig.projects[projectName];        const defaultProjectPath = buildDefaultPath(project);        //将 FortAwesomeModule 加入 AppModule        const modulePath = `${defaultProjectPath}/app.module.ts`;        const sourceFile = readIntoSourceFile(_tree, modulePath);        const importPath = &#39;@fortawesome/angular-fontawesome&#39;;        const moduleName = &#39;FontAwesomeModule&#39;;        const declarationChanges = addImportToModule(sourceFile, modulePath, moduleName, importPath);        const declarationRecorder = _tree.beginUpdate(modulePath);        for (const change of declarationChanges) {            if (change instanceof InsertChange) {                declarationRecorder.insertLeft(change.pos, change.toAdd);            }        }        _tree.commitUpdate(declarationRecorder);        // 将某个 icon 引入到 app.component.ts，再到 app.component.html 中使用它。（声明并实例化）        // 获取 app.component.ts 的 AST        const componentPath = `${defaultProjectPath}/app.component.ts`;        const componentSourceFile = readIntoSourceFile(_tree, componentPath);        // 取得所有的 ImpotDeclaration        const allImports = componentSourceFile.statements.filter(node =&gt; ts.isImportDeclaration(node))! as ts.ImportDeclaration[];        // 找到最后一个 ImpotDeclaration        let lastImport: ts.Node | undefined;        for (const importNode of allImports) {            if (!lastImport || importNode.getStart() &gt; lastImport.getStart()) {                lastImport = importNode;            }        }        // 找到 ClassDeclaration        const classDeclaration = componentSourceFile.statements.find(node =&gt; ts.isClassDeclaration(node))! as ts.ClassDeclaration;        // 取得所有的 property        const allProperties = classDeclaration.members.filter(node =&gt; ts.isPropertyDeclaration(node))! as ts.PropertyDeclaration[];        // 取得最后一个 propery        let lastProperty: ts.Node | undefined;        for (const propertyNode of allProperties) {            if (!lastProperty || propertyNode.getStart() &gt; propertyNode.getStart()) {                lastProperty = propertyNode;            }        }        const componentRecorder = _tree.beginUpdate(componentPath);        const importFaCoffee = &#39;\nimport { faCoffee } from \&#39;@fortawesome/free-solid-svg-icons\&#39;;&#39;;        componentRecorder.insertLeft(lastImport!.end, importFaCoffee);        // 添加声明部分的代码        const faCoffeeProperty = &#39;faCoffee = faCoffee;&#39;        const changeText = lastProperty ? lastProperty.getFullText() : &#39;&#39;;        let toInsert = &#39;&#39;;        if (changeText.match(/^\r?\r?\n/)) {            toInsert = `${changeText.match(/^\r?\n\s*/)![0]}${faCoffeeProperty}`;        } else {            toInsert = `\n  ${faCoffeeProperty}\n`;        }        // 插入字串        if (lastProperty) {            componentRecorder.insertLeft(lastProperty!.end, toInsert);        } else {            componentRecorder.insertLeft(classDeclaration.end - 1, toInsert);        }        _tree.commitUpdate(componentRecorder);        //在 app.component.html 里面加上 &lt;fa-icon [icon]=&quot;faCoffee&quot;&gt;&lt;/fa-icon&gt; ：        const htmlPath = `${defaultProjectPath}/app.component.html`;        const htmlStr = `\n&lt;fa-icon [icon]=&quot;faCoffee&quot;&gt;&lt;/fa-icon&gt;\n`;        const htmlSourceFile = readIntoSourceFile(_tree, htmlPath);        const htmlRecorder = _tree.beginUpdate(htmlPath);        htmlRecorder.insertLeft(htmlSourceFile.end, htmlStr);        _tree.commitUpdate(htmlRecorder);        // 修改 package.json        const dependencies = [            { name: &#39;@fortawesome/fontawesome-svg-core&#39;, version: &#39;~1.2.25&#39; },            { name: &#39;@fortawesome/free-solid-svg-icons&#39;, version: &#39;~5.11.2&#39; },            { name: &#39;@fortawesome/angular-fontawesome&#39;, version: &#39;~0.5.0&#39; }        ];        dependencies.forEach(dependency =&gt; {            addPackageToPackageJson(                _tree,                dependency.name,                dependency.version            );        });        // 使用 Schematic安装3个依赖 Package 。        // 使用Angular Schematics 的 API - NodePackageInstallTask 。        _context.addTask(            new NodePackageInstallTask({                packageName: dependencies.map(d =&gt; d.name).join(&#39; &#39;)            })        );        return _tree;    };};//读取文件function readIntoSourceFile(host: Tree, modulePath: string): ts.SourceFile {    const text = host.read(modulePath);    if (text === null) {        throw new SchematicsException(`File ${modulePath} does not exist.`);    }    const sourceText = text.toString(&#39;utf-8&#39;);    return ts.createSourceFile(modulePath, sourceText, ts.ScriptTarget.Latest, true);}// 给package.json添加依赖包function addPackageToPackageJson(host: Tree, pkg: string, version: string): Tree {    if (host.exists(&#39;package.json&#39;)) {        const sourceText = host.read(&#39;package.json&#39;)!.toString(&#39;utf-8&#39;);        const json = JSON.parse(sourceText);        if (!json.dependencies) {            json.dependencies = {};        }        if (!json.dependencies[pkg]) {            json.dependencies[pkg] = version;            json.dependencies = sortObjectByKeys(json.dependencies);        }        host.overwrite(&#39;package.json&#39;, JSON.stringify(json, null, 2));    }    return host;}// 对象key排序function sortObjectByKeys(obj: any) {    return Object.keys(obj).sort().reduce((result, key) =&gt; (result[key] = obj[key]) &amp;&amp; result, {} as any);}</code></pre><p>代码不用细读，大约做了以下几件事：</p><p>1、判断是不是 angular 项目<br>2、获取 angular.json 中参数配置<br>3、在 app.module.ts 中引入 FontAwesomeModule<br>4、在 app.component.ts 声明一个 Font<br>5、在 app.component.html 实例化。<br>6、修改模板项目 package.json 依赖列表，加入那 3 个库；<br>7、实现那 3 个库的安装。<br>……</p><h2 id="测试并使用"><a href="#测试并使用" class="headerlink" title="测试并使用"></a>测试并使用</h2><p>如果需要写测试用例，那么可以 ng-add 文件夹下添加 index_spec.ts 并写代码(可参看源码)</p><p>直接在 angular 项目中实践：<br><img alt="ng add的效果" data-src="/../images/TA/angular-schematics-tutorial/screenshots/ngadd%E7%9A%84%E6%95%88%E6%9E%9C.png" class="lazyload"></p><p>如果到这里都正常，那么恭喜你，自定义原理库实现 ng add 也成功了！</p><h1 id="angular-schematics-实现-ng-update-更新模块时修改指定组件内容"><a href="#angular-schematics-实现-ng-update-更新模块时修改指定组件内容" class="headerlink" title="angular schematics 实现 ng update 更新模块时修改指定组件内容"></a>angular schematics 实现 ng update 更新模块时修改指定组件内容</h1><p>上面 2 节分别实现了 ng generator 和 ng add，那么接下来就是 ng update 了。<br>关于 angular schematics 自定义 ng update 的实践目前网上找的示例都比较少，还不是很清晰。我们这里也会做个实例，但是不会深究。</p><p>ng update 有什么用？</p><blockquote><p>更新您的应用程序及其依赖项。</p></blockquote><p>如何使用？</p><blockquote><p>ng update [options]</p></blockquote><p>一般的，如果你的 angular 项目是老旧版本的，运行<code>ng update</code>指令，可能就会出现类似以下的内容：</p><pre><code>Using package manager: &#39;npm&#39;Collecting installed dependencies...Found 33 dependencies.    We analyzed your package.json, there are some packages to update:      Name                               Version                  Command to update     --------------------------------------------------------------------------------      @angular/cdk                       8.1.4 -&gt; 8.2.3           ng update @angular/cdk      @angular/cli                       8.3.0 -&gt; 8.3.20          ng update @angular/cli      @angular/core                      8.2.3 -&gt; 8.2.14          ng update @angular/core      @angular/material                  8.1.4 -&gt; 8.2.3           ng update @angular/material      rxjs                               6.4.0 -&gt; 6.5.3           ng update rxjs</code></pre><p>大家可以仔细看看，这份分析结果说明了什么？<br>一共有 33 个依赖，但是只有 5 个可以使用 ng update 升级？<br>从哪里看出哪些依赖能用 ng update 升级？各个依赖包的 package.json</p><p>ug update 的原理逻辑还是比较复杂了，其实直接看 angular-cli 的升级，比较容易看出端倪。</p><p>访问<code>https://github.com/angular/angular-cli/tree/master/packages/schematics/angular/migrations</code>，  查看 migration-collection.json 文件，随意选一个，例如以下：</p><pre><code>// 上略   &quot;migration-07&quot;: {      &quot;version&quot;: &quot;8.0.0-beta.12&quot;,      &quot;factory&quot;: &quot;./update-8&quot;,      &quot;description&quot;: &quot;Update an Angular CLI project to version 8.&quot;    },// 下略</code></pre><p>看起来大概意思就是，ug update 将 angular 升级到 8.0.0-beta.12 版本时，就会执行<code>migration-07</code>的升级相关命令，其工厂函数内容就在 update-8 的文件夹中。</p><p>有兴致可以细研究 ng update 到 8.0.0-beta.12 具体做了什么。我们只需要简单知道<code>migration-07</code>他会依照相关规则去执行一些动作。</p><p>那么，这份<code>migration-collection.json</code>是在哪里使用的呢？</p><p>可以看到，在这里：<code>https://github.com/angular/angular-cli/blob/master/packages/angular/cli/package.json</code>，在 angular-cli 的 package.json 文件中被定义的。</p><p>以上只是一些我在知道结果之后抛出来给大家看的关键点，大家可以深入研究。我在这里，就简单写个示例，供分析。</p><p><strong>注意：为了后续 ng update 实际使用效果，在此时进行后续作业前，可将现在的代码备份一下，作为 0.0.1 版本。</strong> 版本号的更改当然在 package.json 中。</p><p><strong>本节需要实现的目标是：<br>1、本 angular-schematics-tutorial package 在 angular 项目中使用时，可以使用 ng update 进行升级<br>2、在升级到指定版本时，能够按照升级需求修改已有 angular 项目中部分规则内容。</strong></p><p>这也是在使用 ng update 升级 angular 项目时，可以看到很多旧版本的写法，他会自动纠正成新版本的写法。</p><p>不过，依照我的简单总结，使用 ng update 升级，其实有几点要做：</p><h2 id="创建-migration-json-文件"><a href="#创建-migration-json-文件" class="headerlink" title="创建 migration.json 文件"></a>创建 migration.json 文件</h2><p>在 src/文件夹下，与 collection.json 同级目录，新建 migration.json 文件(名字虽然不限制，但是以便识别)，并写入以下内容：</p><pre><code>{    &quot;$schema&quot;: &quot;../node_modules/@angular-devkit/schematics/collection-schema.json&quot;,    &quot;schematics&quot;: {        &quot;migration002&quot;: {            &quot;version&quot;: &quot;0.0.2&quot;,            &quot;description&quot;: &quot;更新angular-schematics-tutorial到0.0.2版本时执行的更新&quot;,            &quot;factory&quot;: &quot;./ng-update/index#update&quot;        }    }}</code></pre><p>此份说明，当后续把这个 schematics 项目打包之后，其他 angular 项目中使用了这个包，升级到 0.0.2 版本时，就要执行在/ng-update/index.ts 文件中的逻辑规则更新代码了。</p><h2 id="在-package-json-中声明-ug-update-配置"><a href="#在-package-json-中声明-ug-update-配置" class="headerlink" title="在 package.json 中声明 ug-update 配置"></a>在 package.json 中声明 ug-update 配置</h2><p>在 package.json 中，添加以下项目：</p><pre><code>  &quot;ng-update&quot;: {    &quot;migrations&quot;: &quot;./src/migration.json&quot;  },</code></pre><p>其作用，就是在执行 ng update 时，能够找到对应的配置文件</p><h2 id="编写更新执行的规则工厂逻辑代码"><a href="#编写更新执行的规则工厂逻辑代码" class="headerlink" title="编写更新执行的规则工厂逻辑代码"></a>编写更新执行的规则工厂逻辑代码</h2><p>因为只是简单示例，我简单的实现，如果把此 angular-schematics-tutorial 包升级到了 0.0.2 版本，那么一并更新 app.component.ts 里面的 title 变量的值，为<code>AngularSchematicsTutorial002</code>，如果在我之前使用的测试 angular-demo 中运行，可以先看到，目前的 title 值应该是<code>title = &#39;angular-demo&#39;;</code>。</p><p>在 component 同级文件夹路径下新建 ng-update 文件夹，并添加 index.ts 文件，并添加以下代码：</p><pre><code>import { Rule, Tree, SchematicContext, SchematicsException } from &#39;@angular-devkit/schematics&#39;;import { buildDefaultPath } from &#39;@schematics/angular/utility/project&#39;;import * as ts from &#39;typescript&#39;;export function update(): Rule {    return (_tree: Tree, _context: SchematicContext) =&gt; {        // 解析angular项目        const workspaceConfigBuffer = _tree.read(&#39;angular.json&#39;);        if (!workspaceConfigBuffer) {            throw new SchematicsException(&#39;Not an Angular CLI workspace&#39;);        }        const workspaceConfig = JSON.parse(workspaceConfigBuffer.toString());        const projectName = workspaceConfig.defaultProject;        const project = workspaceConfig.projects[projectName];        const defaultProjectPath = buildDefaultPath(project);        // 把 app.component.ts 转成 Typescript AST        const componentPath = `${defaultProjectPath}/app.component.ts`;        const componentSourceFile = readIntoSourceFile(_tree, componentPath);        // 找出 title 变量        const classDeclaration = componentSourceFile.statements.find(node =&gt; ts.isClassDeclaration(node))! as ts.ClassDeclaration;        const allProperties = classDeclaration.members.filter(node =&gt; ts.isPropertyDeclaration(node))! as ts.PropertyDeclaration[];        const titleProperty = allProperties.find(node =&gt; node.name.getText() === &#39;title&#39;);        // 如果有找到 title 变量，则修改它的值        if (titleProperty) {            const initialLiteral = titleProperty.initializer as ts.StringLiteral;            const componentRecorder = _tree.beginUpdate(componentPath);            const startPos = initialLiteral.getStart();            componentRecorder.remove(startPos, initialLiteral.getWidth());            componentRecorder.insertRight(startPos, &#39;\&#39;AngularSchematicsTutorial002\&#39;&#39;);            _tree.commitUpdate(componentRecorder);        }        return _tree;    }}function readIntoSourceFile(host: Tree, modulePath: string): ts.SourceFile {    const text = host.read(modulePath);    if (text === null) {        throw new SchematicsException(`File ${modulePath} does not exist.`);    }    const sourceText = text.toString(&#39;utf-8&#39;);    return ts.createSourceFile(modulePath, sourceText, ts.ScriptTarget.Latest, true);}</code></pre><p>内容可不细看，就是找到 angular 项目中的 app.component.ts，把 title 的值改为 AngularSchematicsTutorial002。</p><h2 id="测试并使用-1"><a href="#测试并使用-1" class="headerlink" title="测试并使用"></a>测试并使用</h2><p>当然，再次在 ng-update/index.ts 下创建 index_spec.ts 编写测试用例也是 ok 的，源代码中会给出。<br>若不用这个麻烦，可以直接在之前的 angular-demo 专案的测试，不过因为是相对路径，则不能直接使用 ng update 了，因为它不知道去哪里判断是不是新版本的更新。</p><p>在 angular-demo 中运行：</p><pre><code>schematics ../angular-schematics-tutorial/src/migration.json:migration002 --debug=false</code></pre><p>执行之后，应该会得到以下结果：</p><pre><code>david@ubuntu:~/TTT/angular-demo$ schematics ../angular-schematics-tutorial/src/migration.json:migration002 --debug=falseUPDATE /src/app/app.component.ts (318 bytes)david@ubuntu:~/TTT/angular-demo$</code></pre><p>并且，app.component.ts 中<code>title = &#39;angular-demo&#39;;</code>变成了<code>title = &#39;AngularSchematicsTutorial002&#39;;</code></p><p>如果能够运行成功，说明 angular schematics 构建 ng update 原理图也学习完成。</p><h1 id="将原理图-package-发布并使用"><a href="#将原理图-package-发布并使用" class="headerlink" title="将原理图 package 发布并使用"></a>将原理图 package 发布并使用</h1><p>以上在执行时，都是使用相对路径在项目中运行，一点都不专业？那么我们可以把这个 schematics 工具包发布，后续直接使用 ng 指令运行。</p><h2 id="使用-npm-link-本地调试"><a href="#使用-npm-link-本地调试" class="headerlink" title="使用 npm link 本地调试"></a>使用 npm link 本地调试</h2><p>可以在我们的 angular-schematics-tutorial 项目目录下，运行<code>npm link</code>指令。<br>npm link 指令细节可参看<a href="https://docs.npmjs.com/cli/link.html" target="_blank" rel="noopener">https://docs.npmjs.com/cli/link.html</a><br>。主要作用就是创建一个全局可访问链接符号。<br>执行之后得到的效果应该如下：</p><pre><code>david@ubuntu:~/TTT/angular-schematics-tutorial$ npm linknpm WARN angular-schematics-tutorial@0.0.2 No repository field.audited 78 packages in 1.031sfound 0 vulnerabilities/home/david/.nvm/versions/node/v12.6.0/lib/node_modules/angular-schematics-tutorial -&gt; /home/david/TTT/angular-schematics-tutorialdavid@ubuntu:~/TTT/angular-schematics-tutorial$</code></pre><p>然后在模板 angular 项目中，链接刚刚的全局 angular-schematics-tutorial 链接。<br><code>npm link angular-schematics-tutorial</code>，相当于在当前项目安装了之前 link 的包，然后就可以在 angular 项目中直接使用 ng g <collection> 或 ng add <collection>了。</collection></collection></p><p>例如在 angular-demo 项目中 link angular-schematics-tutorial ，应该如下：</p><pre><code>david@ubuntu:~/TTT/angular-demo$ npm link angular-schematics-tutorial/home/david/TTT/angular-demo/node_modules/angular-schematics-tutorial -&gt; /home/david/.nvm/versions/node/v12.6.0/lib/node_modules/angular-schematics-tutorial -&gt; /home/david/TTT/angular-schematics-tutorialdavid@ubuntu:~/TTT/angular-demo$</code></pre><p>然后使用 ng generator：</p><pre><code>david@ubuntu:~/TTT/angular-demo$ ng g angular-schematics-tutorial:component? 你想创建的component的名字: comp/pieCREATE src/app/comp/pie/pie.component.html (21 bytes)CREATE src/app/comp/pie/pie.component.scss (0 bytes)CREATE src/app/comp/pie/pie.component.spec.ts (741 bytes)CREATE src/app/comp/pie/pie.component.ts (259 bytes)david@ubuntu:~/TTT/angular-demo$</code></pre><p><strong>注意：现在不用设置 –debug=false 属性，一样会直接真实创建了。</strong></p><p>同理，使用 ng add angular-schematics-tutorial：</p><pre><code class="shell">david@ubuntu:~/TTT/angular-demo$ ng add angular-schematics-tutorialSkipping installation: Package already installedUPDATE src/app/app.module.ts (407 bytes)UPDATE src/app/app.component.ts (302 bytes)UPDATE src/app/app.component.html (25506 bytes)UPDATE package.json (1439 bytes)npm WARN axobject-query@2.1.1 requires a peer of eslint@^5 || ^6 but none is installed. You must install peer dependencies yourself.……省略了一些npm WARN……npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.2: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;})+ @fortawesome/free-solid-svg-icons@5.11.2+ @fortawesome/fontawesome-svg-core@1.2.25+ @fortawesome/angular-fontawesome@0.5.0added 4 packages from 25 contributors, removed 1 package and audited 18882 packages in 11.067sfound 0 vulnerabilitiesdavid@ubuntu:~/TTT/angular-demo$</code></pre><p>注意：如果之前执行过，最好撤销后再试。<br>看到上面显示这一句<code>Skipping installation: Package already installed</code>，这里 already installed 的 package 指的是 angular-schematics-tutorial，原因在于我们使用 npm link angular-schematics-tutorial 已经做了链接了。</p><p><strong>那么，能否直接测试 ng update 呢？目前我是没有成功的。</strong> 因为 npm link 无法同时测试两个版本？这点可请大家指出。</p><p>注意，测试完了请使用 npm unlink 去清除那些链接，避免混乱等情况。</p><h2 id="将原理图-package-发布到仓库并使用"><a href="#将原理图-package-发布到仓库并使用" class="headerlink" title="将原理图 package 发布到仓库并使用"></a>将原理图 package 发布到仓库并使用</h2><p>写在前面：如果觉得这样的糟粕不想自己发布用于测试，可以直接使用我已发布的进行测试。<br>先安装 0.0.1 版本：<code>npm i angular-schematics-tutorial@0.0.1</code><br>然后执行<code>ng update</code>，查看是否生效。</p><p>一般如果公司有自己内部的包管理系统，那么就可以直接发布到内部去。<br>如何搭建私有 npm 仓库？我之前有文件，使用 verdaccio。</p><p>我们这里示例将包发布到公网的 npmjs.com 去。既然是 npmjs，那可能你要去注册个帐号了。</p><p>记得前面我们有备份一个 0.0.1 版本的 angular-schematics-tutorial 吗？我们先来发布它。</p><h3 id="添加帐号，在终端输入-adduser，按提示填写"><a href="#添加帐号，在终端输入-adduser，按提示填写" class="headerlink" title="添加帐号，在终端输入 adduser，按提示填写"></a>添加帐号，在终端输入 adduser，按提示填写</h3><pre><code>david@ubuntu:~/TTT/angular-schematics-tutorial$ npm adduserUsername: davidsuPassword:Email: (this IS public) 183318××××@qq.comLogged in as davidsu on https://registry.npmjs.org/.david@ubuntu:~/TTT/angular-schematics-tutorial$</code></pre><p>logged in 表示成功</p><h3 id="在根目录执行npm-publish"><a href="#在根目录执行npm-publish" class="headerlink" title="在根目录执行npm publish"></a>在根目录执行<code>npm publish</code></h3><p>得到结果如下：</p><pre><code>david@ubuntu:~/TTT/angular-schematics-tutorial$ npm publishnpm noticenpm notice 📦  angular-schematics-tutorial@0.0.1npm notice === Tarball Contents ===……略一大部分 npm notice 内容……npm notice === Tarball Details ===npm notice name:          angular-schematics-tutorialnpm notice version:       0.0.1npm notice package size:  11.3 kBnpm notice unpacked size: 41.2 kBnpm notice shasum:        9f80b36542065cafb2eb06a5eceb068d5aa9db44npm notice integrity:     sha512-oZcVhqatHlU9K[...]Qz7Deicn1f3oA==npm notice total files:   34npm notice+ angular-schematics-tutorial@0.0.1david@ubuntu:~/TTT/angular-schematics-tutorial$</code></pre><p>那么没有添加 ng update 的 0.0.1 版本就发布了，可以在 npmjs 网站自己的账户下查看自己发布的包。</p><h3 id="发布-0-0-2-版本的包"><a href="#发布-0-0-2-版本的包" class="headerlink" title="发布 0.0.2 版本的包"></a>发布 0.0.2 版本的包</h3><p>重复以上动作(npm publish)，把 angular-schematics-tutorial 的 0.0.2 版本的包也发布了，那么就可以看到自己两个版本的包了。<br><img alt="npmjs下自己发布的包" data-src="/../images/TA/angular-schematics-tutorial/screenshots/npmjs%E8%87%AA%E5%B7%B1%E5%8F%91%E5%B8%83%E7%9A%84%E5%8C%85.png" class="lazyload"></p><h3 id="实际测试使用"><a href="#实际测试使用" class="headerlink" title="实际测试使用"></a>实际测试使用</h3><p>现在，我们的 angular-schematics-tutorial 就是一个可以被所有人访问的原理图工具包了，那么我们就可以像实际使用包一样去测试它了。</p><p>为了避免干扰，可以删除之前的 angular-demo 测试项目，新建一个 angular-test 的新项目</p><pre><code>ng new angular-test</code></pre><p>我们先测试 ug update 的效果。</p><p>先安装 0.0.1 版本：</p><pre><code>npm i angular-schematics-tutorial@0.0.1</code></pre><p>然后运行<code>ng update</code>指令，应该看到以下内容</p><pre><code>david@ubuntu:~/TTT/angular-test$ ng updateUsing package manager: &#39;npm&#39;Collecting installed dependencies...Found 31 dependencies.    We analyzed your package.json, there are some packages to update:      Name                               Version                  Command to update     --------------------------------------------------------------------------------      angular-schematics-tutorial        0.0.1 -&gt; 0.0.2           ng update angular-schematics-tutorial      rxjs                               6.4.0 -&gt; 6.5.3           ng update rxjsdavid@ubuntu:~/TTT/angular-test$</code></pre><p>现在，我们可以直接使用 ng update 去升级我们的工具包了。<br><strong>注意：使用 ng update 升级前，要提交所有变更。</strong><br>运行<code>ng update angular-schematics-tutorial</code>，注意查看 app.component.ts 中 title 变量是否变化：</p><pre><code>david@ubuntu:~/TTT/angular-test$ ng update angular-schematics-tutorialUsing package manager: &#39;npm&#39;Collecting installed dependencies...Found 31 dependencies.Fetching dependency metadata from registry...    Updating package.json with dependency angular-schematics-tutorial @ &quot;0.0.2&quot; (was &quot;0.0.1&quot;)...UPDATE package.json (1329 bytes)npm WARN axobject-query@2.1.1 requires a peer of eslint@^5 || ^6 but none is installed. You must install peer……省略一些npm WARN……npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.2: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;})updated 1 package and audited 18955 packages in 8.615sfound 0 vulnerabilities    ** Executing migrations for package &#39;angular-schematics-tutorial&#39; **UPDATE src/app/app.component.ts (233 bytes)david@ubuntu:~/TTT/angular-test$</code></pre><p>从最后一行，看到，应该是修改了，实际也如此。</p><p><img alt="ngupdate成功" data-src="/../images/TA/angular-schematics-tutorial/screenshots/ngupdate%E6%88%90%E5%8A%9F.png" class="lazyload"></p><p>其他的 ng generator 的原理图和 ng add 的原理图也是可以的，可以自行测试。<br>例如：<code>ng g angular-schematics-tutorial:crudService</code>或者<code>ng add angular-schematics-tutorial</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>花费了如此大量的篇幅，基本上讲清楚了 angular schematics 的基本使用内容。虽然看起来很鸡肋，但是如果是 angular 技术栈并且长期有重复大量相同工作的开发，不免可以试一下使用它来重构下作业流程。虽然不一定比 ctrl+c ctrl+v 快，但是至少逼格更高了。</p><p>总结一下使用 angular schematics 的步骤重点。</p><p>制作 ng generator 或 ng add 原理图：<br>1、新建原理图使用模板文件；<br>2、创建该原理图需要的 schema.json 并将该原理图配置到 collection.json；<br>3、依照 schema.json 创建接口 schema.d.ts；<br>4、在 index.ts 中编写实现该原理图目的的逻辑代码；<br>5(非必须)、编写测试用例进行测试；<br>6(测试)、利用测试用例或实际项目进行测试。</p><p>添加 ng update<br>1、创建并编写 migration.json 文件；<br>2、在 package.json 中声明 ug-update 配置；<br>3、编写更新执行的规则工厂逻辑代码；<br>4、测试并使用。</p><p>以上内容亲测有效，有问题可提出交流，谢谢。</p><p>主要参考：<br><a href="https://ithelp.ithome.com.tw/articles/10222826" target="_blank" rel="noopener">https://ithelp.ithome.com.tw/articles/10222826</a><br><a href="https://medium.com/@tomastrajan/total-guide-to-custom-angular-schematics-5c50cf90cdb4" target="_blank" rel="noopener">https://medium.com/@tomastrajan/total-guide-to-custom-angular-schematics-5c50cf90cdb4</a><br>和 angular 官方文档：<a href="https://angular.cn/guide/schematics" target="_blank" rel="noopener">https://angular.cn/guide/schematics</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
          <category> angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
            <tag> schematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只言片语——angular material input输入框可以辅助下拉选择</title>
      <link href="/2019/12/12/TechnicalArticles/snippets-angular-input-with-select/"/>
      <url>/2019/12/12/TechnicalArticles/snippets-angular-input-with-select/</url>
      
        <content type="html"><![CDATA[<p>在 angular 使用 material 开发时，如果需要一个输入框，既可以自行输入值，还可以点击下拉选择预设的选项输入值，可以使用 autocomplete 标签。</p><a id="more"></a><p>需要引入 MatAutocompleteModule 模块</p><pre><code>import {MatAutocompleteModule} from &#39;@angular/material/autocomplete&#39;;</code></pre><p>在 xxx.ts 中定义了下拉选项，例如：</p><pre><code>  options = [    { value: &#39;00:30:00&#39;, column: &#39;30分钟&#39; },    { value: &#39;01:00:00&#39;, column: &#39;1小时&#39; },    { value: &#39;01:30:00&#39;, column: &#39;90分钟&#39; },    { value: &#39;02:00:00&#39;, column: &#39;2小时&#39; },    { value: &#39;05:00:00&#39;, column: &#39;5小时&#39; }  ];</code></pre><p>在 xxx.html 中使用示例如下：</p><pre><code>  &lt;span&gt;持续时间：&lt;/span&gt;  &lt;mat-form-field style=&quot;width:150px&quot;&gt;    &lt;input placeholder=&quot;自行输入或下拉选择&quot; matInput [matAutocomplete]=&quot;auto&quot;&gt;    &lt;mat-autocomplete #auto=&quot;matAutocomplete&quot;&gt;      &lt;mat-option *ngFor=&quot;let option of options&quot; [value]=&quot;option.value&quot;&gt;        {{option.column}}      &lt;/mat-option&gt;    &lt;/mat-autocomplete&gt;  &lt;/mat-form-field&gt;</code></pre><p>得到的效果如下：</p><p><img alt="INPUT可下拉可直接输入" data-src="/../images/TA/snippets-angular-input-with-select/pics/INPUT%E5%8F%AF%E4%B8%8B%E6%8B%89%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
          <category> angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只言片语——angular ngFor遍历显示2个数组值</title>
      <link href="/2019/12/12/TechnicalArticles/snippets-angular-ngfor/"/>
      <url>/2019/12/12/TechnicalArticles/snippets-angular-ngfor/</url>
      
        <content type="html"><![CDATA[<p>angular 的*ngFor 只能遍历 1 个数组，但是能够获取到 index，所以以第一个数组的 index 带出第二个数组的值显示即可。</p><a id="more"></a><p>例如，在 xxx.ts 中有声明两个数组：</p><pre><code>names = [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;, &#39;马六&#39;];ages = [32, 34, 54, 25];</code></pre><p>在 xxx.html 中如此使用：</p><pre><code>&lt;div&gt;  &lt;li *ngFor=&quot;let name of names; let i=index &quot;&gt;    &lt;label&gt;{{name}} ~ {{ages[i]}}岁&lt;/label&gt;  &lt;/li&gt;&lt;/div&gt;</code></pre><p>得到的效果图如下：</p><p><img alt="ngFor显示两个数组的内容" data-src="/../images/TA/snippets-angular-ngfor/pics/ngFor%E6%98%BE%E7%A4%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AE%B9.png" class="lazyload"></p><p>当然，如果两个数组的长度不一致，要么显示空白(ngFor 遍历的数组长度值大)，要么不显示值(ngFor 遍历的数组长度值小。)</p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
          <category> angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04下docker基本指令和使用docker安装mysql</title>
      <link href="/2019/12/12/TechnicalArticles/ubuntu-mysql-docker/"/>
      <url>/2019/12/12/TechnicalArticles/ubuntu-mysql-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-基本指令"><a href="#docker-基本指令" class="headerlink" title="docker 基本指令"></a>docker 基本指令</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><pre><code class="shell">sudo sh -c &quot;$(curl -fsSL https://get.docker.com)&quot;  sudo usermod -aG docker $USER</code></pre><p>第一行用docker官方提供的script快速安装<br>第二行将现有的使用者加入docker群组，否则会没有权限操作docker命令。<br>记得注销账号重登，以获取docker操作权限。  </p><a id="more"></a><p>执行<code>sudo docker run hello-world</code>查看是否安装成功。<br>如果出现以下画面则安装成功：<br><img alt="测试docker安装成功" data-src="/../images/TA/ubuntu-mysql-docker/%E6%B5%8B%E8%AF%95docker%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" class="lazyload"></p><h2 id="常用docker基本指令"><a href="#常用docker基本指令" class="headerlink" title="常用docker基本指令"></a>常用docker基本指令</h2><p>1 启动/关闭 docker服务</p><pre><code>service docker start 或者 systemctl start docker // 启动service docker stop 或者 systemctl stop docker // 关闭</code></pre><p>2 创建一个新的容器并运行一个命令</p><pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><p>常用OPTIONS说明：<br>　　-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；<br>　　-d: 后台运行容器，并返回容器ID；<br>　　-i: 以交互模式运行容器，通常与 -t 同时使用；<br>　　-P: 随机端口映射，容器内部端口随机映射到主机的高端口;<br>　　-p: 指定端口映射，格式为：主机(宿主)端口:容器端口;<br>　　-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>　　-e &lt;环境变量名&gt;=”&lt;值&gt;”: 设置环境变量；<br>　　–name=”<container-name>“: 为容器指定一个名称；  </container-name></p><p>例如:<br>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</p><pre><code>docker run --name mynginx -d nginx:latest</code></pre><p>3 只创建而不运行容器(选项同option)</p><pre><code>docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><p>4 删除一个或多个容器</p><pre><code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code></pre><p>OPTIONS说明：<br>　　-f :通过SIGKILL信号强制删除一个运行中的容器<br>　　-l :移除容器间的网络连接，而非容器本身<br>　　-v :-v 删除与容器关联的卷</p><p>例如：<br>强制删除容器db01、db02</p><pre><code>docker rm -f db01 db02</code></pre><p>5 在运行的容器中执行命令</p><pre><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></pre><p>OPTIONS说明：<br>　　 -d :分离模式: 在后台运行<br>　　-i :即使没有附加也保持STDIN 打开<br>　　-t :分配一个伪终端  </p><p>6 查看已有下载镜像(images)</p><pre><code>docker images</code></pre><h1 id="使用docker安装mysql"><a href="#使用docker安装mysql" class="headerlink" title="使用docker安装mysql"></a>使用docker安装mysql</h1><p>1 下载最新mysql镜像</p><pre><code>docker pull mysql:latest</code></pre><p>2 运行容器</p><pre><code>docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</code></pre><p>部分参数说明：<br>　　mysql-test：容器名<br>　　-p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。<br>　　MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。<br>3 配置mysql 使用者(user)<br>　　3.1 进入容器  </p><pre><code>　　docker exec -it mysql-test bash</code></pre><p>　　3.2 登录mysql并修改root密码  </p><pre><code>　　mysql -u root -p　　ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><p>　　3.3 添加远程登录用户 –&gt; ‘用户名‘@’主机’,%表任意都行</p><pre><code>　　CREATE USER &#39;&lt;username&gt;&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;&lt;password&gt;&#39;;　　GRANT ALL PRIVILEGES ON *.* TO &#39;&lt;username&gt;&#39;@&#39;%&#39;;</code></pre><h1 id="备份docker中mysql的数据"><a href="#备份docker中mysql的数据" class="headerlink" title="备份docker中mysql的数据"></a>备份docker中mysql的数据</h1><p>　　使用docker安装mysql可能遇到一个问题,就是如果不做其他处理,docker容器损坏,那么里面的数据就可能丢了再也找不回. 所以应当养成定时备份的好习惯。<br>　　使用以下指令，将docker容器中的mysql数据备份到宿主主机指定位置：</p><pre><code>docker exec [CONTAINER] //usr/bin/mysqldump -u [USER] --password=[PASSWORD] --routines --triggers test_db &gt; /home/user/test_db_backup.sql</code></pre><p>说明：<br>　　test_db是docker中mysql的数据库名<br>　　/home/user/test_db_backup.sql 备份到宿主主机的地址和文件名</p><p>将上面指令写入宿主主机的cron定时任务中就可定时将docker中mysql数据备份到本机，避免docker损坏数据就丢失了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> mysql </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象数组按对象指定属性排序</title>
      <link href="/2019/12/12/TechnicalArticles/object-array-sort/"/>
      <url>/2019/12/12/TechnicalArticles/object-array-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>&emsp;&emsp;<strong>说明：使用语言为javascript。</strong><br>&emsp;&emsp;对象数组，即数组中存放的元素是一个个对象。例如</p><pre><code>let objArr = [    { name: &quot;张三&quot;, sex: &#39;female&#39;, age: 30, birthday: &quot;1994/10/11&quot; },    { name: &quot;李四&quot;, sex: &#39;male&#39;, age: 20, birthday: &quot;2001/08/11&quot; },    { name: &quot;王五&quot;, sex: &#39;female&#39;, age: 40, birthday: &quot;2001/01/15&quot; }];</code></pre><p>&emsp;&emsp;但是我们可能需要对该对数组中对象的指定属性进行排序，例如上述对象数组中的age，birthday。如何操作？<strong>方法之一，就是数组的sort()方法。</strong><br>&emsp;&emsp;下面，就一步步去分析，实现一份简单通用的对象数组排序方法。</p><a id="more"></a><h1 id="实现对象数组排序"><a href="#实现对象数组排序" class="headerlink" title="实现对象数组排序"></a>实现对象数组排序</h1><h2 id="第一步：简单排序number属性"><a href="#第一步：简单排序number属性" class="headerlink" title="第一步：简单排序number属性"></a>第一步：简单排序number属性</h2><p>&emsp;&emsp;因为Array.sort()的“默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的”。好在是sort()方法接受一个用来指定按某种顺序进行排列的函数作为可选参数，即<code>arr.sort([compareFunction])</code>，<strong>如果 compareFunction(a, b) 小于0，那么a会被排列到b之前；</strong>所以可以在此实现自己想要的排序方法。<br><strong>注意，sort方法会改变原数组。（sort() 方法用原地算法对数组的元素进行排序，并返回数组。）</strong></p><p>&emsp;&emsp;话不多说，直接看。<br>&emsp;&emsp;例如上述objArr，按照age升序排序：</p><pre><code>// 指定排序的比较函数function compare(property) {    return function (object1, object2) {        let value1 = object1[property];        let value2 = object2[property];        // 升序        return value1 - value2;    }}let sortObj = objArr.sort(compare(&quot;age&quot;));console.log(sortObj); </code></pre><p>&emsp;&emsp;应该会得到如下结果：<br><img alt="按照age排序" data-src="/../images/TA/object-array-sort/pics/%E6%8C%89%E7%85%A7age%E6%8E%92%E5%BA%8F.png" class="lazyload"></p><h2 id="第二阶段：可以排序string属性"><a href="#第二阶段：可以排序string属性" class="headerlink" title="第二阶段：可以排序string属性"></a>第二阶段：可以排序string属性</h2><p>&emsp;&emsp;但是这个写法只能对age这个number类型的属性其作用，如果换成name或者birthday等，就不行，因为string不能直接用’-‘比较得出大小。<br>&emsp;&emsp;例如，运行<code>console.log(&#39;male&#39; - &#39;female&#39;);</code>，应该会看到得出的是NaN。<br>&emsp;&emsp;string，就应该使用localeCompare() 方法，它返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。完整语法：<code>referenceStr.localeCompare(compareString[, locales[, options]])</code>。</p><p>&emsp;&emsp;所以需要简单修改一下compare()方法，修改如下：</p><pre><code>function compare(property) {    return function (object1, object2) {        let value1 = object1[property];        let value2 = object2[property];        if (typeof (value1) == typeof (value2)) {            if (typeof (value1) === &#39;number&#39;) {                return value1 - value2;            }            if (typeof (value1) === &#39;string&#39;) {                // 升序                return value1.toString().localeCompare(value2);            }        }    }}let sortObj = objArr.sort(compare(&quot;birthday&quot;));console.log(sortObj); </code></pre><p>&emsp;&emsp;结果应当如下：<br><img alt="按照birthday排序.png" data-src="/../images/TA/object-array-sort/pics/%E6%8C%89%E7%85%A7birthday%E6%8E%92%E5%BA%8F.png" class="lazyload"></p><h2 id="第三阶段：可以指定升序-降序"><a href="#第三阶段：可以指定升序-降序" class="headerlink" title="第三阶段：可以指定升序/降序"></a>第三阶段：可以指定升序/降序</h2><p>&emsp;&emsp;既然已经到了这个程度，那可以再加一个是按照升序或者降序排列。<br>&emsp;&emsp;简单修改如下：</p><pre><code>function compare(property, sortType = &quot;asc&quot;) {    return function (object1, object2) {        let value1 = object1[property];        let value2 = object2[property];        // 判断 传入的属性值 是number还是 string        if (typeof (value1) == typeof (value2)) {            if (typeof (value1) === &#39;number&#39;) {                // 如果是升序                if (sortType === &quot;asc&quot;) {                    return value1 - value2;                } else if (sortType === &quot;desc&quot;) {                    // 如果是降序                    return value2 - value1;                }            }            if (typeof (value1) === &#39;string&#39;) {                // 如果是升序                if (sortType === &quot;asc&quot;) {                    return value1.toString().localeCompare(value2);                } else if (sortType === &quot;desc&quot;) {                    // 如果是降序                    return value2.toString().localeCompare(value1);                }            }        }    }}// 生日，降序let sortObj = objArr.sort(compare(&quot;birthday&quot;, &#39;desc&#39;));console.log(sortObj); </code></pre><p>&emsp;&emsp;得到的结果应该如下：<br><img alt="按birthday降序排序.png" data-src="/../images/TA/object-array-sort/pics/%E6%8C%89birthday%E9%99%8D%E5%BA%8F%E6%8E%92%E5%BA%8F.png" class="lazyload"></p><h2 id="第四阶段：封裝成通用方法"><a href="#第四阶段：封裝成通用方法" class="headerlink" title="第四阶段：封裝成通用方法"></a>第四阶段：封裝成通用方法</h2><p>&emsp;&emsp;反正都这样了，再简单封装一下，导出成一个方法，后续直接使用。</p><p>&emsp;&emsp;新建一个objArraySort.js,放入以下代码：</p><pre><code>// sort使用的排序方法// 传入对象数组用于排序的对象的属性,升序/降序function compare(property, sortType = &quot;asc&quot;) {    // 如果不是 asc,desc,不做下一步比较    if (!(sortType === &quot;desc&quot; || sortType === &quot;asc&quot;)) {        return;    }    return function (object1, object2) {        // 取得对象属性值        let value1 = object1[property];        let value2 = object2[property];        // 如果该对象不存在这个属性,也不做后续比较        if (!value1 || !value2) {            return;        }        // 如果两个属性取得的值不是一个类型的就不用比较了        if (typeof (value1) == typeof (value2)) {            // 判断 传入的属性值 是number还是 string            if (typeof (value1) === &#39;number&#39;) {                // 如果是升序                if (sortType === &quot;asc&quot;) {                    return value1 - value2;                } else {                    // 如果是降序                    return value2 - value1;                }            } else if (typeof (value1) === &#39;string&#39;) {                // 如果是升序                if (sortType === &quot;asc&quot;) {                    return value1.toString().localeCompare(value2);                } else {                    // 如果是降序                    return value2.toString().localeCompare(value1);                }            } else {                // 其它类型就不排序了                return;            }        } else {            return;        }    }}// 通用方法，需要传入 需要排序的对象数组、对象属性、排序方式function objectArraySort(array, property, sortType) {    // 如果不是对象数组用这个方法,返回的是undefined    if (!(array instanceof Array)) {        return;    }    return array.sort(compare(property, sortType));}// 导出module.exports = {    objectArraySort: objectArraySort,}</code></pre><p>&emsp;&emsp;再将刚刚的objArr按照age降序排序：</p><pre><code>// 引入模块const oas = require(&quot;./objectArraySort&quot;);// 调用方法，传入需要排序的对象数组、对象属性、排序方式let sortObj = oas.objectArraySort(objArr, &#39;age&#39;, &#39;desc&#39;);console.log(sortObj); </code></pre><p>&emsp;&emsp;应该会得到以下结果：<br><img alt="按照age降序排序.png" data-src="/../images/TA/object-array-sort/pics/%E6%8C%89%E7%85%A7age%E9%99%8D%E5%BA%8F%E6%8E%92%E5%BA%8F.png" class="lazyload"></p><p>&emsp;&emsp;至此，一个简单通用的对象数组按照其对象指定属性排序的模块就完成了。实践有效，如果有问题，可提出交流，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express+multer 文件上传,并在 router 中指定文件存放路径</title>
      <link href="/2019/12/12/TechnicalArticles/express-multer-demo/"/>
      <url>/2019/12/12/TechnicalArticles/express-multer-demo/</url>
      
        <content type="html"><![CDATA[<p>Express+multer 文件上传,并在 router 中指定文件存放路径</p><h1 id="内容简单说明"><a href="#内容简单说明" class="headerlink" title="内容简单说明"></a>内容简单说明</h1><p>&emsp;&emsp;文件上传是 web 开发中比较常见的一个功能虽然说起来是文件上传，实际上，可以看做是对 multipart/form-data 数据的处理。在 npm 中,有很多处理类似数据的库，包括周下载量近 2kw 的 form-data，周下载量近 3mw 的 formidable。</p><p>&emsp;&emsp;不过，如果 nodejs 后端使用的 express 框架，其官方也有一个自己的文件上传中间件，用它自己的话来说就是：“Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据，它主要用于上传文件。”</p><a id="more"></a><p>&emsp;&emsp;使用 multer 比较简单，一般就是<br>&emsp;&emsp;&emsp;&emsp;1、导入 multer，<br>&emsp;&emsp;&emsp;&emsp;2、指定文件上传地址（如果有必要的话，不指定只是写到内存中），<br>&emsp;&emsp;&emsp;&emsp;3、在 router 的路径后，回调函数前，写一个<code>upload.single(photo)</code>（单文件）或者<code>upload.array(&#39;photos&#39;, 12)</code>（多文件），在 router 的回调中，就可以使用<code>req.file 或者 req.files</code>获取文件了。</p><p>&emsp;&emsp;在这里，因为指定的上传地址是在 multer(opts)中的 opts 配置，所以 opts 配置号一个地址之后，后续修改就不是那么方便。如果需要对不同文件不同路由路径指定不同的文件上传地址，那应该如何处理？</p><p>&emsp;&emsp;multer 的简单使用后文会给个示例，但是最终的目的，<strong>是想要在 express 的 router 回调函数中，可以指定文件上传的路径，而不是所有的文件都上传到唯一指定的路径。</strong>例如，路由是“testUpload”，我在 router 处理时指定存放到测试使用的上传路径。路由是“formalUpload”，我在处理时可以指定存放到正式的上传路径。</p><h1 id="express-multer-基本文件上传示例"><a href="#express-multer-基本文件上传示例" class="headerlink" title="express+multer 基本文件上传示例"></a>express+multer 基本文件上传示例</h1><p>&emsp;&emsp;因为主要是测试 multer 内容，所以一切从简，就在一个简单的 express 项目中测试就好</p><h2 id="1、创建一个-express-项目（前提：已安装-express-generator），并安装-multer"><a href="#1、创建一个-express-项目（前提：已安装-express-generator），并安装-multer" class="headerlink" title="1、创建一个 express 项目（前提：已安装 express-generator），并安装 multer"></a>1、创建一个 express 项目（前提：已安装 express-generator），并安装 multer</h2><pre><code>express --view=ejs express-mutler-demo// 进入项目根目录npm i multer</code></pre><h2 id="2、上传页面编写"><a href="#2、上传页面编写" class="headerlink" title="2、上传页面编写"></a>2、上传页面编写</h2><p>&emsp;&emsp;修改 views/index.ejs 的<body>标签内容如下：</body></p><pre><code class="javascript">  &lt;div&gt;    &lt;h3&gt;Express + multer 簡陋上傳文件&lt;/h3&gt;    &lt;form method=&quot;post&quot; action=&quot;/upload&quot; id=&quot;upload-form&quot; encType=&quot;multipart/form-data&quot;&gt;      &lt;input id=&#39;upload&#39; type=&quot;file&quot; name=&quot;file&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;上傳&quot;&gt;    &lt;/form&gt;    &lt;!-- 进度条 --&gt;    &lt;progress id=&quot;uploadprogress&quot; min=&quot;0&quot; max=&quot;100&quot; value=&quot;0&quot;&gt;0&lt;/progress&gt;    &lt;p id=&#39;msg&#39;&gt;&lt;/p&gt;  &lt;/div&gt;  &lt;!-- 引入jquery.js --&gt;  &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;    integrity=&quot;sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;  &lt;script&gt;    let form = $(&quot;#upload-form&quot;);    form.on(&#39;submit&#39;, function (event) {      // 清除提交结果显示信息      $(&quot;#msg&quot;).html(&quot;&quot;);      // 在原页面处理，不跳转      event.preventDefault();      // 检查是否支持FormData      if (window.FormData) {        let formData = new FormData();        // 建立一个file表单项，值为上传的文件        formData.append(&#39;file&#39;, $(&#39;#upload&#39;).get(0).files[0]);        let xhr = new XMLHttpRequest();        xhr.open(&#39;POST&#39;, $(this).attr(&#39;action&#39;));        // 进度条占比计算        xhr.upload.onprogress = function (event) {          if (event.lengthComputable) {            let complete = (event.loaded / event.total * 100 | 0);            $(&quot;#uploadprogress&quot;).val(complete);            $(&quot;#uploadprogress&quot;).innerHTML = complete;          }        };        // 定义上传完成后的回调函数        xhr.onload = function (e) {          if (xhr.status === 200) {            $(&quot;#msg&quot;).html(&quot;上传成功!&quot;);            // alert(&#39;上传成功！&#39;);          } else {            // alert(&#39;文件上传出错了！&#39;)            $(&quot;#msg&quot;).html(&quot;上传失败!&quot;);          }        };        // 发送表单数据        xhr.send(formData);      }    });  &lt;/script&gt;</code></pre><p>&emsp;&emsp;代码内容很简单，就是一个 form 用来模拟文件上传，为了最简单，直接使用的 XMLHttpRequest 实现上传，还没事整了个进度条。<br>&emsp;&emsp;本来想用原始的方法，还是引入了 jquery。更简略类似下面也 ok。</p><pre><code>&lt;script&gt;    function PostData() {        $.ajax({            type: &quot;POST&quot;,            url: &quot;XXX&quot;,            data : &quot;&quot;,            success: function(msg) {            }        });        return false;    }&lt;/script&gt;&lt;form onsubmit=&quot;return PostData()&quot;&gt;    &lt;input type=&quot;text&quot; value=&quot;&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;</code></pre><p>&emsp;&emsp;依旧以第一个为准，页面大概是这个样子（运行 express 项目，在 localhost:3000 看到）：</p><p><img alt="input画面" data-src="/../images/TA/express-multer-demo/pic/input%E7%94%BB%E9%9D%A2.png" class="lazyload"></p><h2 id="3、multer-的简单配置"><a href="#3、multer-的简单配置" class="headerlink" title="3、multer 的简单配置"></a>3、multer 的简单配置</h2><p>&emsp;&emsp;新建一个 util/Upload.js，编写 multer 配置并导出：</p><pre><code>const multer = require(&#39;multer&#39;);// 文件上传配置const fileStorage = multer.diskStorage({    destination: function (req, file, callback) {        callback(null, &quot;/defaultUploadDir&quot;);    },    filename: function (req, file, callback) {        callback(null, file.originalname);    }});// 导出配置module.exports = {    fileUpdate: multer({ &#39;storage&#39;: fileStorage }),}</code></pre><p><strong>注意：上传地址 “/defaultUploadDir”要先手动创建，否则报错。</strong></p><h2 id="4、在对应-router-中使用-multer"><a href="#4、在对应-router-中使用-multer" class="headerlink" title="4、在对应 router 中使用 multer"></a>4、在对应 router 中使用 multer</h2><p>&emsp;&emsp;在 routes/index.js 中，添加以下 router 代码：</p><pre><code>router.post(&#39;/upload&#39;, upload.fileUpdate.single(&#39;file&#39;), function (req, res, next) {  const file = req.file;  console.log(file);  //如果得到了文件，就返回上传成功  if (file) {    return res.status(200).json({ success: true });  } else {    return res.status(500).json({ success: false });  }});</code></pre><p>&emsp;&emsp;记得在最上面引入 multer 配置：</p><pre><code>const upload = require(&#39;../util/Upload&#39;);</code></pre><p>&emsp;&emsp;几个简单注意点：<br>&emsp;&emsp;&emsp;&emsp;1、这个路由路径和路由方法，要和前台页面中的 action 和 method 一致；<br>&emsp;&emsp;&emsp;&emsp;2、多文件就要 upload.array(),单文件就用 upload.single()（后续都是单文件示例中说明）;<br>&emsp;&emsp;&emsp;&emsp;3、第二点()里面的标志字符串要和前台页面中的<code>&lt;input id=&#39;upload&#39; type=&quot;file&quot; name=&quot;file&quot; /&gt;</code>name 属性一致。</p><p>&emsp;&emsp;如果步骤都正确，成功上传，应该可以看到前台页面如下：<br><img alt="上传成功" data-src="/../images/TA/express-multer-demo/pic/%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F.png" class="lazyload"></p><p>&emsp;&emsp;router 的回调中取得上传文件的信息，如下：<br><img alt="上传成功router取得文件信息" data-src="/../images/TA/express-multer-demo/pic/%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9Frouter%E5%8F%96%E5%BE%97%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF.png" class="lazyload"></p><p>&emsp;&emsp;文件上传的位置：<br><img alt="第一次上传成功后台地址" data-src="/../images/TA/express-multer-demo/pic/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F%E5%90%8E%E5%8F%B0%E5%9C%B0%E5%9D%80.png" class="lazyload"></p><h1 id="关于使用-multer-文本域数据"><a href="#关于使用-multer-文本域数据" class="headerlink" title="关于使用 multer 文本域数据"></a>关于使用 multer 文本域数据</h1><p>&emsp;&emsp;multer 的 readme 所说：”Multer 会添加一个 body 对象 以及 file 或 files 对象 到 express 的 request 对象中。 body 对象包含表单的文本域信息，file 或 files 对象包含对象表单上传的文件信息。“<br>&emsp;&emsp;实际测试，在前台页面 index.ejs 创建 formData 后，append 一个文本数据：</p><pre><code>let formData = new FormData();// 补入此句formData.append(&#39;dest&#39;, &#39;file_upload&#39;);</code></pre><p>&emsp;&emsp;刷新页面之后，重新上传，可以在 multer 配置中，在 diskStorage 的 destination 的 callback 中，可以得到 req.body 包含了 dest 属性。如下图：<br><img alt="req.body获取文本域数据" data-src="/../images/TA/express-multer-demo/pic/req.body%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E5%9F%9F%E6%95%B0%E6%8D%AE.png" class="lazyload"></p><p>&emsp;&emsp;这是好事，很好的，这样，在前台上传文件时，就可以把需要上传的地址放到这里，那么不同的文件上传就可以存放的不同的地址了。<br>&emsp;&emsp;那么会有哪些问题呢？<br>&emsp;&emsp;&emsp;&emsp;1、前端需要知道后台的上传路径，不合理。<br>&emsp;&emsp;&emsp;&emsp;2、并不是所有使用 formData.append()添加的属性都能在文件上传 destination 生成前，在 req.body 中获取到。</p><p>&emsp;&emsp;&emsp;&emsp;这是一个实际遇到的问题，我在使用 angular 时，使用 HttpClient 实现文件上传操作，类似：</p><pre><code>  upload(file: any) {    // 文件使用FormData发送    const formData: FormData = new FormData();    formData.append(&#39;file&#39;, file, file.name);    formData.append(&#39;file_name&#39;, file, file.name);    return this.http.post(this.URL + &#39;/upload&#39;, formData );  }</code></pre><p>&emsp;&emsp;后台的 req.body 在获取到上传的文件前并不会有 file_name 属性的值，即在 multer 配置在 diskStorage 的 destination 的 callback 中，可以得到 req.body 是空，在对应 upload 的 router 回调中，才取得 req.body 的 file_name 属性。</p><h1 id="在-router-的回调中，指定文件上传的路径。"><a href="#在-router-的回调中，指定文件上传的路径。" class="headerlink" title="在 router 的回调中，指定文件上传的路径。"></a>在 router 的回调中，指定文件上传的路径。</h1><p>&emsp;&emsp;在”关于使用 multer 文本域数据“这部分有讲到，前台直接传入文件上传的路径不合理，在接受到上传的文件前得到指定的上传路径也不一定成功，而直接使用配置好的 multer，其文件上传目的地 destination 又只有固定一个。该如何实现？</p><p>&emsp;&emsp;<strong>把 multer 的配置，封装到一个返回 promise 的函数，指定传入一个文件路径参数，并在 router 的回调中使用该函数，传入上传路径。</strong></p><p>&emsp;&emsp;修改 utils/Upload.js 文件，补入以下内容：</p><pre><code>// multer文件上传,可指定上传路径,不在router参数里直接用let uploadFunction = (req, res, dest) =&gt; {    let storage = multer.diskStorage({        destination: function (req, file, cb) {            let newDestination = dest;            let stat = null;            try {                // 检查传入的路径是否存在，不存在则创件                stat = fs.statSync(newDestination);            } catch (err) {                fs.mkdirSync(newDestination);            }            if (stat &amp;&amp; !stat.isDirectory()) {                throw new Error(&#39;文件目录： &quot;&#39; + dest + &#39;已存在！&quot;&#39;);            }            cb(null, newDestination);        },        filename: function (req, file, callback) {            callback(null, file.originalname);        }    });    let upload = multer({        storage: storage    }).single(&#39;file&#39;);    return new Promise((resolve, reject) =&gt; {        upload(req, res, (err) =&gt; {            if (err) {                return reject(err);            }            resolve();        })    })};</code></pre><p>&emsp;&emsp;记得导出：</p><pre><code>module.exports = {    fileUpdate: multer({ &#39;storage&#39;: fileStorage }),    uploadFunction,}</code></pre><p>&emsp;&emsp;在 router 中使用，修改原 routes/index.js 的 upload 路由如下：</p><pre><code>router.post(&#39;/upload&#39;, /*upload.fileUpdate.single(&#39;file&#39;), */ async function (req, res, next) {  // 指定文件上传路径  let uploadPath = &#39;test_upload&#39;;  // 等到文件上传完成  await upload.uploadFunction(req, res, uploadPath);  const file = req.file;  console.log(req.file);  //如果得到了文件，就返回上传成功  if (file) {    return res.status(200).json({ success: true });  } else {    return res.status(500).json({ success: false });  }});</code></pre><p>&emsp;&emsp;当然，await 需要在 async 函数中使用，也最好放到 trycatch 中。</p><p>&emsp;&emsp;如果步骤正确，结果应该和第一步中的一样，文件上传成功。在后台的项目中会新建一个 test_upload 文件夹，并有上传的文件。<br><img alt="第二次文件上传成功位置" data-src="/../images/TA/express-multer-demo/pic/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F%E4%BD%8D%E7%BD%AE.png" class="lazyload"></p><p>&emsp;&emsp;代码已放到 <a href="https://github.com/Sanotsu/express-multer-demo" target="_blank" rel="noopener">github</a>，有需求可查阅。</p><p>&emsp;&emsp;以上内容，全部亲测有效，如果有问题，请提出交流，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> multer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高中创作古体诗词合集</title>
      <link href="/2019/10/19/OrdinaryArticles/03poetry/"/>
      <url>/2019/10/19/OrdinaryArticles/03poetry/</url>
      
        <content type="html"><![CDATA[<p>千里萧瑟，归去，也无风景也无愁<br>Swm Lee 苏魏明<br>诗辛卯杂诗（廿一首）</p><p>其一<br>昨夜海棠风，吹散百花中。不知春寒至，寂寞桃园公。<br>其二<br>晚风浮月光，断波托夜香。几缕相思絮，寒秋寄我窗。<br>其三<br>汉唐有遗风，塞德华清宫。茉莉百年韵，舒眉一笑中。<br>其四<br>山水丹青色，天地余飞白。春深花渐落，残香由谁摘？<br>其五<br>黄牛小牧童，吹笛春风中。时吟复低头，清水碧草峰。<br>其六<br>张弓取翎羽，怡心或为趣。斐然不知数，为君歌一曲。<br>其七<br>月明故人怀，情浓倩女猜。回眸不经意，尝饴如梦来。<br>其八<br>千峰景只厚，何止登泰山。万里茫如雾，迷情问其间。<br>其九<br>常念思不动，优娴自风流。东风不相识，不知其何然。<br>其十<br>秋节落南空，春雷响江洪。尺书雁归寄，不敢问来鸿。<br>十一<br>乱红为我舞，心碎不解情。人生底事忙，何处觅安宁。<br>十二<br>金瓶一枝梅，鲜妍能几时？不知东风后，何处弃遗枝。<br>十三<br>当年咏梅处，如今知谁在。行人各纷纷，还有残梅开。<br>十四<br>君向何处行，灼日汗飘零。若渴与瓜解，犬吠道虫鸣。<br>十五<br>老犬卧道旁，行人各复往。唤归食肉骨，夜深独彷徨。<br>十六<br>残香未殆尽，春寒发几枝？一夏满子荷，空高留心痴。<br>十七<br>有心画江山，迷漫满城烟。一雨清飞尘，还闻车马喧。<br>十八<br>伏虎狮子山，猎鹰雁门关。东海采莲舟，西湖猎蛟船。<br>十九<br>大黑千山暗，川穿霓虹散。遥闻车鸣急，夜枭独飞宽。<br>二十<br>君仍惆怅客，我本憔悴人。孤独守夜者，泪落闲时分。<br>廿一<br>硕人其修兮，月与灯俱昼。摇步翠屏影，也把青红嗅。</p><p>壬辰七绝杂诗（廿九首）</p><p>其一<br>镜中这人真卑鄙，漫言枉语他人寄。贫贱农人少失闲，纨绔子弟多得意。<br>其二<br>柳腰风摆柳色失，杏花酒美杏花醉。迷踪菜花黄蝶追，冲破苍天白鹤回。<br>其三<br>千古悲怆凭谁问，百世孤独人生梦。假使破舟抵万字，做梦飞蝶又何人？<br>其四<br>蔓草深巷无酒杯，春花落玉有旧醅。千古风流空寂寞，凭虚公子惹惆悲。<br>其五<br>池鱼有心暴泉岩，叛燕依情计日归。花心无奈才初落，水兴波澜一扶红。<br>其六<br>玉人不与我玩笑，我吵吵叨叨太闹。不知何处得饴糖，卧树一枕黄粱少。<br>其七<br>明月散辉千树映，几家寂寞几家忧。都道何处无喜事，空空落落停复走。<br>其八<br>君问我心何所似，料峭东风六月冰。枯枝摇坠随流水，羞与落花共长清。<br>其九<br>王堪叹瘦牡丹香，何事无情出画廊？文章总为笑人作，静女红颜非独往。<br>其十<br>天杀风景我杀心，滚滚秋风献殷勤。康庄大道左相邀，偏向西边追落阴。<br>十一<br>一曲舞尽皆开颜，徒把欢笑作戏言。多少云雨人喧谑，千古风流鲜为传。<br>十二<br>我自独面三千狼，何管他人笑骂伤。天生志气难泯灭，不到东岳不正装。<br>十三<br>人生莫谈愁上愁，只是年少便爱酒。风雨几开几度秋，大抵是空叹心揪。<br>十四<br>清瘦未必真相思，陌途不独假无情。星天有梦终让醒，却将美酒巨觥倾。<br>十五<br>莫言丰年实仓廪，走马千里酒家无。可怜从阳俯黄面，十分耕耘十分苦。<br>十六<br>心神不定人堪哀，小雨北风过楼台。遥闻灯噪佳人笑，红绡帐中散银来。<br>十七<br>一着席白半露雪，春姗轻步泪晶莹。多言红尘深无路，劝君莫夸自清灵。<br>十八<br>区区人生数十载，一山不登二山来。借得云梯上山去，半悬空中何其哀。<br>十九<br>九曲连环策马刀，从随萧萧鸣东枭。一骑平川八千里，汉家百万枯骨郊。<br>二十<br>千里悲天肥如油，白云飘过一声愁。不知何时成海绵，一路吸附一路流。<br>廿一<br>一夜黄雨梅子香，半风瑟瑟半风凉。有酒借来且暖胃，不知春寒梦几长。<br>廿二<br>几日春来雾霭霭，昨又立夏天未开。守得一干枯索塘，只盼雨乱且疾来。<br>廿三<br>春蚕老死桑未落，夏荷新出雨不休。祝融燃情或气弱，一脉亲承暗神州。<br>廿四<br>逐名追利或为何，一宿一餐皆自可。春去愁上心头坐，秋来还将寂情搁。<br>廿五<br>轻烟蔓草绕枯城，小扣紫窗飘飞尘。遥想当年人声沸，可知青鸟老树根。<br>廿六<br>绝代风华叹几载，一川烟草随火烧。各人食来皆相似，不求富贵先求饱。<br>廿七<br>灯红酒绿车马喧，平壁绚彩暗见天。疑心明月晴不再，独自垂泪不成眠。<br>廿八<br>轻狂少年轻挥鞭，老牛闻声且徐沿。姑娘扭头荷中散，不知重面是可怜。<br>廿九<br>独坐空楼人心烦，忽闻窗外鸟声残。若只惊飞雨打翼，不如枯笔成笑谈。</p><p>自诩<br>缱绻绸缪缠绵绿，经纬纺织缥缈红。怅怅懆懆惵惙惙，惶惶悢悢愫悾悾。</p><p>巷里桃花<br>春来桃花几多红，摇摇作步小巷中。料得把花簪头戴，人面不知桃花红。</p><p>老翁<br>老翁滑琴又张弓，斗米千杯笑梁公。朝荷锄犁东向去，西归换酒三两盅。</p><p>悲秋五首</p><p>其一<br>绝地未死春依旧，挑破重秋复见天。何时浊云毕尽去，立拔环刀割月弦。<br>其二<br>多少风雨多少悲，秋风吹罢又飞回。才从天上下黄泉，又强月寒捉炙辉。<br>其三<br>落黄无奈悲秋风，迁路不悔封尘中。一飞九天生枯叶，不笑残凉已过冬。<br>其四<br>天南地北双飞燕，东风西雨各伤心。我恐悲秋伤过客，归程万里望月亭。<br>其五<br>落叶吓鱼入石避，悲嗟惊鸟离巢飞。愤恨不堪担月影，我借秋刀夜杀人。</p><p>秋词四首<br>其一<br>秋节因秋心秋在，秋心沟壑秋水溉。秋水从秋天上去，天人怜君降秋来。<br>其二<br>我借秋刀画秋容，秋风笑我秋长空。连枝秋叶归秋落，秋雁带血秋书红。<br>其三<br>秋心或因秋人变，一秋金叶一秋丘。秋家藏秋乱秋绪，秋风带泪解成秋。<br>其四<br>秋风秋雨乱秋声，秋啼秋鸣作秋悲。秋人独立秋桥上，便引秋情化秋归。</p><p>有感五首</p><p>其一<br>燕子江边燕子楼，燕子楼上人倚楼。落辉过后短清漏，何处明月空照楼？<br>其二<br>游园一梦相思寄，奈何相思人不时。相思无心千秋在，那人灯后无相思。<br>其三<br>苦哉九月掘藕人，却叹藕心空且枯。胡折老藕茎径断，千丝万缕倒不出。<br>其四<br>今年槐花我不见，人念槐花往日艳。槐花一树白如雪，散尽江岸遍锦缎。<br>其五<br>蚕死留丝可成绸，蜡炬垂泪为君忧。飞蛾无心带芯灭，道是夜雨晴难求。</p><p>壬辰五律杂诗（九首）</p><p>其一<br>月破中天残，雾愁云地宽。畎水漳河流，村树南山攒。<br>鹏飞了路遥，叶落知夜短。清清落魄人，不足苦倚栏。<br>其二<br>青山请为荫，沃土殷作棺。问我何处葬，得君此地勘。<br>无能芊芊手，不才滔滔畔。天高莫难伤，匆匆小径延。<br>其三<br>平江远更延，舟泊酒家边。细烟随风舞，残叶沿影翩。<br>无声蛙乱叫，有情人未眠。寂寞广寒宫，舒袖为谁颜？<br>其四<br>秋风无几日，秋事倍伤身。枯石久折木，断塔常忆峥。<br>落陌无人问，生道有仙升。不知若我辈，何处长伤神。<br>其五<br>横日西岩挂，乱鸟北天行。残花荒处歇，孤蝶野中隐。<br>千里风影马，几寸游丝心。向来路犹辨，去时景不清。<br>其六<br>晴阴低水望，隔山送青影。空留春壳在，徒画夏情阴。<br>漫漫遥遥阔，寂寂枉枉轻。伤心欲滴泪，此地无相亲。<br>其七<br>大路喧亦平，小曲静且幽。善奔追飞鹤，安缓钓轻舟。<br>公子患风瘦，亲身忧鸠啾。天下大事忙，徒坐青发秋。<br>其八<br>乱雨红残忾，飞影奔白溪。青鸟鸣恰恰，绿竹曳猗猗。<br>秋发随刀下，春情与怨齐。辽辽野径远，杜宇催别离。<br>其九<br>车马来往疾，行人叫嚣高。坐卧气不匀，伏步情且噪。<br>忽忆南山阴，遥想东皋嚎。何日囚樊笼，忘我明月妖。</p><p>读史有感<br>琅嬛何书有？借我凡尘游。天下一石才，平添八斗愁。<br>拭刀却狻猊，弹剑沉貔貅。醽醁凭须尽，一醉解春秋。</p><p>南方有嘉木<br>南方有嘉木，人传为霜斓。鸡鸣花欲落，蝉唱露先干。<br>翠微倾远径，花圃荒邻园。先生善承蜩，奈何倚栅栏？</p><p>凄词<br>越女多情意，南柯本寡欢。十年两行泪，三秋对眼穿。<br>一心失五色，四海落八番。六月梅子黄，九州还独酣。</p><p>答友<br>伊人语不凡，陈酒香我友。清新细雨荷，含蓄微风柳。<br>烽火高啸马，殷勤低语鸠。未至情深处，借醉凭生愁。</p><p>凉辞六首<br>其一<br>有凉旋空舞，随去至何处。落木追飞鸟，流云遮天路。<br>满川游江河，一线悬枯树。知是疯人来，牛头作悲赋。<br>其二<br>又凉春风暮，白马行无路。悲嘶恻天庭，哀嚎恸地府。<br>狂歌无杯盏，乱醉犹歌舞。滚马惊嗟起，杏花村何处？<br>其三<br>再凉夜寒宿，一河挂星树。嫦娥舒广袖，织女续机杼。<br>蝉噪蛙声澈，灯红酒味足。白马卧空棚，悲叹禁不住。<br>其四<br>早凉寒雾凝，一脉圆荷露。黄草燃白烟，青鸟上翠树。<br>野味自山来，浊酒由泛渡。忍口待我归，随耕春山暮。<br>其五<br>晚凉遮蔽露，大风封山缺。一乱走江水，三年奔泉穴。<br>遗留断章句，放逐连城决。悲绪无端由，至死或方绝。<br>其六<br>春凉丝雨细，风轻落木寒。枯棋起复落，老觚虚又添。<br>哭追十年病，欣度三日闲。明朝忍别君，有酒路归远。</p><p>清静辞<br>绣鸟空啼花落忙，巧柳枉生河断淌。青丝带愁鸢借去，红尘掩质离路罔。<br>丧家傲犬知自嘲，离群残燕失己伤。梅鹤痴得清静在，南山幽曲无草长。</p><p>长诉<br>琥珀半轮泪半霜，一任艅艎向小沧。折浪延绵斜北冥，落日横圆逆南荒。<br>山水远近悠悠岸，心神浮沉款款篁。苍径知我懒作扫，幽幽疏曲凄青黄。</p><p>乡人愁<br>小月弯弯寄愁怅，几家无情人断肠。破庭深深无花红，层峦郁郁有鸟唱。<br>守得黄犬吠陌客，留着瘦禽待落郎。不堪荒草荫浅苗，一厢殷勤付流江。</p><p>旧访<br>窗外有花花不发，室内无人人堪下。九折山路刚下车，三番水流又骑马。<br>牧童才解黄牛索，村舍方开青春匣。浊酒不弃一饮尽，淡茶徒受旧人夸。</p><p>开卷乱作<br>抽刀舞罢河水断，仰天饮尽杜康酒。凭虚公子柔情弱，乌有先生傲骨遒。<br>黑发平原向晚泣，白须田园对月酬。人生自古谁得意，舴艋载愁遏江流。</p><p>闲日自说<br>低声下气本吾愿，忆得陶公三径荒。只因无能难断念，岂非有情易感伤。<br>古人失意可借酒，今我残生怎返光。一随风景任老去，心如天地倩谁藏。</p><p>毕业有感乱作两首<br>其一<br>阴云轻散露华光，银雨丝折隔青茫。残蝶弋行枯枝傍，野草横卧乱山岗。<br>流年追去千番苦，来生思忆一岁长。可怜九月勃勃日，断送悲秋梦里荒。<br>其二<br>木丹凋尽酒壶空，一别君后何相期？白发还有几年岁？黄河犹流任东西。<br>枯琴衰声萦不去，悲歌哀调绕难离。此曲天上不应弹，散尽人间处处凄。</p><p>一月十七日夜无情乱作<br>碧泉无暇深山静，幽笛有韵峭崖清。明明皓月破绿波，戚戚琴音碎枯情。<br>萧萧落木逐飞尘，妍妍红日向来阴。知君此景消不得，轻划一叶见长亭。</p><p>念归客<br>念归客，夜渐深。风雨显，伞犹驻。千鸟尽，黄犬回。<br>蜂入巢，蚁易穴。纵有晴，须更说。空又厮，难相解。<br>应半语，子不言。谓我愁，何须解。山有峰，海厌深。<br>量有度，仁不义。百难与，智神清。重山重，断其断。<br>兴其兴，归吾归。</p><p>砭时歌<br>腹中空空，佳食难衷。为何难咽，心已重重。古之贤者，淡求名利。<br>今之学者，以古谋幸。朝朝日出，冥冥月坠。一夫为柱，众蠹蚀木。<br>木石前缘，已有侧重。咄咄逼人，原嗜酒命。饮者有醉，饮者浇愁。<br>明明清泉，不可决觉。所谓食粮，众所拼抢。人人济济，归归本心。<br>举目饮天，三尺神明。君有性兮，落云泽雨。换而新之，如姣如皓。<br>亲亲子与，悠断南绝。大路歌兮，执手相迎。</p><p>夜书<br>昨夜秋风凉，残星取暖去。今宵夜更冷，隐星竟出来。<br>缘有上令召，为作指路引。旁人识路走，我独向天看。<br>茫茫沉沉阔，隐隐虚虚合。翻身风折叠，挥手光盘旋。<br>千军提叛贼，天将擒佞人。一扶初光时，万物开明明。<br>唯我仰视之，下召宣我往。天殿虽好舍，不如归家里。<br>人间有浊臭，待我清扫去。大路有洁日，上去亦不迟。</p><p>书怀<br>残光浓雾中，路湿雨亦稀。亲朋期日缺，陌途鲜惊依。<br>鬼话疯人语，破草敝蓑衣。一人不知往，天下几女子。<br>静中有何致，闲里无可唏。徒走醒又睡，风过又窗倚。<br>照镜疑三目，伸手似五指。可怜今夕月，西风兼雨期。<br>衣中藏个口，禾火心还栗。天可右勾变，大江横舍一。<br>清河几多水，心竖草千里。欲约寄月情，飘飘戈下际。<br>苟凭生死去，且盼酒米祭。</p><p>破夜书怀<br>昨夜言千字，今朝尝肃心。比翼单飞燕，和光入世归。<br>天晴灯阑光，无人夜单行。寂寞听风影，惆怅观光音。<br>少年不胜酒，邀月代我饮。东坡从中来，天高月不晴。<br>去凉何其致，热火中烧寒。洗戟忆前朝，空话亦有道。<br>东风本应无，只是孔明催。菊在南山下，松居三径荒。<br>一人知其往，何须笑折腰。拔山虽盖世，天亡不可轻。<br>若是宴中灭，何会垓下围。汩江水不清，洁垢愈沾尘。<br>去他王堪瘦，十歌多叹留。岁月空蹉跎，今人难吟收。<br>花落春中尽，叶弃秋日回。我自逍遥去，扁舟凌云天。</p><p>中秋杂句<br>且从游，天南地北空悠悠。大秋酿了丰收酒，伴君无饮一口。<br>且回头，各种人物尽乡走。留我等品相思愁，追萤流月轻舟。<br>且情仇，待我折戟沉西流。一纸写得言语久，海天相望君守。<br>且心忧，四海为家业难求。世间本来长短有，福禄与月同受。</p><p>少年事<br>不厌秋雨潇潇下，虽如青丝不是春。昔日风烟绝胜柳，今地风雷尽苍魂。<br>射鹰驱狼毕侵意，跃马扬鞭定乾坤。肝胆如裂未成气，印面啮血心不寒。<br>待到功名鹊喜泣，借尔盘古开混沌。</p><p>前道<br>那个门前何所似，莫非昨才离别人。大笑径取拍肩去，转面笑颜浑不识。<br>不堪欲解缘何误，由来一体才出门。天道苍茫路途远，宜结伙伴防豺狼。<br>千番风雨有何怕，一举四手折天横。</p><p>树高悲狐<br>树高木折身既死，扎根三丈不偏移。大鹏展翅拔山起，飞阔千里一鸣回。<br>黄沙射日牵我心，清流小桥浣衣引。自古炎黄向天地，惊死残命念本情。<br>一思一眷难判明，黑发犹从霜鬓生。怀此祷先同悯者，具备乘鹤始毫挥。</p><p>春思<br>一点春思三秋起，日日复念雪欲期。似是重唱越女词，心悦君兮君不知。<br>由来本是托寄物，何管相思变成诗。可怜假情害真意，多由总是有人痴。<br>至寒不过愁肠酒，几炙又堪暖我心。满树芳芳正骄傲，无奈却道春未至。<br>天下何处是放翁，独破冰中无所几。</p><p>战树其苍兮木其黄，凤其鸾兮龙其刚。人其哀兮气其昂，灭孤重兮兴不亡。<br>去其国兮雾漫茫，归其家兮甲兵强。提携剑兮为君死，鬼雄魄兮生人别。<br>主其令兮将其将，客之宴兮泣涕下。三尺神兮天明鉴，戈矛对兮情亦忾。<br>哀其生兮域应加，汝妻子兮我嫂侄。君入归兮君乃葬，生不付兮生者爱。<br>松之傲兮神以灵，竹之韧兮魂以固。再与战兮折我戟，垂而治兮我宁奴。<br>而慨记兮三杯酒，清明正兮代我饮。</p><p>夏雨辞<br>不借兵符不求仙，黑乌连天敝空间。冲发一怒雷电裂，滚滚西水平岳巅。<br>逐鹿甲器折销碎，艨艟千里赤壁焰。太屋山顶响铜鼓，北溟深蛟出水宽。<br>不带春柔几分甜，无端嚎啕六月天。落下珍珠一线系，溅起瓦楞散彩延。<br>檐前燕子闲久立，房上浓烟聚又翩。一派清荷茫茫现，满地红泥点点斑。<br>层层波掀舞衣露，叠叠绿翡压腰弯。待到塘鱼跃江河，声消雨歇风吹栏。<br>本为几时少闲累，始作一刻桑田干。千山万壑新绿再，饱受此番苦折难。<br>万池碧叶亭亭立，随风扶姿托殷胭。崦嵫斜处微光见，晚有蜻蜓度凉闲。</p><p>梦野<br>花残酒绿圆梦缘，酒洒黄土花不晓。借得春茗三更尝，偷来骄阳难过饶。<br>青竹有叶一枝扇，冬松无木半革干。我不借酒驱无意，酒不得我赞无言。<br>一迁白马走千里，却见江海平九天。若为梧桐倚墙绿，可非芭蕉夜难眠。<br>夜卧东坡醉复醒，涛声不显人声贱。喧喧连岸三千丈，岸水江天四处延。<br>一任狂月得君愁，君不明言酒自消。不才千杯为君饮，可知我君为谁汍。<br>独坐合丈酒轻贵，人来少失味不甜。我家有树曰合欢，植在村头麦田绵。<br>但见月落人长在，只因觉醒无外显。村头树下知何人，知君只爱花下艳。<br>花未吐露人未醉，人借花语解花娇。花岂人语知何意，人恼花语解难晓。<br>大风春落全零落，知是花魂鸟魂谙。杯中见月为君笑，知君天奈空难了。<br>花欲乘风化风去，蝶怨花落不解缱。风不招蝶蝶自怒，半为恼风半为羨。<br>只恐夜深君独醉，故借翩翩声声断。茫茫浩浩飘飘碎，跹跹叠叠长长厌。<br>别君去兮永不还，本只江岸夜饮拳。千里驱车走长城，日日夜夜似年年。<br>万山青林岩半露，百里人烟作酒钱。相见时难别亦难，春去秋来不得闲。<br>去时小姬灭纣暴，归时马嵬影姗姗。牛毛轻落路未湿，同行乡人尽梦连。<br>我本人间楚狂客，宁为此伊憔悴颜。落落苍天无人问，独破清漏夜长眠。<br>风吹百花蝶翩舞，蝶恋花绵如风渐。今夕月明思君泪，明朝山隐绝君雁。</p><p>词</p><p>唐多令<br>灯红酒绿足，窗前盼月下。寂寥烧烛夜探花。<br>思愁本来日日呈，约嫦娥，无非她。</p><p>如梦令<br>空山流泉泠石，老树幼雏初鸣。东盘西绕折，忽现竹稀舍处。<br>甚好，甚好，邀我共尽余杯。</p><p>昭君怨<br>小诗未带真情，却有流火飞萤。俏得惹人爱，催香茗。<br>江山何必亲承，谁家无事空忧。念往事伤心，泪竭流。</p><p>昭君怨<br>秋叶自有芳尘，倩谁无情空扫。随风往事追，已作灰。<br>昔忆不留念去，偶有微尘罔罪。好汉当年勇，世人悲。</p><p>昭君怨<br>银杏暗香无语，權丛背后有声。长凳分两头，有何人？<br>灯火明过月影，密云隔行月升。车流来往急，未启程。</p><p>点绛唇<br>重飘叠坠，积风卷得妆晶莹。素银丝展，惊鸟失落霙。<br>小灶酒暖，尚有暗梅诗，斑驳影。当年咏处，犹有君孤零。</p><p>关河令<br>自信人间断珠联，青山双流泪。古渡遗舟，逗绿水疲惫。<br>连绵若途万里，碎十二年悲恨梦。身醉荒河，人道流萤飞。</p><p>采桑子<br>百花残时百花归，落蕊烟挥，不堪堕摧。飞黄浩浩寒魄辉。<br>乱红流水怕污闺，葬花人卑。料谁轻扫，窃作农家燃火灰。</p><p>阮郎归<br>龙虎榜头第一名，万众齐仰之。宝铛金玉隐还露，拆而随散之。<br>一袋烟，一壶酒，老头垄上守。若是百闲无一事，可否回乡走？</p><p>阮郎归<br>一线传音话语少，问我归是否？每每欲谈千万言，却泪止回流。<br>此无月，彼处有，得日再回首。别问我心可会怨，天下共西楼。</p><p>菩萨蛮<br>微风吹落槿花残，绕舞曼姿歌频断。相思无计日，与君叙一晚。<br>千斤铁蹄鞋，空嘶泪回散。山黄斜影远，归望向来天。</p><p>菩萨蛮<br>烈风不解柔情在，苛我冰炭划分经。三秋叶不恋，明年枝犹青。<br>窃君作太阳，日日悬空明。葵藿何能尔，死君心方倾。</p><p>菩萨蛮<br>桂花隐有香心透，霜华满地破清秋。千里江山梦，今夜共一酬。<br>此时寻芳草，不知何处有。遥望残栀影，老家植西楼。</p><p>画堂春<br>小宴酒散影蹒跚，乡人几多言语。他处独坐观秋绪，风流词句。<br>去年中秋时雨，惊得夜啼无趣。岂知今年异乡里，还添忧郁。</p><p>诉衷情<br>翠竹挟雨掩清泪，暗有伤荷意。孤亭檐落无语，执着一线系。<br>断风尘，谙世音，填江月。蛙声乱坠，老犬轻吠，抑郁人醉。</p><p>诉衷情<br>三更风雨三更秋，寒烛寒心忧。千里遮蔽不透，还拂枯琴留。<br>虫鸣残，杯酒干，灯芯断。一双老眼，一片赤心，一声长叹。</p><p>诉衷情<br>绣锦玉案盈满肴，也得众亲笑。月光不见人在，对影燃火烧。<br>遥记得，中秋夜，残栀招。往年共聊，今日分散，何时共嚣？</p><p>浪淘沙<br>一载半春秋，残力回首，明明历历意在暖，枉汝不识开眼传，谁吾思秋。<br>雪葬荷花寒，尔绝私情。日日得见是汝影，却难月色空掩晴，问汝可名？</p><p>浪淘沙<br>乱红已荣里。倾地寻觅，南山不顾耐凄离。又欲平心攒星集，霾云遮蔽。<br>应得已难记，楫舟已启。逆风击浪未远已。两畔故事事事忆，吾谁与寄？</p><p>浪淘沙<br>早日疑别离，日见察理。行如风景静似绮。窥眼已然思亲密，漫言心底。<br>忽见为人记，始觉忿罹。日日伴君不在意，今愧旧日狂妄语，汝安能记？</p><p>浪淘沙<br>夜深叶悄息，念残蕊亦。十年一剑不弃疾。亮剑谁有不平事，拭者谁知？<br>可怜无所谊，寒风习习。向看灯火不灭处，心中倩谁可堪思。沉睡千里。</p><p>少年游<br>当年行日擒苍龙，紫电乱如虹。作笔西东，作笔西东，较天马行空。<br>尚才往日醉成梦，千山暮雪封。红尘初衷，红尘初衷，旦晚付悲风。</p><p>柳梢青<br>夜风轻扫，黑云微散，寒月无声。长篙东指，流水吻舷，恹恹孤灯。<br>大江万里共色，繁华烟气消三更。反裘负刍，凤冠霞帔，一般眼神。</p><p>虞美人<br>蛩鸣犬吠渔人灯，今夜有秋风。月应来诺与之约，中秋栀子残香为谁留？<br>千山重阻催思绪，我本居故里。多少话语应传说，岂能一线了解心中事？</p><p>虞美人<br>天下风景多谙情，无奈飞思有。衣缝密密身既暖，倚墙东望稀星怎解忧？<br>可恨两行慈目泪，天涯游不走。人生能有几多愁，忍看八月飞雪六月秋。</p><p>鹧鸪天<br>秋风吹罢叶应少，格骨百筋炼火烧。白发老者须尽银，青炉红锤清酒浇。<br>尘沦乱，性形变，我为少年空嗟叹。期颐过后岁犹长，我心一只白头雁。</p><p>鹊桥仙<br>深深庭院，乔木早枯，鹊鸦不见闺帘。羞月遮霞琥珀片，清秋不敢锁朱颜。<br>绝壁半劈，黑城绕山，无酒洒血正酣。日落崦嵫拭宝剑，自诺红染一河天。</p><p>蝶恋花<br>燕子微风杏花楼，纤草陌纤，曲径无通幽。料得生得躯壳善，难得腹内几春秋。<br>空怜葬花人多情，痴痴凝视，心乱意不在。私借月老和红线，不知多少方缠绵。</p><p>醉落魄<br>祝融气盛，钰宝不足炼其魂。晴云落魄惊鸟乱。十分嚣张，八面铜鼓坤。<br>岁岁年年袅气散，生裂暴戾应沉淀。日高城空万物尽。快过烟渚，乐甘霖淳淳。</p><p>醉落魄<br>大夜落余，明灯阔室人头攒。自古人生风雨中，百三十年，携刀不磨剑。<br>泼墨山间寒气深，黑云翻卷恶龙回。十年刃刀今废倦，金光霞辉，虬髯青发灰。</p><p>醉落魄<br>月本长有，可惜今日约不候。此时不共残烛。三三两两，归去也思友。<br>天涯何处无左右，半晌悲伤且望柳。青丝借风微摆走。本待今日，共饮菊花酒。</p><p>一剪梅<br>寒心一叶悬半壁，春头日上，落魄江郎。斜照透过愁云来，风色萧萧，哀声枯塘。<br>犹记当年自在处，隐影白鹤，野水辽旷。可怜白马追不回，秋风卷草，来日方长。</p><p>一剪梅<br>落破江山谁为王？南面称孤，大河西望。烈雁带血硝烟漫，黑灰失色，枯肠径断。<br>笙歌靡靡使人怨，行者纷纷，归心似箭。奈何馁虎势威远，千里愁路，豺狼跛现。</p><p>一剪梅<br>飞寒薄暮扶帘轻，累了双燕，残了秋丝。十里长亭玉容在，红了落叶，青了枯枝。<br>都道飞雪春不远，竭了老眼，肥了鲤鲫。人生几何害相思，从了义山，随了若士。</p><p>苏幕遮<br>叶未换，景未变，物格人方，一墙藤枯乱。满院落叶归根散，斜雨微风，渲染相思慢。<br>花开时，香一段，风流尽颤，堪受人行懒。我欲借看画柳诗，芳菲无情，谁恨我多情？</p><p>钗头凤<br>离恨天，万丈渊，何处相思未成眠？三千里，二十年，衰草枯扬，荒阳斜远，念，念，念。<br>赤壁下，大江边，笑曹操刘备孙权。机关尽，聪明断，儿女情长，戎马江山，贱，贱，贱。</p><p>江城子<br>日暮收织急炊烟，濯素手，作羹汤。八仙锦华，斜月破竹篁。强耐红烛湿画扇，倦新眉，失晚妆。<br>昨宵云书入梦来，疑今日，似昨朝。点点清泪，深深倚栏干。凉暗春风无去处，美人案，为谁看？</p><p>江城子<br>鬼风吹零我发稀，杯酒老，月相欺。流影东沉，颜色霜雾漆。天地本来只黑白，徒无事，画多姿。<br>自诩陶令无耕计，乞食前，为酒泣。尔当共鉴，饥妇死足米。借我一双沟壑手，共永醉，笑伏羲。</p><p>孤雁儿<br>晴空无云蔽热情，孤鹜与谁共飞？了然应是一羽重，遍却亢无寻回。残蝶未央，哀蝉失鸣，空空也如风。<br>本是比干失心后，可怜卖菜老妪。若将从书说否字，忠义或难成颂。无心者死，由使之至，痛人不自已。</p><p>解语花<br>野菊遍地，风微物密，正独往凉坝。东边芭蕉，西边橘园兼杏枣枇杷。凝息应听，雨打竹叶珍珠裂。还更说溟潆隐处，有蓑衣人家。<br>黄犬不住吠鸣，邻家自由猫，几只老鸹。炊烟徐上，应是唤我归去把桌抹。几多烦事，经得起风吹雨打。自在人风景如画，画中可汗浃。</p><p>夜合花<br>大道苍茫，人境迷皇，凭生千万孤独。怎得忘记，风伤雾失哀处。何时逢，黄山月，几点竹影倚门户。太白鸟道，借酒浇愁，漫叹不足。<br>雄鹰折翅始飞 铁杵久磨成针，耐若何苦。无情自咎，才过多少夜烛。收拾罢，莫强伫，只不过重展宏图。卧薪尝胆，破釜沉舟，胯下之辱。</p><p>暗香<br>六月飞雪，禁不住哀嚎，好生寂寥。刷白蒿莱，那得逍遥进紫霄。这一声声悲音，知为何，流诉到老。说无了，甚无了，束搁枯牢。<br>肠寸寸断，心亦片片碎，吾谁与笑？狉狉白驹，追一缕清风无恼。安得昌荣盛地，闲落脚，半食干草。莫叹感，却叹感，此地迢迢。</p><p>桂枝香<br>清风路中，白桥横上，映一河流涟。榆桑柳槿榧檀，苍叶飞乱。伏尸波上千青残，悬钓渔，不知哪番。断桥河岸，雷峰塔下，金山寺畔。<br>念了余，为何胡弹。画满城山雨，其人渲染。管毫木端谁看，笔下灿烂。知君无言可推辞，故借风景代君观。银河一桥，执手泪眼，百代遗传。</p><p>念奴娇·宿雨初晴<br>初醒长凉，一晚雨，几番北风私语。雾清不透，拂衣袖，茫茫不堪却步。浮影隐廊，流香跃素。几人携伴与，声声思断，千万风景曾歇。<br>云中哪个放肆，惊雷兼霹雳。龙头蛇身，持令扬器，愧怍怍，不知小口何事？何折得意，扫我暗暗异，飞奔千里。人间无事，仅是悲天人泣。</p><p>眉妩<br>轻描小墨眉，淡染红唇，簪花衬云落，霞辉身上着。摇作步，回镜羞笑还默。我为君妆，君不知，乱心之作。两行泪，散彩污玉容，流郎何处乐？<br>腰系花围裙，炉灶转不停，火烤烟熏。老脸满纵横，犹带笑，应是爱子省亲。盛席华宴，老无力，仅识厨技。夜半肴早凉，向门坐，渐天明。</p><p>眉妩<br>流一束清梦，待峰万仞，作飞阶镂空。追天地飞白，微微冷，好景待似旧弄。荒草黄沙，向往日，兔穴蛇踪。莫叹惋，留香愁灰恨，开眉一笑中。<br>后日可有尽，道色应收忆。潇潇狂雨。雕琴红袖少，浊酒浇。海棠清馥正浓，一珍重。到某日，听来且用。无奈春欲走，莫匆匆，莫匆匆。</p><p>赠言</p><p>千载一古，百世二栖。绝天地之无情，识盈虚之有治。白马疲而止三年，青鸟倦而步三阶。诧傺无绪，愁痛惨怛。然吾以吾志定天下，犹不得求吾心之异已，悲夫。得见时或不多日，相言语或不多时，其心不解，其志不详，其理不察，其言不谙，纵无独绝之冠言，未深白之无力。<br>然求以深也欤，追而思杰，生而衣，死而窆，空空一世，留几多烟华浮云，长歌当哭，轻生死哉。<br>狭口逼仄，丛草参差。前路无途，顾影自怜。望君奋而起，虽坂上一蛙，亦胜井中自诩。浑人比比，昌言胜义。镜花水月，别无二致。言思卓绝，彪炳千秋，亦不远矣。<br>言有尽，思无邪，望君自勉，若期有见，未望远也。</p><p>大学初识</p><p>遥闻大学之道，肩摩毂击。昏昏然庸昧，漠漠然无知。<br>大学者，学之大也。未谙此道，私以为朝乾夕惕，焚膏继晷，明发不寐，以解千载之困也。若然，则十二载思学，亦未绝非凡之难也。<br>成电之名，置邮而传，遥听发然，此鸾翔凤集，虎卧龙藏之所，吾等惟伐毛洗髓，发扬蹈厉，及日，及锋而试。或激浊扬清，或飞扬颐指。然黄口小儿，惟思鸡口牛后之琐然，每每思来，爽然若失。及至入学，亦有蒙蔽之心，且无丹楹刻桷之楼，亦无华彩富丽之舍。区区八百亩之地，半刻且尽，井然无多。再有学时，不知一言，大如羝羊触藩之感。又忆田园庐舍，朝观烟波浩渺，名赏西日横荫，惬意自怡。偶班荆道故，惘有悲戚，唯恐不知所读。<br>然七尺之汉岂涉难且退，我大成电之名空穴之风？学者，学也，非受者。山弥高，登之弥劲；海弥深，潜之弥勤。囊萤映雪，闻鸡起舞，“以中有足乐者，不知口体之奉不若人也。”尚巍巍电子信息，擒来且用。每有克绍箕裘之欲，精采秀发。无欲无私，无愧无溃。且思察学困，尚有硕望。虽难耳提面命，但精神之言，匡我不逮，使不佞发聩，亦光荣之路也。<br>学也不知凡几，崇论宏议，自出我口；闳中肆外，然出我手。恰同学少年，亦心系采兰赠药之思，且有耳鬓厮磨之忆。天隔一方，各求己任，无边风月，时日无长。<br>善交者，不言而群集，善文者，不作而群闻。金风扬面，且徐且行。大学之道，虽塞仍广。莫言苦折，再有复日，亦何莫不然。大者，学为重，友为同，争为次。功名之誉，可遇可求。拔攀之势，且寻且记。<br>搜索枯肠，诚无言辞，各番私论，聊复尔耳。</p><p>整理于2013年10月6日0:46</p><p>此中绝大多数为苏魏明在高中时期所作部分（有几个是大学伊始），如今整理而来，也算对高中的那段风光岁月有个交代。聊以自慰，希望大家别拿他用，算是仅供欣赏吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>别人才是年轻有为的高材生</title>
      <link href="/2019/10/19/DesperateSeries/06bierencaishi/"/>
      <url>/2019/10/19/DesperateSeries/06bierencaishi/</url>
      
        <content type="html"><![CDATA[<h1 id="一样的开始"><a href="#一样的开始" class="headerlink" title="一样的开始"></a>一样的开始</h1><p>　　他们站在那里，我离他们也就十个步子，他们谈笑着，气氛十分轻松，似乎还带着些欢乐。<br>　　其实也没有过多的话，只不过是一个副总带着一个新来的行政人员介绍一位已来三年多的管理人员，言语中描述着，这是公司的新秀，”年轻有为的高材生。”<br>　　事实上来讲，也的确如此。三年多，步步高升，备受器重，前途无限。只不过，突然想到了自己，同样三年多，却只不过是一个丢了成电脸的废物。顿时充满了羞愧感，自卑感，和满心悲凉。<br><img alt data-src="/../images/DS/06bierencaishi/101149.jpg" class="lazyload"></p><h1 id="应该有这么多的疑问吗？"><a href="#应该有这么多的疑问吗？" class="headerlink" title="应该有这么多的疑问吗？"></a>应该有这么多的疑问吗？</h1><p>　　“叹人生，不如意事，十常八九。”不知不觉，人生的十之八九，却变得没了那些分量。<strong>再不如意的事情，总能在间隙中找到一个舒适点，不激进一步，根据现状慢慢妥协。</strong>或许正是因为这常态，反倒让人觉得，不如意的事，才是人生应该充斥的环境，倒也不必再去挣扎，去改变。<br>　　时间一直是个美妙的东西，随着她的流逝，总能带走很多不愉快。如果再加上一点庸庸碌碌，看起来席不瑕暖，整天很充实。<strong>从早忙到晚，总会让人觉得，我这一天天如此辛劳，人生必不可能无趣。</strong><br><img alt data-src="/../images/DS/06bierencaishi/unhappy.jpg" class="lazyload"><br>　　习惯也是一件美妙的事物，无论是习惯了每天的作息，每天的工作内容，每天交际的人物，就算有少许意外，总能靠着充足的经验圆润回来，就很舒服。毕竟常言道，“安安乐乐才是福，平平淡淡才是真。”<br>　　所以我一直处于一个习惯了的舒适区，这样，或许偶尔出现的不安才无法引起内心的骚动。毕竟现在所处的就是我每天都在重复的，它不会出现重大的纰漏，所有的问题都能够有机会解决。<strong>就像温水煮青蛙，在死之前，一点点的改变，并不会促使我做出改变。然而，如果这个水温上升的速度足够的慢，或许这只青蛙并不是被煮死的，只是老死了而已。</strong><br>　　因为，<strong>或许很多人不想在已经习惯的生活中做出一些改变，只是害怕这改变会失去一些东西。</strong>这些东西或许就是一直安于现状的包袱。古人已经说的很明白了，“置之死地而后生”，“背水一战”。很多的故事也这样阐述，我一无所有，还有什么好失去的。往往在这种时候，才让人去拼搏出新的希望。<br>所以说，<strong>安于现状，固步自封，停滞不前，或许没有什么问题，甚至这才应该是正常的选择。</strong></p><h1 id="假如还有意志力的话"><a href="#假如还有意志力的话" class="headerlink" title="假如还有意志力的话"></a>假如还有意志力的话</h1><p>　　突然想起一件陈年往事。应该是在高二快结束了，每年高三学生要毕业了，学校都会允许一些淘旧行为，规划一块地，让即将离开学校的高三学生，把自己不想带走的旧物品先平价卖给后生。我一个同学买了不少旧书，放在他宿舍的书桌上。某天我看到他们的这一堆心灵鸡汤书籍，便问了一句：这些你都有看吗？他说：没有，看了也只有三分钟激情，第二天就回归原状了。<br>　　2019/06/17那天，我也突然被什么事情刺激到了，那前几天都未得好眠。<strong>依稀记得，虽然已经固步于居住在习惯的舒适区，但是大逆不道地觉得这不是我想要的生活。</strong>突然之间，想继续我之前未完成的“事业”，继续心理学考研。我甚至还认真分析了这件事情的很多因素，例如时间，2020考研时间是不够的，目标要定在2021；一定要在保留这份工作的前提下，利用下班等空闲时间，进行心理学专业知识学习；不要去报所谓的考研班，按照上次失败的经历，仅仅是因为知识点背了又忘，所以只需要认真熟读熟背教材知识点，并做题训练；现在开始培养英语语感和听说写环境，听歌都只能英文乡村，新闻多听BBC、CNN；政治到明年准备，避免遗忘……<br>　　多么详细缜密的计划，绝对不是突然头脑一热，拍桌而定。但是随着几天加班，我就不知为什么，就放弃掉了这件事情。<strong>或许正如前面所说，即便对现在的生活不满意，但是并无法成为追求新目标的代价，因为新的目标并不一定实现，但是现在平淡、庸碌、习惯的生活，确是真是存在。</strong><br><img alt data-src="/../images/DS/06bierencaishi/will.jpg" class="lazyload"><br>　　或许真的要想影视作品中那样：我一无所有，还有什么可失去的。才能够勇敢迈出改变的第一步。<br>　　如果我真的有这份坚定的意志力，无论是放弃现在的生活去追求新的目标，还是维持现有的生活，待追求到新的目标之后再放弃，都不会停步在半途。“岂能尽如人意，但求无愧我心”。<strong>然而这份半途而废的quitter、loser羞愧感，随着时间的流逝，随着习惯的打磨，依然无济于事，消失无影。</strong></p><h1 id="活着，从来都不是一个人的事情"><a href="#活着，从来都不是一个人的事情" class="headerlink" title="活着，从来都不是一个人的事情"></a>活着，从来都不是一个人的事情</h1><p>　　人们都说：这人啊，一旦闲下来，就爱胡思乱想。在四个月的庸庸生活之后，因为偶然间听到的一段对话，却在不闲的时候，也开始胡思乱想起来。<br>　　<strong>人，大多都有一个痛点，深藏起来，不愿提起。但是如果被有意无意戳中了这个痛点，总会勾起一些异于平常的心态或动作。</strong>我不知道是狂性大发，是抱头痛哭，是羞愧难当，或者只是面不改色。<br>　　或许有那样的麻木不仁的人，即便是一直被戳痛点，都能够一如既往，一尘不变，那可能这已经变成了曾经的痛处而已了。<br>　　电影《霍元甲》有一句经典台词：“活着，从来都不是一个人的事情”。与别人的步步高升，前程似锦的对比，才让我有了愧疚感和自卑感。因为是成电毕业的学生，与其它一般毕业生相比生活质量差距过大，才更加剧了这份悲凉情绪。因为父母养育，才担心放弃现在即便不满意但是自调节到习惯的生活，会让他们失望和担心……<br><img alt data-src="/../images/DS/06bierencaishi/huoyuanjia.jpg" class="lazyload"><br>　　还拥有生命特征，就算是活着了吗？最近看到一句毒鸡汤，类似：别人过的才是生活，而我只是来凑数的。<strong>有些东西即便不主动去对比，只要还有别人在，那标准就在那里。过着普通的生活，从小比到大，从生比到死，总是有一些通用的衡量标准。</strong>就如喜闻乐见的：你每个月工资多少啊？房子买在哪儿的啊？孩子几岁了？越是简单的标准，越是能让人认清现实。我也企图用一些分流的思想来回避这些问题，例如我和别人不一样，我更看重其它的东西。<br>　　但最后，我才发现，这就是安于现状不思进取的契机，和悲伤难过的诱因。<strong>如果抵抗住了狂风暴雨，何还惧这微风细雨。如果能够正面交锋，何必再去投机取巧。</strong><br>　　<strong>或许本来有些自私的人，就不会有这样的问题。倒不是自私不愿分享，若眼中没有别人，心中也无别人，这个世界，就仿佛与我无关。</strong><br>　　然而，即便是阿Q，也是直接大胆说出：我要和你困觉。</p><h1 id="如果你不出去走走-你就会以为这就是世界"><a href="#如果你不出去走走-你就会以为这就是世界" class="headerlink" title="如果你不出去走走,你就会以为这就是世界"></a>如果你不出去走走,你就会以为这就是世界</h1><p>　　应该没有人这一辈都处于高潮，人生看起来都是浮浮沉沉。<strong>人生就像爬山，如果你在山脚下，你就完全不用担心会摔下去；一旦往上爬了一小段，总是会有担心摔下山崖，又得从头开始；往上爬得越高，可能越会担心摔得越痛。</strong>所以当爬到一段路程之后，发现这一段路，有很多和自己一样的人，大家言笑晏晏，也并不需要继续往上爬，带着这里也挺好。<br><img alt data-src="/../images/DS/06bierencaishi/climbing.jpg" class="lazyload"><br>　　《倩女幽魂3：道道道》里面有那么一段老和尚和树妖斗法时的对话：<br>　　——树妖：“因果报应？你真的相信善有善报，恶有恶报吗？”<br>　　——白云：“正是，此乃天理循环。”<br>　　——树妖：“天理？你知道恶人死了之后可以风光大葬，还有人为他著书歌颂呢！”<br>　　——白云：“不过他们会被打下地狱，受尽痛苦，得到恶报。”<br>　　——树妖：“地狱比人间更黑暗，恶人下去后一样，只要有实力，恶人也有好报。我去过那里，所以我知道。”<br>　　……<br>　　有些地方，你没有去过，你或许不会知道它的真相。这是一个取舍的问题，常言道，有得必有失。走出去，见识下不同的风景，虽然这并不一定是好事，就看你怎么看了。<br>　　“地狱比人间更黑暗。”说不定正是因为这样，才会找到一个歇脚处，不再前行。<br>　　正如薛定谔的猫，你不打开盒子，你就不知道猫是否还活着。<strong>有些事，你不做，就永远不会知道做了会怎样。我不出去走走，我也不会知道出去走走之后，风景是哪边更好。</strong><br>　　<strong>如果我没有比较的基准，我根本就不会有愧疚感或者自卑感。单点不成线，双点不成面。只要我与世隔绝，就没有人会对我产生影响。</strong><br>　　别骗自己了。现在，体会到了这份愧疚与自卑，甚至是羞辱，So what you gonna do？</p><p align="right">2019/10/19 15:20</p>]]></content>
      
      
      <categories>
          
          <category> 绝望系列 </category>
          
          <category> 悲惨现实 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绝望 </tag>
            
            <tag> 失意 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没什么，只是一个快30岁的老处男罢了</title>
      <link href="/2019/08/06/DesperateSeries/05meishenme/"/>
      <url>/2019/08/06/DesperateSeries/05meishenme/</url>
      
        <content type="html"><![CDATA[<h1 id="小絮两句"><a href="#小絮两句" class="headerlink" title="小絮两句"></a>小絮两句</h1><p>　　<strong>斜晖轻流，层翠斑驳，漏下几束阳光，抚过她皎白的脸庞。一双明眸透出青色，半颜笑靥散出春光。</strong><br>　　我不敢直视她，唯有待她看向别处时瞥见几眼。偷偷跟着走几步，看她走远，心中依然激荡，忐忑而满足。</p><h1 id="可能没什么原因"><a href="#可能没什么原因" class="headerlink" title="可能没什么原因"></a>可能没什么原因</h1><p>　　如果我再年轻10岁，或许转头便也羞愧难当，却也是应当魂牵梦萦，茶饭不香。只不过，当这种朦胧情绪忽然恍惚了10几年，终究还是会变了模样。<br>　　<em>曾几何时，还在惋惜未曾初恋已不能早恋。暮然回首，已叹息不得深情也一贫如洗。</em><br>　　<em>曾几何时，叛逆生息也流行萝莉配大叔。 终熬到头，怡然期盼却轮回白脸小奶狗。</em><br><img alt data-src="/../images/DS/05meishenme/lslandalone.jpg" class="lazyload"><br>　　到也不是说，我们这一代看起来是没有女生看的上的一代。只是总会需要找点借口，来平复快三十年来孤独心境。<br>　　<strong>无能的人总是需要找点借口来袒护自己，但或许有时候却只是为了活得更好。</strong>阿Q活着的时候就没有什么难过的事情，死的时候依然也没有弄懂为什么就死了。快三十年了，我也没有弄懂为什么我还是一个人。<br>　　<em>当你在可以嬉笑打闹你侬我侬的时候，选择这抱手怒目，蹙眉摇头，自然是错失了一个机会。</em><br>　　<em>当别人都在计划成家立业、光宗耀祖的时候，依然还在四处奔走、天被地床，自然也错失了另一个时机。</em><br>　　<em>当终于应该打开大门，广迎四方宾客，却还是闭门不出，固执自我舒服，那轻易就失去了又一个希望。</em><br>　　<strong>或许是突然也觉得，女人吧，也就那样。可能是发现了，女人哪，也是这样。最后还是明白了，女人啊，终是那样。</strong></p><h1 id="可能没什么机会了"><a href="#可能没什么机会了" class="headerlink" title="可能没什么机会了"></a>可能没什么机会了</h1><p>　　说起来，别说是女朋友了，连女生的手都没有牵过吧。别说是牵了，都没有握过吧。到底是活该单身一辈子吗？<br>　　<strong>曾经也应该有过喜欢的女生吧？羞于表达，故作矜持，终于在错过之后，变成了怀念过去。</strong><br>　　<strong>那么也应该再有积极去争取吧？宴客馈礼，甜言蜜语，终于在顿悟之后，发现了好人文化。</strong><br>　　<strong>终于也是等待媒人牵线搭桥吧？车房具备，情专意真，终于在疲惫之后，得出了现实颓废。</strong><br>　　真的看起来是没什么机会了，现实是很残酷的，社会是很骨感的。说起来如果我还年轻些岁数，变化些颜色，可能在学校还能获得点经验。毕竟都有KTV开在了学校里，友好陪读三保一。<br><img alt="图源网络" data-src="/../images/DS/05meishenme/luxian.jpeg" class="lazyload"><br>　　突然好想出去走一走了，看看外面的世界，外面的人，新的机遇，新的美好或许就在一瞬间。却发现去哪儿都是晕车，倒头就睡，全程都晕头转向，目光散漫，并体会不到外出的乐趣，那自然不能够遇到新的人，开启新的篇章。<br>　　或许足不出户也可以，曾经的QQ爱，如今依然可以网上来，努力展示给你的都是好看的一面，生活或许还都是阳关灿烂，各自美好。只可惜隔着一张网，终究不会知道根底，相见难，怀念更难。<br>　　等着有人帮我烦恼吧，看起来隔代人终是会先操心起这样的事情来，或许这就是新的开始，且简单真实。只不过，或许没有底气说一句“你要的全带走”，<strong>人嘛，大概只能同享福，并不能同吃苦。</strong></p><h1 id="别担心，除了孤独，还有无能啊"><a href="#别担心，除了孤独，还有无能啊" class="headerlink" title="别担心，除了孤独，还有无能啊"></a>别担心，除了孤独，还有无能啊</h1><p>　　没有那么多问题，贝多芬，牛顿，伊丽莎白一世，圣母玛利亚都是没有结婚也过完一生，虽然无法达到他们的成就，但是却可以以他们为借口安抚自己。没人会因为你不如牛顿而看不起你的。<br>　　有人说情义值千金，却还有价，所以若是个有钱人，自然不会是孤独一个人。到了这个岁数还是一个老处男，只能说明从过去到现在，依然还是一个穷人罢了。<br>　　也有人说智慧胜过黄金，也是会有人仰慕那些聪明的大脑，千金难买是人才。到了这个岁数还是一个老处男，只能说明已经没有什么潜能，成为一个智慧超群的人了。<br>　　“粗缯大布裹生涯，腹有诗书气自华”。有的人可能没有财气，没有智气，但有一股傲气。到了这个岁数还是一个老处男，只能说明经受坎坷的社会洗礼，已经不是一个骄傲的人了。<br><img alt data-src="/../images/DS/05meishenme/sunman.jpg" class="lazyload"><br>　　不要担心，没有什么与众不同的，孤独一人或者并不是件坏事，这样就没有人来嘲笑我的无能了，自然也变得理所当然，没必要那么害怕了。<br>　　<strong>烈日依旧灼热，汗水浸透了抹布。抬头看看远处，似乎没有什么值得追逐的方向，也没有害怕辜负的期望。头顶一片焦阳，肩上只有一担挑。</strong></p><p align="right">2019/08/06 21:47</p>]]></content>
      
      
      <categories>
          
          <category> 绝望系列 </category>
          
          <category> 悲惨现实 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绝望 </tag>
            
            <tag> 孤独 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你终于失掉了意志力了吗？</title>
      <link href="/2019/07/21/DesperateSeries/04nizhongyu/"/>
      <url>/2019/07/21/DesperateSeries/04nizhongyu/</url>
      
        <content type="html"><![CDATA[<h1 id="当我还年轻的时候"><a href="#当我还年轻的时候" class="headerlink" title="当我还年轻的时候"></a>当我还年轻的时候</h1><p>　　如果我重返15岁，从村里面读完9年义务教育后，终于到区级中学读书的时间。那时候我也没有多大的理想，只能想着将来能够成为一名优秀的教师，教书育人，桃李天下，这倒是事实。后来才发现，教书只能传授书本上既定的传统，无论如何，进入社会之后，都会被慢慢地磨砺成圆润的样子，这也是事实。所以我想成为一名作家，一来可以继续传道，却也不用担心是从未被社会洗礼却还要跟学生讲社会道理的角色，二来总有一些话，不适合授业者，倒适于反叛者，这还是事实。<br><img alt data-src="/../images/DS/04nizhongyu/fighting2.jpg" class="lazyload"><br>　　如果我重返18岁，那是我终于到了离家更远的地方看起来是学习的时间。家长到不会再继续劝诫以学业为重，老师也不会常在身边叮咛，身边感觉是突然被清空，没有了太多束缚，堆积了太多的自由，这倒是事实。看起来从年龄上已经成年，可以有了更多自主决定的空间，可以去尝试很多以前被限制被劝阻的事物，”心之所向，素履所往”，这也是事实。稍过两年，突然就会发现，虽然有尝试过很多事物，但是毕竟人的精力也有限，总会有一个大的目标，考虑自己的前途，继续深造学习，还是毕业就业找个好的工作，也毕竟是个事实。</p><p>　　如果我重返22岁，那是我刚毕业出来工作的时间。常说“新秀看三年”，刚刚毕业工作的三年，承载了太多的希望和发展现实，是无论如何都应该重视和努力的三年，这倒是事实。如果我磨砺了这三年，或许我能够找到自己的目标，看清楚自己的市场，明确自己的方向，说不定事业就能起飞，随即身心得到充实，但是我并没能这样，这是不争的事实。如今随着时间的流逝，我竟然不知道我到底在追求着什么目标，没有特别的理想或者志向，甚至没有需要努力一下才能得到的需求，这也是不想承认的事实。</p><h1 id="差不多是条咸鱼了"><a href="#差不多是条咸鱼了" class="headerlink" title="差不多是条咸鱼了"></a>差不多是条咸鱼了</h1><p>　　看过太多这样的话：“从哪里跌倒，就在哪里睡着。”“上天为你关上一扇门，肯定会再关上一扇窗。”“你不努力一下，你都不知道什么叫做绝望。”</p><p>　　事实上，我倒是挺羡慕的。你要跌倒，至少也是走在了一条想要走的路上；关上了门，至少也知道这个门是通向何方；就算面对的是绝望，至少还有努力的动作和努力的方向。这也就说明了一个观点，即便这如果算是失败，那么也是失败在了正确的道路上。所谓正确的道路，就是还未实现的理想。</p><p>　　我已经不知道这个“理想”是个什么样的东西。如果我想睡觉，也不想着找个床，倒在地上就可以了。如果我想吃个饭，也不想着找个饭店，向天张开嘴巴，能接到什么就算什么了。如果我被人踢了一脚，也不想着去看看是谁踢的，反正踢倒了没踢倒，说不定都还会有第二脚。如果我走到了悬崖边上，也不想着回头找其他路或者找个工具飞过悬崖，继续走就好了，就算跌到崖底还不一定会死掉。<br><img alt data-src="/../images/DS/04nizhongyu/salted_fish.jpg" class="lazyload"><br>　　“仓廪实而知礼节，衣食足而知荣辱”，或许并不一定是“实”和“足”的问题，也不是“知”的问题，他的问题就是，这里根本就没有问题。</p><p>　　有一句著名的电影台词是这样的：“做人如果没梦想，跟咸鱼有什么分别。”现实就是我与咸鱼就只是有没有腌那一层盐和风干的区别。</p><p>　　<strong>生活没有激情，混吃等死，偶尔无能狂怒，转眼自暴自弃。期待着撑过今天，明天说不定就世界末日了，或者自己就突然暴毙了，灰飞烟灭，一切成空。</strong></p><h1 id="如果我也曾经有梦"><a href="#如果我也曾经有梦" class="headerlink" title="如果我也曾经有梦"></a>如果我也曾经有梦</h1><p>　　如果说人不该这么消极，应该积极生活，以良好的态度对待每一天，期待着美好的事物即将来临。Well，如此消极真是对不起了。</p><p>　　曾经我也想做个好人，服务社会，服务人民，希望自己能为这个美好的生存环境贡献一份绵薄之力。有人需要我的帮助，我能够完成某项工作，共同促进人类生活走入美好幸福的下一篇章。<br><img alt data-src="/../images/DS/04nizhongyu/dream1.jpg" class="lazyload"><br>　　对不起，我错了，有些人注定是人类进步的阶梯，而有些人只是为了平衡这个社会，证明前一种人是不可或缺的。所以我也曾简单想过，并不需要许多人，社会性质服务工作即便是不能胜任，但是伦理道德上的人类群体说不定还能count on me。有人信任，有人依靠，我想做被信任、被依靠的角色。</p><p>　　不过，当你发现你并不能承担那样的角色之后，或许就会改变那样天真的想法。毕竟，还有其他的俗话可以借鉴：“人不为己，天诛地灭。”也不说非要成为什么出类拔萃的社会栋梁，做好这个社会的个体其实也还好。<strong>只要自己活得还好，那也是算为社会做了贡献了</strong>。事实上，并没有。我挣了大钱，在亲戚朋友的财力需求时能有所援助吗？没有。我生活愉快，不需要亲戚朋友来担心我的精神状态和情绪状况了吗？没有。我家庭和睦，不需要亲戚朋友叹息劝导我的情感经历和身体状况了吗？单身寡人，当然也没有。</p><p>　　就算是作为个体，我依然即便财政自由，但是却不敢自由消费；即便手有工作，但是失意至极，仍不敢另谋他职；即便羡慕爱情，感慨人生，但是瞻前顾后，不为所动；即便身体还在，机能运作正常，却不知该走向何方，归向何处。<strong>一具行尸走肉，无为无求，肉体与精神都被掏空。</strong></p><p>　　《老子》里面有一句话，“夫唯不争，故天下莫能与之争。”一开始我觉得这句话说得没艺术。都已经强调“不争”了，但还是看重结果是“莫能与之争”。到最后还是在说最厉害的“争”就是“不争”。幸好是这样，不然若真的是不争，所有人都一样，没有比较，没有差距，无欲无求，那将是死气沉沉的一片，空气中都充满着腐坏的味道。</p><h1 id="当做白日梦都变得奢侈起来"><a href="#当做白日梦都变得奢侈起来" class="headerlink" title="当做白日梦都变得奢侈起来"></a>当做白日梦都变得奢侈起来</h1><p>　　曾经我在玩游戏的时候，尤其在体育竞技类游戏时，我就在想，如果在现实生活中，我就是这样像游戏里一样优秀的人会是怎样？创造历史，获得在现实中从来没人取得过的数据、成绩，受到万千粉丝追捧。不仅影响行业类的人员，甚至在政治、宗教、文化等各个方面，都被树立成典范。成为前无古人、后无来者、流芳百世、名垂青史的唯一人，the only one。但是事实上，像这样的自我满足仅仅只能停在拥有那一身名誉，浮华过后，还剩下什么呢？即便人们尊重了这样的伟大，却永远无法达到这样的成就，没有进步，那就是没有发展。无法达到的地步，那就是走到头的位置。人们会怀念过去，但是不应该也不会停留在过去。<br><img alt data-src="/../images/DS/04nizhongyu/despair1.jpg" class="lazyload"><br>　　曾经我在看超英影剧时，尤其在表现超能力的时候，我就在想，如果在现实生活中，我也拥有这样的超能力会是怎样？如果我能超高速飞行，就不用担心埋怨拥挤的交通影响出现。如果我能隐身，肯定会想着偷偷溜进超市，带走几罐薯片。如果我能够喷火、释放闪电，在和别人发生冲突之后，不用动手，只需要展示下能力就能够把人吓跑……的确就是如此卑微，如此低廉。我也想过如果能用来对抗邪恶，匡扶正义那就更好了，但是事实上，完全不知道怎么做，只能想想这影视剧中存在的邪恶，并与之对抗，仅仅是加大对手数量或者提到对手能力而已。然则在现实中，即便拥有这样的超能力，也并没有这样的邪恶。</p><p>　　曾经我在看到一些消极的社会新闻时，也会义愤填膺，慷慨激烈，想用无比激烈的言辞去谴责那样败坏的风气事物。我会在脑海中整理出一大片正义之言，模拟出万人集会的场景和演讲台，然后在台上演讲。“锣鼓喧天，鞭炮齐鸣，红旗招展，人山人海”。然后呢？“前事不忘，后事之师。”对于已然发生的事情，毕竟是无能为力了。谴责过后的群愤，终究会散去。也不是每个人都有自己的生活，也不是每个人都没有自己的生活，泛泛而谈之后，付诸行动的实际依然是不可控制的。昨天说着“扶清灭洋”，今天就是“哈利路亚”。</p><p>　　<strong>所以，即便是做白日梦，幻想着永远不可能发生的事情，都已经失去了动力，失去了乐趣，失去了意义，他已然变成了一件奢侈的事物。</strong></p><h1 id="我就是这样失掉了意志力了"><a href="#我就是这样失掉了意志力了" class="headerlink" title="我就是这样失掉了意志力了"></a>我就是这样失掉了意志力了</h1><p>　　当我不知道活着的目的的时候，或许就是失掉了意志力的时候，那就是现在依然的状态。</p><p>　　“一个人自觉地确定目的，并根据目的来支配、调节自己的行动，克服各种困难，从而实现目的的品质，这就是意志力。”<br><img alt data-src="/../images/DS/04nizhongyu/failure.jpg" class="lazyload"><br>　　可能有人会说，如果不知道活着的目的，那不如死了好了。别骗自己了，如果你还能死，那你至少还有一个目的是你活着的目的，即便实现可能并不会太费力，那依然还是没有失掉意志力。<strong>活着，从来都不是一个人的事情，死亡，亦然如此。</strong></p><p>　　“当我再看到他的时候，他就那样躬着背坐在那里，盘腿而坐，双臂支撑着脑袋，眼睛看着远处。<br>　　他的眼神是那么空洞，神态是那么僵硬，甚至连呼吸都变得微弱起来。我不知道他保持这样的状态有多久了，我也不知道他还会保持这样的状态是多久，看着他缓慢眨眼睛动作，已然知道他已经不在这里了。<br>　　我看着从他眼睛看着的方向，努力想去找到他眼光搜索的目标，想知道他现在到底在注视着什么，心里在想着什么。终于，我再次回过头来看着他，看着他的眼睛，在那双空洞的眼睛里，我竟然看不到任何东西，甚至看不到反射的自己。<br>　　<strong>我生怕碰着了他，想着若是我这一碰，他就可能碎了一地，慢慢化为灰烬，随风而去，再也拼不到了一起。</strong>”</p><p align="right">2019/07/21 21:18</p>]]></content>
      
      
      <categories>
          
          <category> 绝望系列 </category>
          
          <category> 悲惨现实 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绝望 </tag>
            
            <tag> 意志力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如果人生注定是个悲剧，那就”挑”一个无能为力的活法</title>
      <link href="/2019/07/17/OrdinaryArticles/02ruguoren/"/>
      <url>/2019/07/17/OrdinaryArticles/02ruguoren/</url>
      
        <content type="html"><![CDATA[<h1 id="开局不扯皮，那就毫无意义"><a href="#开局不扯皮，那就毫无意义" class="headerlink" title="开局不扯皮，那就毫无意义"></a>开局不扯皮，那就毫无意义</h1><p>　　当年张纪中制片版《天龙八部》在卫视播出时，我小学还没毕业，即便那时候人还小，但是金庸古龙的武侠小说盗版件还是买了很多来看，所以武侠题材算得上我一直以来比较喜欢的艺术作品题材。<br><img alt="小磨坊的王姑娘" data-src="/../images/OA/02ruguoren/wangguniang.jpg" class="lazyload"><br>　　不过由于年纪的关系，那一版看完之后，印象最深的人物其实只要这么几点：潇洒霸气的乔帮主，清纯漂亮的王姑娘，和憨实搞笑的岳老三。但是印象深刻的场景道更多一点：杏子林声讨乔峰、虚竹误解珍珑棋局、聚贤庄力敌众英豪、少室山认爹大会、曼陀罗山庄痴痴殉情、雁门关退辽诀别等等。即便是人物和场景都有些熟悉，甚至这么多年了片尾曲都还能跟着唱，但是并没有烙下多少深刻的印象。</p><h1 id="总得说来，悲剧就是这样产生了"><a href="#总得说来，悲剧就是这样产生了" class="headerlink" title="总得说来，悲剧就是这样产生了"></a>总得说来，悲剧就是这样产生了</h1><p>　　直到不久前，机缘巧合，我又重新看了看这部经典的金庸剧，才突然发现，原来《天龙八部》讲的是悲剧，那么多的侠骨柔情、奇人异事、风花雪月，基本上都没有逃脱这个结局。我甚至一度认为，留下印象的人物，基本上都是以悲剧收场了。</p><p>　　不过再度回味之后，即便是大流，也算不上全都是悲剧。然而悲者，极大悲也。</p><p>　　在记得上的主角人物，乔峰看起来是为了天下太平壮烈牺牲，阿紫刁蛮一身毅然殉情，游坦之英雄气短单思殒命加上替父受死的阿朱，争风吃醋面面而死的逍遥派二老等等，最悲伤的点，或许就在于人已经死了，活着的人的一切，都已然无法造成牵挂分毫。</p><p>　　虚竹大悲在于父母子相认当日，也是绝别之时，段誉大悲之日也仅仅在养父生母殉情那时，在电视剧里三大男主中，段誉算得上是很幸运的，这也是我觉得这不全是悲剧。其他与段誉相连的女子，都在母亲死的那一刻走到了最低点，最后依然有情人终成眷属。<br><img alt="少室山三兄弟初共聚" data-src="/../images/OA/02ruguoren/sanxiongdi.jpg" class="lazyload"><br>　　四大恶人角色有三者我都很喜欢，我也讨厌好色之人。叶二娘虽然刚找到儿子，但却是自愿殉情。云老四好不容易回过神来依然不忘本业结果死相最惨，段老大虽然最后一刻幡然发现自己也和别人一样，是人，却只能独自远去。岳老三是我最喜欢的角色之一，但是却是我觉得最悲情的那个。</p><h1 id="主角，其实应该是他"><a href="#主角，其实应该是他" class="headerlink" title="主角，其实应该是他"></a>主角，其实应该是他</h1><p>　　最悲惨的应当是慕容复，这个角色早期看时很讨厌，再看已是同情，如今看来，最后我也会活成自己最讨厌的样子。<br>　　<br>　　他的一生，从来都不是按照自己想过的一生，他所有重大的决定和选择从来没有往好的一面发展。从一开始五十万两白银买军资却被吞了，解珍珑棋局反被迷幻差点自杀，再到后面想到飘渺峰收买人心却遇到一个“盗号”的虚竹，后续少室山一战想笼络武林豪杰而力斗乔峰却被“开挂”的段誉羞辱又险些自刎，随后刚看到一心复国的父亲却顿悟一切皆空万事又靠自己，西夏想当驸马拿兵复国甚至不惜把一往情深的表妹逼到投井却依然没有如愿以偿，曼陀罗山庄不惜杀了家臣、再认义父、手刃舅妈为假借段家兵马复国却功亏一篑，最后众叛亲离，家破人亡，精神失常，徒劳自己皇帝梦。<br><img alt="最后的慕容复" data-src="/../images/OA/02ruguoren/murongfu.jpg" class="lazyload"><br>　　还有一直有在说的“北乔峰，南慕容”。口碑上，别人都是侠义心肠，豪情万丈，他却是“以彼之道还施彼身”。在武技上，慕容复大部分的对战，都没有取得胜利，甚至和别人一比较起来，简直不堪一击。主角三人，大哥算的上“肝帝”——师父领进门，修行在个人，实战经验实打实的充足，二哥算“盗号玩家”——逍遥派三大前辈的功力轻松获取，三弟算“开挂玩家”——凌波微步无人能近身，北冥神功想取就吸，六脉神剑无人能敌。而慕容复，谙熟天下武学，却只能泛泛而谈，也没一个算得上出类拔萃，相比别人的神功简直不堪一击，甚至还需要“最佳辅助”王姑娘出口相助，简直唏嘘。<br>　　<br>　　说实话慕容复这失败的一身，却也是成就了他人的一身。其实我都已经不能分辨到底是他一生的皇帝梦，还是祖训他人的复兴使命。<br><img alt="曾经的慕容复" data-src="/../images/OA/02ruguoren/murongfu2.jpg" class="lazyload"><br>　　少室山慕容博出现的时候，指定他儿子的，却是说的慕容复无后，自刎之后，慕容氏赫赫有名的前辈英雄断了血脉。多少人活着的时候，是为了他人活着，就连死，都没有为了自己的资格。他的一声只为了四个字，光复大燕。其实他难道不明白，联姻西夏也好，联合辽国吐蕃等过瓜分大宋趁机复兴也好，甚至假借段式家族也好，他即便成功，也只是把这个旗号立了起来，国小民少，其实也是任人鱼肉的位置，他真的只是为了当这样一个皇帝吗？<br>　　<br>　　我们现代人一般说来，算得上有两个方面是希望取得成功的：美女与金钱，也就是爱情与事业。有的人为了事业放弃爱情，也有人为了事业耽误爱情。但是对于慕容复这一生来讲，他没有这方面的考虑。他完全看不见身边有对他一往情深的王姑娘和阿碧，甚至在他疯了之后阿碧依然还在他身边。有些事，一旦错过了，那就是永远错过了。阿碧陪着他和那群小孩子演皇帝过家家的一幕，倒是真的触动了我。一个人，即便你是积极拼搏，心无旁骛，努力奋斗的一生，最后可能依然一无所有。</p><h1 id="“别辜负了你那一身蔑视天下的功夫”"><a href="#“别辜负了你那一身蔑视天下的功夫”" class="headerlink" title="“别辜负了你那一身蔑视天下的功夫”"></a>“别辜负了你那一身蔑视天下的功夫”</h1><h2 id="如果你佛法高深"><a href="#如果你佛法高深" class="headerlink" title="如果你佛法高深"></a>如果你佛法高深</h2><p>　　除了慕容复，还有几个再看时让我印象深刻的角色。</p><p>　　少林扫地僧，这是这部电视剧的一个BUG的存在，佛法无边，武艺高深。在少林寺呆了40多年，到“出面”之时居然无人知晓。看起来像是无争，修身。但是呢，一个人的修行，最后还是只能自己一个人。佛法普度众生，玄奘都要取西经，而他却只是呆在藏经阁扫地，30年来，眼睁睁看着两个人走火入魔误入歧途，却不及时出手相助，却让人怀疑这份无争的修行到底有没有到位。<br><img alt="扫地僧" data-src="/../images/OA/02ruguoren/saodiseng.jpg" class="lazyload"><br>　　事实上，已经40多年的佛法修行，如果已经超凡入圣，乔峰父子和慕容复父子打到藏经阁也是完全不必出手，任起发展。但听到一句为天下人的话就出面干预，倒也不是无争了，因为就是不干预，为了天下苍生的想法乔峰也在，联手灭宋的做法也不会实现。</p><p>　　所以，扫地僧的出现，不是为了炫耀自己这一身无敌的“杀人技俩”与“佛法调养”的武功，将是毫无意义。无争却还是出手尘世事，广度却销匿藏经阁，只能是修行40多年，还是没有悟到。所以说，哪有什么超凡入圣，到头来还不过是一个人而已。</p><h2 id="仁至义尽又如何"><a href="#仁至义尽又如何" class="headerlink" title="仁至义尽又如何"></a>仁至义尽又如何</h2><p>　　南海鳄神岳老三，算得上电视剧里搞笑担当了，电视剧中有他出现的场景一般我都是看得很高兴。他言出必行，一诺千金，有情有义，伶牙俐齿。他一直想当四大恶人的老二，因为他知道自己不是当大哥的料子，他也认可大哥的实力，说错话之后看看大哥怂成一团。不过很多时候四大恶人都在，却只见他一人滔滔不绝时，其他人却话不多说。他想当别人师父却当了别人徒弟，即便千万个不舒服，但是没有做任何一件违背道义的事情。他甚至还为自己师父高超的功夫而沾沾自喜，被师父没有叫出一声爷爷而高兴，还为师父的寻短见的“师娘”开导劝诫，最后为了救这个师父违背从未违背过的大哥的话而断送了性命。<br><img alt="岳老三和他的“临终遗言”" data-src="/../images/OA/02ruguoren/yuelaosan.jpg" class="lazyload"><br>　　事实上，他的这个师父，却基本没有为他做过任何事情，多数情况下都是利用岳老三对这个师父的道义观念为他做事情。岳老三从来只是口头说着要怎样怎样，但是这些违反道义的事情，从来只是说，没有做，即便他的名号是四大恶人，即便做了对别人基本上都算得上毫无影响，但是他还是没有做。<br>　　“肯做我师娘的人多着呢，还怕少了。你看，这是我小师娘，大师娘，全都是我师娘。”说出这么骄傲的话，却从不是说的自己，直到死了，还是没有等到师父那句“下次我真的教你几手功夫”成真。</p><h2 id="没有如果能掌握自己的命运"><a href="#没有如果能掌握自己的命运" class="headerlink" title="没有如果能掌握自己的命运"></a>没有如果能掌握自己的命运</h2><p>　　如果直接说金二和花妹，可能印象不深，但是如果是说起第11集太湖边小磨坊，王姑娘受到段誉惊吓衣服掉地上，双手护身娇滴滴的画面，倒是饶有兴致。但是对于金二和花妹两人，郎情妾意，大雨滂沱，山间林中，湖边磨坊，四下无人，私借云雨，不料不属之客打断了美事。做个好人，留客避雨换衣，结果惨死西夏武士手下，死前还不清不楚，不明不白。然而死前金二还在自证清白，花妹奋力反抗。即便一向是老好人的段誉看见那场景，都只是赶紧跑上楼对王姑娘说句没办法，而不是对正在行凶的人喝一声住手。<br><img alt="金二和花妹" data-src="/../images/OA/02ruguoren/jinerhuamei.jpg" class="lazyload"><br>　　其实按照“打断则忘记”的套路，如果段誉有喊一声“住手”，或许西夏武士看到了他，就知道了自己要干的正事，然后扭头就过来与段誉纠缠，而花妹就会去抱着金二的尸体痛哭。从旁观者的角度来看，是啊，无端招来杀身之祸，绝世高手没有挺身而出，实在是可怜。</p><p>　　如果当段誉和王姑娘私闯民宅，金二和花妹看到了，把他们赶走，也就没有后面的事情了。如果慕容复胸襟广阔，也不会把西夏武士带到小磨坊了。如果王姑娘没有出口相助吴长老打败云中鹤，说不定西夏武士就不会放悲酥清风吓得段誉带王姑娘逃走了。如果乔峰没有被丐帮群众逼走，凭他的本身，根本不会有西夏人开口说话的机会，因为音响都是他自带的。……</p><p>　　这就是平凡的小人物，说不定平平淡淡与世无争的过着小日子，突然就飞来横祸了。好不容易遇到的高手，却全都不是来接好运的。或许人生的悲剧可能可以被别人一句话就中止，但是他们总会有更多自己的事情要做。</p><p>　　安安乐乐才是福，平平淡淡才是真？你以为你能？做自己的主人，把命运掌握在自己的手中？你准备继续骗谁？卑微，弱小，无能为力。不配拥有名字的小人物，也不配活下去。</p><h1 id="理所当然，总结点现代社会毒鸡汤"><a href="#理所当然，总结点现代社会毒鸡汤" class="headerlink" title="理所当然，总结点现代社会毒鸡汤"></a>理所当然，总结点现代社会毒鸡汤</h1><p>　　其实还有很多人可以说的，包括那我一直想说的阿碧，但是却也不用再说了。“戏说不是胡说,改编不是乱编。”电视剧毕竟没有照搬原著拍摄，其中可能有些省略，甚至与我写的内容都会有点差异，我猜大体意思没错，都还好说。<br>　　此外如果不再提起，或许你也不曾注意片尾曲《宽恕》由林夕作词，赵季平作曲，王菲演唱。最近这首歌一直在我脑中萦绕，挥之不去，张口就来，闭眼就唱，完全情难自禁。“你给我保护，我还你祝福；你英雄好汉，需要抱负。可你欠我幸福，拿什么来弥补，难道爱比恨更难宽恕。”<br><img alt="初见阿紫的游坦之" data-src="/../images/OA/02ruguoren/youtanzhi.jpg" class="lazyload"><br>　　但是，我还是忍不住说几句“心灵鸡汤”陶冶一下情操。</p><ol><li>舔狗没有好下场（如果你还记得他的名字叫游坦之的话）。</li><li>高富帅的一生从来就是风调雨顺，多姿多彩（可曾还记得段公子受了多大委屈）。</li><li>我已经那么努力了，为什么不能成全我（志存高远、励精图治、殚心竭虑到头来几乎一无所有的慕容复啊）。</li><li>世间没有两全法、既负如来又负卿。</li><li>没有用的，你无论如何还是打不过盗号的和开挂的。</li><li>爱的确比恨更难宽恕。<br>……</li></ol><p align="right">2019/7/17 21:29</p>]]></content>
      
      
      <categories>
          
          <category> 一般文学 </category>
          
          <category> 文读影评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每一年的这一天，亦如每一年的每一天</title>
      <link href="/2019/07/15/DesperateSeries/03meiyinian/"/>
      <url>/2019/07/15/DesperateSeries/03meiyinian/</url>
      
        <content type="html"><![CDATA[<p>　　今年的这一天，和往常一样，睁开眼想着的第一件事情就是，今天又有哪些工作等待我去完成？倒不是自以为觉得每天都要是充实的，一日之计在于晨，勃勃朝气，昂昂生机。却是每天一起来就被工作压迫着，就像一起床就欠别人几百块钱，心里总是不轻松。</p><p>　　为了贪睡那几分钟，压缩了洗漱的几分钟，也节约了吃早饭的那几分钟。匆匆路上，刷了卡，到了办公室，就开始处理起看起来毫无意义的事情。早年有一句标语：“高高兴兴上班去，平平安安回家来。”却也是没有硬气地说工作的期间，应该是高兴还是开心。</p><p>　　和一般没有梦想的咸鱼一样，上班只是机械作业，却也和现实一样，事情没做完，却也没有办法下班。所以，就如至理名言告诫一样，今日事今日毕，正常时间不够，加班完成就好了。所以，再一抬头，却差不多已到晚上10点。又是一天工作时间轻轻松松过去了，然而却懒得迈步子出去吃个晚饭。刷个下班卡，再掏出手机，看看沙雕段子，径直走回宿舍，竟变得难过起来。如果笑一笑，那必然也是会浪费一些能量，为了减缓能量的流逝，看沙雕段子已然不敢笑了，倒也不是提不起兴致。<br><img alt data-src="/../images/DS/03meiyinian/worker.jpg" class="lazyload"><br>　　回到宿舍，换下鞋子，冲个脚，也想着倒在床上休息一下。缓缓闭上眼，几乎就要睡着了。啊，难得到了一天的下班休息时间，若真真是用来睡觉了，怕也是颇有几分浪费。于是坚强地睁开双眼，打开自己的笔记本电脑准备玩几把游戏放松下。</p><p>　　我电脑开机后久久没有输入密码绝不是因为我睡着了，我那一下猛子也绝不是因为手机掉地上吓到了我，我只是单纯的放慢我的动作。只要我动作足够的慢，你就不会看到我，时间也不会流逝那么快。难得下班时间，不玩两把游戏怎么说的过去。</p><p>　　启动一个MOBA游戏的客户端，看着黑压压一寸长的好友列表，也没有一个头像亮着，不免觉得一个人玩得也是无趣，不如看会儿视频放松一下，有时候玩游戏也挺累的。最近有什么火的剧吗？哪些明星正当红呢？电视剧《亮剑》什么的应该还有很多人在追吧？谢霆锋、吴彦祖还依然是帅哥的代表吧？话说张艺谋的《英雄》应该还是中国影史票房第一吧？<br><img alt data-src="/../images/DS/03meiyinian/game_win1.jpg" class="lazyload"><br>　　突然QQ列表有闪烁，消息盒子有个1。我点进去看看，居然是老爸，他问我，今天有没有喝酒。我顿生奇怪，我为什么要喝酒，我都戒了好久了，绝对不是没有人一起喝没有意思，只是单纯的因为酒太贵了。</p><p>　　老爸却反问我：“今天你过生啊，你忘记了？”过生日吗？不是吧，也没有亲戚朋友跟我说啊，堂姐生日在我前一天，她也没有提起过啊，甚至老妈也没有说啊，既然我也不知道，那唯一的结论就是，老爸记错了，今天不是我生日。</p><p>　　如果今天是我生日，我的朋友们一定会有人记得，那他们一定是会祝福我一下。如果今天是我生日，我的亲戚一定会有人记得，血浓于水，那他们一定会祝福我一下。如果今天是我生日，我妈和我应该也会记得，受难日和出生日，怎么可能不犒劳一下，我一定也得出去吃顿好的，至少吃顿肉吧。</p><p>　　但是忍不住查了一下万年历，似乎日历上的时间却也是今天。细想一下，也对，每一年的这天都和每一年的其它天没什么区别，该做什么事还是做什么事情。我哪来的什么朋友，我哪有常联系的亲戚，我一家人的关系哪里有那么和睦。<br><img alt data-src="/../images/DS/03meiyinian/birthday1.jpg" class="lazyload"><br>　　<em>如果要记住自己生日的原因，不是为了要好好吃一顿肉，那将毫无意义。</em>吃肉不喝点小酒也缺少一些风味。一个人喝酒到也是没有什么意思，反倒像是一人独醉，借酒浇愁的忧郁画面。既然是生日，不应该是一个高兴的日子吗？若是能够请上三五好友一起去吃顿肉也是不错的。</p><p>　　掏出手机，打开通话记录，翻看百来条，终于才会明白，常联系的朋友，原来还就是外卖快递、诈骗推销、中国电信、中国联通和一些没有备注响铃未接的号码而已。转念一想，倒也开心起来，今天却也节约了一顿吃肉的饭钱。</p><p>　　如果没人提醒我，那今天就这么过去了，作为生日当天似乎太凄清了一下。已经11点了，还有一个小时才算过了生日。于是我做了一个大胆的决定：我煮了碗泡面，还加了根火腿肠。一般我是绝对不会在11点了再吃晚饭，就算是要饿死，也绝对不会的。</p><p>　　吃完泡面，洗了个澡，走到门外走廊，吹吹晚风，晒晒月光，差不多就12点了，看起来，今天下班后的休息时间，也算到了尽头。迎接我的，已然是第二天睁眼的另一天。<br><img alt data-src="/../images/DS/03meiyinian/night1.jpg" class="lazyload"><br>　　虽然因为昨天是我生日，我才吃了碗加火腿肠的泡面。但是我知道，等我有钱了，吃泡面加肠应该会是稀松平常的事情，那么这也就和任何的一天没有什么区别了，也用不着去纠结什么。要是真有什么遗憾的，怕是我登录了游戏，却还没有玩上一把，就退出了。抑或是，为了煮完面，浪费了我下班之后应有的30分钟休息时间，30分钟想睡又不能睡、醒着也不知道干什么的休息时间。</p><p>　　<strong><del>或许，哪有什么特别的一天，每一天都是同样的每一天。</del></strong></p><p align="right">2019/7/15 21:32</p>]]></content>
      
      
      <categories>
          
          <category> 绝望系列 </category>
          
          <category> 悲惨现实 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绝望 </tag>
            
            <tag> 孤独 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嫉妒随笔(九)：缓解嫉妒第一招——注意力转移/分散</title>
      <link href="/2019/07/14/EmotionTalk/envy/09distractibility-and-attention-shifting/"/>
      <url>/2019/07/14/EmotionTalk/envy/09distractibility-and-attention-shifting/</url>
      
        <content type="html"><![CDATA[<h1 id="九：注意力转移"><a href="#九：注意力转移" class="headerlink" title="九：注意力转移"></a>九：注意力转移</h1><p>　　这个方法不仅仅是面对嫉妒，面对很多问题都能够起到缓解的作用。</p><p>　　嫉妒这种情绪，一旦当时在脑海产生，严重的人就会越想越气，越想越来劲，越想心里有越烦躁，就恨不得打塌一座山，一直萦绕在脑海，挥之不去，伴随着很长一段时间，说不定直到睡着前都还想着这事儿，更惨的是可能还睡不着。所以，在这样的时候，最简单的，就是转移注意力。因为嫉妒的针对性，一但看到嫉妒的对象，产生了嫉妒，开始胡思乱想，就没有办法停下来了。所以一定要找个时机，停下来，注意力转移之后，再回过头来，或许就会暂时忘记了刚刚在烦恼什么。</p><p>　　对我来讲，是最常用的。比如我嫉妒的那个能力不行却平步青云的那个同事，就坐在我前面不远，我每天上班一抬头就会看到他，一看到他我就会去想为什么、凭什么之类的问题，所以我就不敢抬头。但是这低头不见抬头见，下班之后还在脑海想这事，实在太过分了。所以一下班，我就会去打篮球。打篮球是我比较喜欢的运动，每天下班那个点，一起打球的许多人就也比较熟悉，打着球，一起说说笑笑。做自己喜欢的事物，让那份喜悦挤兑走占据脑海中的那时嫉妒。</p><p>　　<strong>注意力转移是最简单的方法，就是一定要在嫉妒情绪一直盘踞在脑海中的间隙，使用自己对自己最喜欢的事物的投入，将其暂时挤开，释放那一部分被占据的大脑，缓解当时受嫉妒心理烦恼之苦。</strong></p><p>　　正如我一开始所说，这是对消极情绪都比较通用的一招，每个人都或多或少会有自己比较喜欢的事物，例如玩游戏，做运动，胡吃海喝，压马路逛超市，和朋友倾述。有的人是可以通过别人的同情、劝导等慢慢排掉当时的嫉妒情绪，有的就像我前面说的，是用别的情绪将已被占用的挤兑出去。</p><p>　　<strong>事实上，朋友多的人，处理这类的情绪问题，都比较快。</strong>所以我在这里才更多的是说明使用挤兑，用自己喜欢的美好的东西将它挤兑走，让我脑海暂时更多的留的是我对喜欢事物的喜爱。</p><p>　　其它大多数的时候，即便我身边有几个朋友，我也不会跟他们说我嫉妒谁。因为嫉妒这本来就不是什么好的事情，我也不想变成事儿婆，让别人看不起。所以我才会使用自己喜欢的时候。打球，打游戏，什么都好，只要能让我暂时快乐，而且当前只关注在这个快乐上。<br>　　<br>　　不过，对于长期只有一个人的人，可能就没有用。不喜欢打篮球这类人多的运动，也不想麻烦几个人来打游戏，甚至一个人打游戏都会因为嫉妒情绪盘旋而无法尽兴。对于这种情况，我就是说用第二种，注意力分散。</p><h1 id="十：注意力分散"><a href="#十：注意力分散" class="headerlink" title="十：注意力分散"></a>十：注意力分散</h1><p>　　这种话在读书时代，肯定经常被老师说。事实也证明，当我们上课神游四海，老师在讲什么，的确是没有听进去，这也是很多人玩笑说，“因为第一节数学课讲的太简单了，我没注意听，所以后来数学从来都是不及格。”</p><p>　　<strong>注意力无法集中，就没有办法轻易做好很多事情。</strong></p><p>　　那么哪样的事情会让人注意力不集中呢？读书那会儿，上数学课、英语课对我来说就觉得无聊，无聊就不是很想去听讲。考试的时候，窗外有人在跳广场舞，高音炮动次打次听着很吵闹，就感觉完全无法思考，啥题都做不出来。还有就是，放假回家，一直贪玩，快要开学上课了，发现每一课的作业都没做完，翻翻语文，写两句，又翻开数学做几道，然后又看英文……</p><p>　　对应到具体的问题，当我在受到嫉妒心理情绪侵害的时候，我当时大脑已经被占据了，只要开始想着这个嫉妒的事情，就会没完没了。那就不让它想，开启吵闹的音乐，强制自己听，就算是到“卧槽，这是什么XX玩意？”盘踞在脑海也不要听。一直走动，不要停。不管是不是要做事情，就不要停，就像要到楼下小卖部买瓶水，走到楼下了又走回去，放下钱包，又走下去再回来，拿钱包，买了水，放到门口地上，再走回寝室，把钱包放了，又再回小卖部去拿回来。<strong>Keep busy，不管是不是真的有事，就是不要闲下来，要保持手脚运动。</strong>其实这两项，可以简单的变成听着吵闹的音乐去跑步，心里想的是这唱的什么乱七八糟，想换首歌却停不下来去换，自然到下一首还是自己不喜欢的那种。（其实这挺好，在纠结抱怨歌曲的时候，还锻炼了身体。）</p><p>　　当然，这不一定有用，有的人并不喜欢运动，也不喜欢听歌，甚至还不想走到人多的地方去，就像默默一个人呆在书舍，安安静静的。一般情况都还ok，<strong>但是处于嫉妒或者其他消极情绪的时候，一定是不能保持在一个安静的状态环境</strong>，如果有手机电脑的，就打开电视节目，看那种很吵人很多，嘻嘻哈哈的那种。我常常干这样的事情，我比较喜欢情景喜剧，就开到最大声，听那种哈哈哈，听得人很烦，或者看别人推荐的综艺节目（最讨厌看综艺），没什么营养，就是听别人嘻嘻哈哈，闹腾。</p><p>　　<strong>注意力转移是用自己对喜欢事物的喜好的积极情绪挤兑走嫉妒情绪缓解当时的嫉妒之苦，而注意力分散就是使用吵闹、用次要消极情绪（轻度无对象指向的烦躁、愤怒等），转移用在嫉妒上的注意力，没法集中注意力去想，那就很难继续去想。</strong>“好吵啊，我没法我工作了。”“那我偏偏就不停下。”<br>　　<br>　　关于注意力转移/分散这个办法，在处理任何消极情绪或其他问题的时候，基本上都算逃避性办法，只能缓解一时之苦，没法消除、克服，总会再次被勾起的。</p><h1 id="总结说明"><a href="#总结说明" class="headerlink" title="总结说明"></a>总结说明</h1><p>嫉妒缓解方法一：注意力转移、分散<br>自定义性质：消极逃避型<br>作用效果：暂时性缓解，长远效果需要交给时间流逝去验证<br>作用情景：正在因为嫉妒情绪在东想西想，不能自已，十分烦躁的时间段。</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 情绪调节 </category>
          
          <category> 嫉妒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嫉妒 </tag>
            
            <tag> 缓解嫉妒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嫉妒随笔(八)：我在嫉妒什么？</title>
      <link href="/2019/07/14/EmotionTalk/envy/08the-things-I-envy-for/"/>
      <url>/2019/07/14/EmotionTalk/envy/08the-things-I-envy-for/</url>
      
        <content type="html"><![CDATA[<h1 id="八：我在嫉妒什么？"><a href="#八：我在嫉妒什么？" class="headerlink" title="八：我在嫉妒什么？"></a>八：我在嫉妒什么？</h1><p>　　在说明我用于缓解或者克服嫉妒的方法前，有必要说明一下，目前困扰我的嫉妒的情境是如何，才能够借以判断其它情况是否也同样适用。</p><p>　　简单说来的话，目前有3个（种）对象我是嫉妒的。</p><p>　　一个是和我年资和年纪都差不多的同事，同样大学毕业后进入目前的就职公司，三年过去了，他升了3级，受公司领导重用，差点就成为我的顶头上司，在这个公司前途一片光明和道路一片通畅。但是于我来看，他的能力完全没有达到这样的层度，他的工作态度和能力也和我差不了多少。随着他的步步高升，他周边的人也围得越来越多，有的人对我俩的态度几乎就成了180度的两个极端。——你看看别人，三年过去了什么样子，我过了三年只有原地踏步。<b>简单说来就是，我不认同他的能力，但别人就是飞黄腾达了。<b></b></b></p><p>　　一个是和我同时进入公司同部门，因为机缘巧合他们又一起调到其他部门，又因为机缘巧合，他又调回了原部门。但是就这么两次调度，他回去后工资在我们的基础上又涨了，事情也变得轻松了，而且公司对该部门的重视程度也正好是提高的时机。就是那种一年可能会亏几百万，但还是要什么就给什么的态度。我在没日没夜加班的时候，他可能上班都没事干就看小说睡觉度日，老板和CXO时不时会请吃饭，不时联系外部工程师合作。<b>简单说来就是，同样的人，他的运气就是那么好，事少钱多地位高，但我却没那么幸运。<b></b></b></p><p>　　最后一个就是，同样的，我们一起到了这个公司，但是他在几个月之后，觉得呆在这里没有前途，毅然辞职之后，回到籍贯城市进行创业。仅仅三年过去，已经小有成就，事业爱情都收获颇丰。但是我却因为一直的妥协和犹豫一直没有走，时间呆的越久，越来越发现自己现状的悲惨性——大学毕业后三年最该磨练提高升华的时间，没有努力。能力没有提高，再想走技能已经比不上竞争者，想走又怕再也找不到工作，不走又觉得自己过得没前途，身边的人又变得越发优秀，心情烦躁。<b>简单说来就是，自己优柔寡断，照前顾后，缺乏斗志，前途迷茫，却看到别人毅然决然，当机立断，雷厉风行，颇有成就。<b></b></b></p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 情绪调节 </category>
          
          <category> 嫉妒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嫉妒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嫉妒随笔(七)：哪样的人容易遭受嫉妒？</title>
      <link href="/2019/07/08/EmotionTalk/envy/07easily-envied/"/>
      <url>/2019/07/08/EmotionTalk/envy/07easily-envied/</url>
      
        <content type="html"><![CDATA[<h1 id="七：哪样的人容易遭受嫉妒？"><a href="#七：哪样的人容易遭受嫉妒？" class="headerlink" title="七：哪样的人容易遭受嫉妒？"></a>七：哪样的人容易遭受嫉妒？</h1><p>　　To be honest，I don’t really care！</p><p>　　说句实在的，哪样的人容易遭受嫉妒，我完全一点都不在乎。事实上，你嫉妒的那种人，就算得上是容易遭嫉妒的人。一般正常的嫉妒，就是这么一说。当然你说你嫉妒别人露出的鼻毛比较长，那我更不会关心这样的嫉妒心理。不说是变态吧，但一般人应该是不会有的。其实有没有这样的人，在一些刁钻的点上嫉妒别人。我才是肯定有的。不过我觉得这要算在异常（变态）心理学去考虑下。</p><p>　　其实被嫉妒了，对于被嫉妒的人来讲，或多或少是有点不公平。就算是让他道歉，你总不想听到的是：“<strong>对不起，因为我的优秀让您嫉妒了</strong>。我保证，我把我的优秀低调点，以便照顾好您的情绪。”所以啊，有时候想到这里，虽然有点异样的难过，但是完全不会改变我嫉妒的现实，因此大多时候，我还是把这份嫉妒藏了起来，就算是是柯南来了，也要推理下才让他知道。</p><p>　　我们不可能去鼓励被嫉妒的人想办法不要变成被嫉妒的对象，因为嫉妒的由来本来就毫无办法。这里倒是可以说一句好听的话：“如果不能改变他人，那就改变自己。”我到不是想说“世人皆醉我独醒”。被嫉妒的人可以去嫉妒其它人，那样他的关心点就不会在自己的嫉妒者这里。或者，变得更优秀，让别人都不知道其实你是比其他人更值得嫉妒的对象。</p><p>　　关于如何消除克服嫉妒，如果三言两语就能说清楚的话，我也就不要写以上那么多内容了，这部分，我后续会写一系列的尝试办法，从我身上做实践，能否有用，都分享出来，大家共勉。</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 情绪调节 </category>
          
          <category> 嫉妒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嫉妒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嫉妒随笔(六)：嫉妒的意义和作用</title>
      <link href="/2019/07/08/EmotionTalk/envy/06the-role-of-envy/"/>
      <url>/2019/07/08/EmotionTalk/envy/06the-role-of-envy/</url>
      
        <content type="html"><![CDATA[<h1 id="六：嫉妒的意义和作用"><a href="#六：嫉妒的意义和作用" class="headerlink" title="六：嫉妒的意义和作用"></a>六：嫉妒的意义和作用</h1><p>　　以上说了很多，基本上都是在想着要缓解克服嫉妒，为什么呢？就如我开篇所说：“它就想一颗肿瘤，长在我身体，无时无刻地，不知不觉地，伤的心，伤的身，我受到极大的痛苦。”就如我们耳熟能详的天主教的七宗罪，从某一种从重到轻的排序来看，“嫉妒”是仅次于“傲慢”的第二大罪。其实这样的说法也比较抽象，并没有真正说出危害来。</p><p>　　如果让我来说，凡是对我有危害的事物，通常就是简单分为了在心理和身体两方面，如果再加上对自己身边关系亲密的人来说，那就是不免危害加倍的问题了。</p><p>　　我网上看了很多这方面的总结，似乎有专业教育书籍总结如下：</p><ol><li>直接影响人的情绪和积极奋进精神</li><li>嫉妒心理容易产生偏见</li><li>嫉妒心理压抑和摧残人才</li><li>嫉妒心理影响人际关系的正常发展</li><li>嫉妒心理影响身心健康</li></ol><p>　　不在其位，不谋其政。第三点虽然我可能并不会是嫉妒者，但是千百年来的历史经验，和文学影视作品，都有这样的故事，那就是功高震主，不得善终，诸如吴起、蒙恬、韩信。不过其他的几点倒是有所感悟。</p><p>　　自从因某件事而对某些人产生了很重的嫉妒心理之后，我总是喜欢抱怨社会不公，苍天无眼，倒是很少再去想着刻苦学习，丢了这块地，我要去抢那座城，似乎对工作没有那么投入，没有开始的激情。然而却也缺少了新时代人的血性，没有“此处不留爷，自有留爷处”的觉悟，也没有毅然辞职，令图霸业的血性。倒是变得怯懦，想离开，却又怕找不到工作。想进步，却眼高手低。瞻前顾后，优柔寡断。“当断不断，反受其乱”，现在却也还是无能狂怒。</p><p>　　就像在回到任何哲学问题的时候，开局说一句“一般事物都具有两面性”总是没有错，但嫉妒心理却让我也没有再去考虑其他的方面。就如一开始的例子，不如你勤奋，不如你聪明，不如你的工作效率，不比你年资高，但是别人就是被提拔，扶摇直上，而你就是原地踏步，无人问津。可是在你没有看到的其它地方，他就是比你优秀呢？比如处理与同事、上级领导的关系，对产品推广的市场的占比……就像冯骥才的《俗世奇人之好嘴杨巴》，茶汤虽好，但是中堂并没有喝。</p><p>　　嫉妒的对象，我之前说是“拥有的好的资源比你多的人”，事实上，有些资源例如家业、形貌这生下来就注定了，没办法。但是很多时候，这类拥有好的资源多的人，往往从一些层面来讲，就是比你优秀的人。从嫉妒的“对抗性”来看，如果对于比你优秀的人都是嫉妒，试图刻意剥夺。那么身边那里还有思齐之贤，说不定到真是狐朋狗友，鸡鸣狗盗之辈了。</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 情绪调节 </category>
          
          <category> 嫉妒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嫉妒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嫉妒随笔(五)：嫉妒的特点</title>
      <link href="/2019/07/08/EmotionTalk/envy/05special-features-of-envy/"/>
      <url>/2019/07/08/EmotionTalk/envy/05special-features-of-envy/</url>
      
        <content type="html"><![CDATA[<h1 id="五：嫉妒的特点"><a href="#五：嫉妒的特点" class="headerlink" title="五：嫉妒的特点"></a>五：嫉妒的特点</h1><p>　　如果看到这里，还对嫉妒一无所知的话，其实我衷心的祝福你，因为你完全不用担心嫉妒会影响你的生活，对你的人生造成负担——因为你不会嫉妒，也就不用处理它。我也希望能够像你一样。</p><p>　　<strong>生活就是这样，岂能事事如人意，还不能无愧于心，怎一个惨字了得。</strong></p><p>　　一个人没有嫉妒心，这也算他的优点，他的特点。而对于嫉妒来讲，它也是有它自己的特点。从社会心理学之社交情绪这一部分来讲，主要的特点有如下4点：</p><ol><li>具有针对性，嫉妒总是针对具体的个体或群体；</li><li>具有持续性，嫉妒情绪一旦产生，就不容易摆脱，能持续影响个体的思想、情感和行为；</li><li>具有对抗性，嫉妒者心胸狭隘，希望别人朝坏的方向发展，如果别人成功，他们就会不满和愤恨，并可能用极端的手段来破坏他人的成功或伤害他人；</li><li>具有普遍性，嫉妒是人类普遍存在的社交情绪，人在现实生活中，或多或少会体验这种情绪。</li></ol><p>　　这算是心理学家们对嫉妒作为社会心理学概念中提炼出来的特点。对我来说，就是在说明，怀着嫉妒心理的人，他们能做出怎样的事情来。</p><p>　　枪打出头鸟，最突出的，往往就是会成为攻击的对象。读书的时候，大家最关心或者印象最深的，基本都是那些成绩最好的或者最顽皮最坏事的那几个。工作的时候，一般就是最漂亮最会说话拿钱最多的那几个。其实很多时候，最刻苦、最能干、最顽强的并不在以上之列。他们就算得上被嫉妒的目标了。</p><p>　　一般来言，嫉妒一旦产生，就很难消除了，不然我也不会如此痛心疾首。为什么呢？大概不是心理被治愈或者嫉妒的对象降到了水平之下，怕是很难好了。随着时间的流逝，如果嫉妒对象真的就像愿望的那样什么突然瓶颈，一落千丈，泯然众人，垂垂老矣，那自然就不再嫉妒了。或者像我希望的，克服了这个嫉妒，那么也许就不再嫉妒了。</p><p>　　但是，还没有达到这个水平的时候，无论出现多么恶毒的咒骂，多么刻薄的刁难，多么邪气的谣言，多么消极的交流，多么疲惫的态度，我都觉得很正常。很多的努力进取积极奋斗都会因为毅力不足而半途而废，我想这嫉妒心理倒是例外。</p><p>　　以前有句教人谦虚的话叫：“人外有人，天外有天。”所以，即便是你嫉妒的对象，他可能也有更高级的嫉妒对象，只不过你水平太次，还没有看到那个高度。同样的，可能你在同一时间并不只有一个嫉妒的对象。一边嫉妒这个有钱的，又嫉妒那个有权的，还嫉妒那个有才的。这个人你想去咒骂一下，那个人你想去坏坏名声。倒是正事没有干，专想着歪门邪道去了。说不定有的人会意识到这个问题，结果自己也腾飞了。但是不免有的人就像吸毒了，越来越有瘾，还不好戒。</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 情绪调节 </category>
          
          <category> 嫉妒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嫉妒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嫉妒随笔(四)：嫉妒与羡慕等的一些区别</title>
      <link href="/2019/07/08/EmotionTalk/envy/04some-differences/"/>
      <url>/2019/07/08/EmotionTalk/envy/04some-differences/</url>
      
        <content type="html"><![CDATA[<h1 id="四：嫉妒与羡慕等的一些区别"><a href="#四：嫉妒与羡慕等的一些区别" class="headerlink" title="四：嫉妒与羡慕等的一些区别"></a>四：嫉妒与羡慕等的一些区别</h1><p>　　虽然我已经说明了很多关于嫉妒的语言，但是肯定还是会有人对一些近义词或同义词有兴趣，例如在汉语词典的解释：</p><ol><li>嫉妒：因人胜过自己而产生的忌恨心理。</li><li>忌妒：对才能、名誉、地位或境遇等比自己好的人心怀怨恨。</li><li>妒忌：就是“忌妒”。</li><li>羡慕：因喜爱别人有某种长处、好处或优越条件等而希望自己也有。</li></ol><p>　　说句实在话，“嫉妒”和“忌妒”在平时口语的说明中，都是一个意思，就连维基百科也是这样认为，所以这一般说明中，这两者通用就好了。</p><p>　　不过在文法上或者更吹毛求疵地讲，或者硬要说个区别，还是有的。</p><p>　　从词性来讲，“忌妒（妒忌）”偏向是动词，例如：我忌妒你有名有利。“嫉妒”更偏向形容词，例如：嫉妒心理。</p><p>　　从词语的情感上来讲，“忌妒（妒忌）”是贬义词，而“嫉妒”是中性词。</p><p>　　“嫉妒”的好一面，你就可以当作是“羡慕”，坏的一面，你就可以当作是“忌妒（妒忌）”。</p><p>　　就连英文，都还是会有Envy和Jealousy的区分。当然在这里我就不会去查看什么牛津词典然后说一大堆，没有必要。当时在心理学层面，对这两个的英文单词的区别还是有的，也有可能对我们的“嫉妒”和“忌妒”的区别有更多了解。如果有兴趣的话，可以去<a href="https://www.psychologytoday.com/us/blog/joy-and-pain/201401/what-is-the-difference-between-envy-and-jealousy" target="_blank" rel="noopener">这里</a>看看。</p><p>　　以上都是屁话了，按照输入法输入“jidu”显示的第一个词语，后续就不再区分这两个词语了，都是嫉妒。事实上，如果都说到嫉妒了还是去谈论好的那一面，完全没有必要。</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 情绪调节 </category>
          
          <category> 嫉妒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嫉妒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嫉妒随笔(三)：嫉妒的层级及分类</title>
      <link href="/2019/07/08/EmotionTalk/envy/03classification-of-jealousy/"/>
      <url>/2019/07/08/EmotionTalk/envy/03classification-of-jealousy/</url>
      
        <content type="html"><![CDATA[<h1 id="三：嫉妒的层级及分类"><a href="#三：嫉妒的层级及分类" class="headerlink" title="三：嫉妒的层级及分类"></a>三：嫉妒的层级及分类</h1><p>　　正如维基百科所说：“强烈的妒忌可能会产生憎恨”。像我之前描述那样的级别，看起来已经是非常强烈的嫉妒心了。但是并不是所有人的嫉妒都会达到如此境界。或许今天看见别人得到了升职加薪的提拔而自己一无所获，内心悲伤，但是第二天就back the game，其实在这个悲伤的期间，其实也算是在嫉妒中，不过很快就走出来了。</p><p>　　此外，还并不是所有的嫉妒都是消极的，都是有害的。举个例子，譬如结婚后的两夫妻，妻子还是对其他男人一样友善，一样关心，丈夫就也可能嫉妒，就会怕，就会担心突然有天妻子会弃他而去，有严重的失落感，担忧感。说实话，有这样的担心才是一个正常的现象。试想，即便结婚了，看着身边的一个个适婚男士都好像情敌，如果还毫无感觉，恐怕是无稽之谈了。但是这样的担心，这样的嫉妒，或许就能促使这份感情往正确的方向走，譬如对妻子更好，两人感情更密切，羁绊更深。</p><p>　　当然，如果丈夫去把妻子关心的每一个适婚男士都打一顿来缓和这份嫉妒，造成了很不良的社会性质结果，我倒是很愿意把这样的问题归咎于丈夫对这份嫉妒的处理方式，而非这份嫉妒的性质本身。</p><p>　　综上所述，嫉妒应该是有分层级，也有分性质。理性或良性的嫉妒对人有益，非理性恶性的嫉妒对人有害，而这种嫉妒程度越重的，对其人本身危害就越大。</p><p>　　其实这个观念也可以用看起来专业点的话描述，例如Wikipedia中：Psychologists have recently suggested that there are two types of envy: malicious envy and benign envy—malicious envy being proposed as a sick force that ruins a person and his/her mind and causes the envious person to blindly want the “hero” to suffer; on the other hand, benign envy being proposed as a type of positive motivational force that causes the person to aspire to be as good as the “hero”—but only if benign envy is used in a right way.</p><p>　　此外，里面还提到了一种因为社交媒體和自拍文化的发扬而产生的新的嫉妒：自我嫉妒（self-envy），这对我来讲并不算问题，有兴趣可以参看<a href="https://books.google.com/books?id=AjFXDgAAQBAJ" target="_blank" rel="noopener">这里</a>。</p><p>　　其实说了这么多，如果我的内心充满的是理性良性的嫉妒心，我完全不用担心，说不定反而应该高兴。但是悲惨的现实说，我的嫉妒，是非理性恶意的嫉妒，它对我的性情，对我的生活都产生了极大的负面影响，这才是我担心的。</p><p>　　所有你要判断自己有没有严重的嫉妒心，就想想是不是都满足了这样的特点。</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 情绪调节 </category>
          
          <category> 嫉妒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嫉妒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嫉妒随笔(二)：什么是嫉妒？</title>
      <link href="/2019/07/08/EmotionTalk/envy/02what-is-envy/"/>
      <url>/2019/07/08/EmotionTalk/envy/02what-is-envy/</url>
      
        <content type="html"><![CDATA[<h1 id="二：什么是嫉妒？"><a href="#二：什么是嫉妒？" class="headerlink" title="二：什么是嫉妒？"></a>二：什么是嫉妒？</h1><p>　　所以，什么是嫉妒呢？</p><p>　　从维基百科来看：妒忌又称忌妒、嫉妒，是一种人与人关系性的体现；是人的一种情感表现。由于怨恨且察觉他人享有之利益，并欲将其占为己有，因而产生的一种情感与心理状态。一般让人感受到的是难受的滋味，强烈的妒忌可能会产生憎恨。</p><p>　　专业点从社会心理学来讲：嫉妒是与他人比较，发现自己在才能、名誉、地位或境遇等方面不如别人而产生的一种由羞愧、愤怒、怨恨等组成的复杂情绪状态。<br>　　如果让我来说，<strong>简单点讲，就是别人拥有的好的资源比你多，你对他感到不爽，甚至还希望他很快就一无所有。</strong>这些“好的资源”可以广义的说是任何好的东西，若是要直白点，就是你一直想要却就是还没有得到的东西，俗气点，比如友情、爱情、财富、名誉。</p><p>　　明白了什么是嫉妒，就一并知道了产生嫉妒的几个关键点：</p><ol><li>这是一种社会性的情绪。如果只是我自己一个人，也谈不上嫉妒了。“我嫉妒我自己长得太帅”这样的话，看起来更像是自夸自恋，想要“臭美”、“不要脸”来评价都是不错的。</li><li>这是有比较才会产生的情绪。只要不是一个人，就会有差异，只是看差异有多少。但是很多时候可能没人去关心去在意这些差异。只要不去比较这些差异的优劣，也就无从嫉妒了。</li><li>比较的结果是别人比你优秀。一般来讲，一个100米短跑10秒的运动员，不会去嫉妒一个跑完百米需要11秒的运动员，而是去嫉妒跑完百米只需要9秒的运动员。</li><li>对别人的优秀，不是正面的态度。如果对待别人的优秀，是衷心祝贺，为之高兴，以他为榜样，那也谈不上嫉妒。</li></ol><p>　　“不患寡而患不均”，只要人与人所占有资源不等价，或说大抵等价，总是会有嫉妒的产生。而事实上，在资源占比上，哪里会有人人平等的可能性。你比我高，你比我帅，你还比我有钱，你还事业蒸蒸日上，家庭幸福美满，我肯定是羡慕你，嫉妒你，不说取代你，产生“想达到你所取得的成绩”的想法总是有的。</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 情绪调节 </category>
          
          <category> 嫉妒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嫉妒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嫉妒随笔(一)：引出嫉妒</title>
      <link href="/2019/07/08/EmotionTalk/envy/01lead-to-envy/"/>
      <url>/2019/07/08/EmotionTalk/envy/01lead-to-envy/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　我应该不算是一个心理非常健康的人，毕竟我有一个非常难以克服的缺点：强烈的嫉妒心。它就像一颗肿瘤，长在我身体，无时无刻地，不知不觉地，伤我的心，伤我的身，我受到极大的痛苦。因此，为了缓解，为了安宁，为了活下去，我需要好好了解一下这个“肿瘤”，希望能够安抚它，克服它，切除它，愉快的活下去。</p><p>　　这并不打算写成一篇科普性文章，也没有心思写成专业性的论文。如果只是简单了解名词，去百度Google一下也就ok。想要深度了解，若是去知网、Citeseerx检索专业文献学习也是不错。我只想简单地明白一些概念，剖析一下原因，学习一下治愈良方，为了心情不再那么沉重痛苦，为了生活再次充满愉悦欢笑。Maybe we can help each other。</p><h1 id="一：引出嫉妒"><a href="#一：引出嫉妒" class="headerlink" title="一：引出嫉妒"></a>一：引出嫉妒</h1><p>　　什么是嫉妒？我来描述一下一个例子。</p><p>　　你和A君是同一年来到同一家公司工作，你们在同一个部门，做同一个项目。在项目的完成过程中，你付出的时间、精力、完成的内容都比A君多。在项目完成上线，收益良好，但是A君被领导提拔，升职加薪，而你就一层不变。渐渐地，A君和你做的事情不一样，接触的圈子不一样，得到的回报不一样。A君一下子节节攀升，而你还是原地踏步。那么你对A君是有一种如何的情绪呢？</p><p>　　我不知道你是什么情绪，我的感受就是：为什么是他？凭什么是他？换一个事做的比我多，或者资格比我老的人都行，为什么是他？领导是弱智吗？是脑残吗？我不说别人，至少我都比他有资格被提拔。你看看他，升级之后，工作又不积极，进度还被拖延，领导为什么还对他谈笑风生，上午去开会，下午去见客户，晚上去聚餐。我做错了什么要在我面前晃？看不起谁？看吧，保不齐陪客户生意告吹，做项目稳赔不赚，手下离心离德……</p><p>　　看到了吗，这样的情绪，这样的想法，如果你不说它是嫉妒，那么也得说绝对不是好的走向。</p><p>　　我说不定晚上睡不着觉，就在想为什么？凭什么？我说不定上班就一时半会就盯着他，然后想着，你看，他又在玩手机；你看，又去厕所了；你看，又去找人聊天，还笑那么大声。我说不定每天都很晚才能下班，要做的事情总是不能及时完成。我说不定心里一直不舒服，一直不爽，看谁都来气，谁都不想理。说不定一种怨念充满整个身躯，吃包泡面结果调料包挤到了垃圾桶，买瓶老干妈结果拧不开瓶盖，破口打骂，为什么什么都要针对我！</p><p>　　如果还没有这样的想法，恭喜你，你还ok。如果像我这样了，那你就已经长出了嫉妒的“肿瘤”，而且级别不低。</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 情绪调节 </category>
          
          <category> 嫉妒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嫉妒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假如我死了</title>
      <link href="/2019/07/01/DesperateSeries/02jiaruwo/"/>
      <url>/2019/07/01/DesperateSeries/02jiaruwo/</url>
      
        <content type="html"><![CDATA[<p>　　假如我死了，在一个吵闹的夜晚，或许在一个安静的白天，我死了。没有人知道，没有人在意。为什么会有人会在意呢？75亿8千万分之一，又有什么影响呢？世界上本来就人口膨胀，本来就那么多贫穷饥荒，本来就那么多背井离乡，少我一个又有什么关系？宗教政治矛盾不会改善，落后经济建设也不会被激发，科学技术在这一刻也没有跃进，种群斗争也并不会因此停止，所以有什么关系呢？</p><p>　　假如我死了，我的国家会从社会主义初级阶段实现共同富裕了吗？物质财富极大丰富了吗？人民精神境界极大提高了吗？每个人自由而全面发展了吗？或许很久的以后会，但是现实大概是不会的，所以又有什么影响呢？少一个人吃面包，就有多一个人可以吃面包；少一个人自私怯弱，就有多一分无私友爱的比例；少一个人迂腐妥协，就有多一份积极进取精神。少了我一个，说不定是为了进步，为了和平。</p><p>　　假如我死了，说不定家人会给我刨个坑，填点土，多么可惜。人均土地占比已经那么少了，为什么还要多空出一块地来。他们或许也会难过，他们或许也会伤心。地种了一辈子，结果变少了；人养了好多年，结果还没个回报就没了。地下种个花生，说不定也会长出一窝落花生；地下种个树苗，说不定可以长出一根房梁；地上埋堆狗屎，都能够肥沃一寸土地。说不定有些年，再来坟前看看，插根香烛。或许再些年，不能走动，杂草淹没，灌木丛生，说不定也生个蛇窝鼠窝，骇人。</p><p>　　假如我死了，说不定借的钱就不用还了，没有份子钱需要再出了，没有酒需要再喝了，没有那么多吵闹需要去忍受了。或许可能会成为一段时间的谈资，或许会成为一段时间的笑柄，然后呢？我解脱了，我不用再装着高兴了，不用再假装关心了，不用再伪装同情了，该是多么自在。或许他们身边会有一个更好的人填补，会有更好的经历分享，会有更好的羁绊牵引，这也是奉献，这也是情谊。</p><p>　　假如我死了，或许我终于得到了升华，这原本的世界不会因为我的死而变得美好，或许会带来点愤怒，但是我什么都不知道。我终于不再害怕生的煎熬，再不用理会旁人的排挤，再不用隐藏自己的邪恶，再不用担惊受怕畏手畏脚。我终于得到解脱，逃离这一切的肮脏，肮脏的一切。没有牵挂，无拘无束；没有压迫，无忧无虑；没有包袱，无欲无求。人的一生就该如此，人的存在就该如此，死亡，才是一个人最应该最正确的归宿。</p><p>　　假如我死了，不要悲伤，不要心急，或者这就是我想要的全部，我应得的一切。</p><p>　　假如我死了，没有眼泪，充满欢笑，或者这就是我留下的遗产，我保留的希望。</p><p>　　假如我死了，我终于做出了最后的决定，正确的决定。</p><p align="right">2019/7/1 21:15</p>]]></content>
      
      
      <categories>
          
          <category> 绝望系列 </category>
          
          <category> 人生感慨 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绝望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你为什么还要活着？</title>
      <link href="/2019/07/01/DesperateSeries/01niweishen/"/>
      <url>/2019/07/01/DesperateSeries/01niweishen/</url>
      
        <content type="html"><![CDATA[<p>　　活着，挺辛苦，挺难过，挺无奈的。每天庸庸碌碌，碌碌无为。吃饭就是浪费食物，说话就是污染环境，呼吸就是亵渎空气。每天都有沉重的生活压力，每天都是平庸乏味的机械重复，每天经历的都是讥讽排挤。走的路没有一块砖是你铺垫，住的屋没有一片瓦是你搭建，穿的衣没有一针是你缝制。<em>你为什么还要活着？</em></p><p>　　人生是多么的孤独空虚，人生是多么虚伪狡黠。你有多少朋友可以联系？你有多少家人长久来往？说不定偶尔来个电话，想的是多聊几句，结果无话可说；也许偶尔发了信息，不是拼单砍价，就是集赞分享。偶尔想跟家里打个电话聊个近况，却话不投机，三言两语。亲戚朋友尚不能知，还有谁更会懂你？玩个游戏都只能单刷不敢联机，发给微博都要匿名评论关闭。现实生活都是各自生活，网上隔膜更多欺骗打击。<em>你为什么还要活着？</em></p><p>　　有多久没有人邀请你出去参与活动，一起玩耍，有多久没有没人发来生日祝福信息？寒风里出门拿外卖快递，烈日下汗滴砖头变蒸汽。哪样东西能白给，哪样需求不要人民币？今天想买个空调洗衣机，明天还要车房齐，今天医院看病两千七，明天商场打折九折起。肩上到底扛的是谁的生活？地下躺的是谁的身躯？好运从来不会光临，灾祸始终不离不弃。<em>你为什么还要活着？</em></p><p>　　社会治安永远会加强，经济建设永远在提高。今天可能有吃有穿就温饱，明天可能有车有房才刚好。想买好菜要趁早，盐总得比适量少一勺。可能哪一天物质需求极大提高，却发现没有财力去享受这些美好。人们总是要追求进步，最求更高的需求，但是往往需要更多的时间、精力、财力去实现它。物质社会跑得这么快，你怎么才追的上？不过当你转头一看，有的人早就瘫坐着俯视你，还面带微笑。人们总会向往平等，但是唯有不公才是真正的平等，你无论多么努力，总是得不到，而别人就是简单弯弯腰，踮踮脚。<em>你为什么还要活着？</em></p><p>　　75亿8千万分之一，无力的抗争，卑微的呐喊，你是最底层的渺小。根本没有人关心过你，根本没有你存在的必要。科技进步有你几分付出，世界和平有你多少功劳？你甚至不敢阻止别人偷人钱包，有人插队你也只能往后稍稍。你不懂别人的信仰，也不知道别人的宗教。你不懂别人的政策，也不懂别人的需要。社会矛盾激化也不知道，世界末日说不定还拍手叫好。<em>你为什么还要活着？</em></p><p>　　不思进取，无能狂怒，勾心斗角，<em>你为什么还要活着？</em></p><p>　　无力斗争人生的曲折，无法承受生活的煎熬，不被社会认可，不被别人需要，<em>你为什么还要活着？</em></p><p>　　生而为人，<em>你为什么还要活着？</em></p><p align="right">2019/7/1 22:11</p>]]></content>
      
      
      <categories>
          
          <category> 绝望系列 </category>
          
          <category> 人生感慨 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绝望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夏雨辞</title>
      <link href="/2019/06/30/OrdinaryArticles/01xiayuci/"/>
      <url>/2019/06/30/OrdinaryArticles/01xiayuci/</url>
      
        <content type="html"><![CDATA[<br><center><b>不借兵符不求仙，黑乌连天敝空间。</b></center><center><b>冲发一怒雷电裂，滚滚西水平岳巅。</b></center><a id="more"></a><center><b>逐鹿甲器折销碎，艨艟千里赤壁焰。</b></center><center><b>太屋山顶响铜鼓，北溟深蛟出水宽。</b></center><center><b>不带春柔几分甜，无端嚎啕六月天。</b></center><center><b>落下珍珠一线系，溅起瓦楞散彩延。</b></center><center><b>檐前燕子闲久立，房上浓烟聚又翩。</b></center><center><b>一派清荷茫茫现，满地红泥点点斑。</b></center><center><b>层层波掀舞衣露，叠叠绿翡压腰弯。</b></center><center><b>待到塘鱼跃江河，声消雨歇风吹栏。</b></center><center><b>本为几时少闲累，始作一刻桑田干。</b></center><center><b>千山万壑新绿再，饱受此番苦折难。</b></center><center><b>万池碧叶亭亭立，随风扶姿托殷胭。</b></center><center><b>崦嵫斜处微光见，晚有蜻蜓度凉闲。</b></center><p align="right">文成：2011年7月<br>誊写：2019/6/30</p>]]></content>
      
      
      <categories>
          
          <category> 一般文学 </category>
          
          <category> 七言古诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
            <tag> 七言古诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦到自己喜欢的游戏</title>
      <link href="/2019/06/30/EmotionTalk/dreams/20190628/"/>
      <url>/2019/06/30/EmotionTalk/dreams/20190628/</url>
      
        <content type="html"><![CDATA[<h1 id="梦醒时间"><a href="#梦醒时间" class="headerlink" title="梦醒时间"></a>梦醒时间</h1><p>2019/09/28 02:42</p><h1 id="梦境概况："><a href="#梦境概况：" class="headerlink" title="梦境概况："></a>梦境概况：</h1><h2 id="场景简述"><a href="#场景简述" class="headerlink" title="场景简述"></a>场景简述</h2><p>　　梦在看到一个英雄联盟主播玩VN，另一个玩德莱文，玩得很菜，我不知道为什么在旁边看。玩VN的主播可能因为打得不好被说了，一直在讲：我在回忆过去了，找回曾经的手感……</p><p>　　玩着玩着就突然出现4个人玩的角色在混战的场景，当年的人当年的游戏情景。一个是玩VN，非常秀。一个是那局被VN秀的狗熊。一个叫大蛇，梦中专门强调一句，他们叫大蛇，我们叫大龙，具体指的是纳什男爵还是什么就不知道了，但纳什男爵不是玩家可操作角色。</p><p>　　我们四人想起了当年那局游戏相遇的情景，感觉是不错的朋友。我们一起走在我熟悉的现实生活中以前奶奶家到赶集到水碾的路上，一起聊着话题。比如说到：我们当年还没有玩得这么菜的人，很多人都没有上线了。为什么大蛇很久不见了，说是去江东读书了。突然又说到江东离海有多远。我梦中清晰的想象着中国地图，还说如果中国左右有100里，那么江东离海就50里，一半的距离，而且梦境中是指的距离是离地图下方的海。聊着江东就醒了。</p><h2 id="其它细节"><a href="#其它细节" class="headerlink" title="其它细节"></a>其它细节</h2><ol><li>梦中就在主播说“我在回忆了”，转场景的画面是CG似的游戏角色在战斗的画面，像游戏场景。</li><li>“很秀的VN”是我给那个主播说的定义，说是那一局他就是那个很秀的VN。那个被秀的狗熊是他玩家自己跟玩VN主播说的，他就是那个被秀的狗熊。</li><li>我玩的什么角色没有提到。</li><li>有专门提到有一个人叫大蛇，我们叫大龙，像是在区分国内国外的说法不同。</li><li>梦醒的时刻聊的是江东离海的距离，梦里的场景是家中看到大湾田的画面。</li><li>有个年份2017年，记不清是说的再次上线后4人重遇的时间，还是那个大蛇要去上学的时间。</li></ol><h1 id="自我解析："><a href="#自我解析：" class="headerlink" title="自我解析："></a>自我解析：</h1><h2 id="现实情况"><a href="#现实情况" class="headerlink" title="现实情况"></a>现实情况</h2><ol><li>英雄联盟是一款网络游戏，也是我现实中耗费时间最多、投入精力最多、花费金钱最多的游戏。在有一段时间里，以前一起玩的人都弃游了，我还是一人在玩。但是最近一段时间玩得非常少了。在有游戏对局记录历史的半年内，只有3次和队友开黑（一起玩）才玩了一下。</li><li>除了单机，网游包含手机游戏没有队友的话我一般都不会玩，但是平时都有去直播平台看主播玩，所以从实际意义上来看，虽然没有亲手去玩游戏，投入的精力和金钱少了，但是时间并不算少。</li><li>最近没有发生有触发回忆过去的伤感事件。工作上也熟悉了各方面的不如意。没有抗争，就将就着它。下班之后也没有看什么电影，都只是在玩另一款单机游戏NBA2K18，因为MC模式开了一个新角色，所以每天下班投入了不少时间去玩。</li></ol><h2 id="心理近况"><a href="#心理近况" class="headerlink" title="心理近况"></a>心理近况</h2><ol><li>最近也不算烦躁，之前在工作上的一些内心不舒服的感觉也没有那么强烈。</li><li>没有特别的事情发生。</li></ol><h2 id="梦境反应"><a href="#梦境反应" class="headerlink" title="梦境反应"></a>梦境反应</h2><ol><li>当我们不再年轻的时候，很多以前特别喜欢的事情，即便热情未消，但精力有限。这也可能是为什么是梦到看主播玩游戏，而不是自己玩游戏。<strong>所以有些看起来可能是因为年龄、生存环境、时间限制等收敛起来的兴趣爱好，甚至是梦想，虽然看起来是暂时放弃或者埋没了，但是可能在心底，一直都在一个很高的地位上，只要有契机，说不定立马就钻出来了。</strong></li><li>在那个主播在说我在回忆了，梦中的场景是跳转到游戏角色战斗的CG画面，就像是游戏CG宣传片那样的效果。很多电影都有这种表现现实，主角或某个角色，在讲述着一个故事，现在是这个讲述者的画面，随着他话语，画面转到讲述者故事发生的场景。事实上，梦中出现的三个游戏角色，除了狗熊，最近看的主播中都没有玩，三者也不是我现实中喜欢玩的角色，所以为什么会出现这三个角色也不知道。</li><li>我倒是希望在游戏中结交朋友，并在现实中成为朋友。这是我一直都有的观点，但是能触发这一个想法的，只有最近看到一篇帖子，内容是说在一款娱乐消遣的APP中认识的人在线下一起聚会了的事情。事实上，我可能缺乏各种意义上的朋友，所以算比较羡慕，这也体现在梦中看起来4人关系不错。不过其它三个都有一个角色或名字定义，但是“我”却没有任何一点，可能也像是虽然渴望，但是却没有去争取的表现。</li><li>2017年在现实中对于我来讲并不算一个有特殊意义的年份，为什么会强调“大蛇”这个角色也不清楚，但如果是现实生活中在国外且还算有点联系的到的确只有一个大学同学。我自认为关系也还行，但平时并没有什么联系。</li><li>为什么会出现“江东”这个地方也是奇怪。如果从现实来讲，“江东”的话应该是长江以东，如果说是距离右边的海的话，100里取50里，还真的可算的上最远离海距离了。不过梦中是距离到地图下方的海，但在现实中以长江为基准，中间的话还就在重庆左右，以重庆到海的距离，地图上看起来还真往下往右都差不多。这段时间高考成绩也陆续出来，也到了大家要去填志愿选自己想读和能读的大学了。（私人层面上，去这个我梦中的“江东”读书还不错哦，说不定我回老家会遇上。）谈论某地方时梦到的是自己熟悉的生长的地方，可能有两个解释，一是没有去过别的地方，想象不出来那个地方的情景，只能用自己熟悉的地方来代替。二是你想象的地方，不管名字是什么，都会是自己喜欢而且想要回去的地方。“踏遍青山人未老，风景这边独好。”</li></ol><h1 id="总结说明："><a href="#总结说明：" class="headerlink" title="总结说明："></a>总结说明：</h1><p>　　这是一个典型的梦到自己喜欢的活动的“想梦”，但是对于自己喜欢的活动，很多时候并不一定是喜欢活动内容本身，还有那些一起玩耍、一起参与的人。当一个人长时间缺乏这些经历时，或许在不经意间就会透露出想要得到或者再来一次的想法。<br>　　你以为是单纯的爱好，说放弃就能放弃。而事实上，或许从来未曾走远过。<br>　　阔别已久的重逢，微笑依然是感动。</p><p align="right">2019/6/30 0:32</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 梦之解析 </category>
          
          <category> 想梦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解梦 </tag>
            
            <tag> 梦境与现实 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦到最近发生的事情</title>
      <link href="/2019/06/23/EmotionTalk/dreams/20190619/"/>
      <url>/2019/06/23/EmotionTalk/dreams/20190619/</url>
      
        <content type="html"><![CDATA[<h1 id="梦醒时间："><a href="#梦醒时间：" class="headerlink" title="梦醒时间："></a>梦醒时间：</h1><p>　　2019/06/19 03:13</p><h1 id="梦境概况："><a href="#梦境概况：" class="headerlink" title="梦境概况："></a>梦境概况：</h1><h2 id="场景简述"><a href="#场景简述" class="headerlink" title="场景简述　　"></a>场景简述　　</h2><p>　　梦见我和老爸跟着表弟（现实中最大的那个）去他的宿舍。表弟出去了一下，我和老爸转转，遇到周围住的一个女生，感觉这个女生一见如故。</p><p>　　然后老爸在煮面，不知道怎么说到钱的事，我和他在数钱包。然后那个女生就说：“钱嘛到处都是，要的话拿就是。”然后一个特写，她小桌子上有一卷散钱，应该就几十。然后我把我钱包里的钱取了一点，大概几十留下，其他和钱包都给了老爸，然后还附和着女生说：“对，我们年轻人用不了多少钱，不吃饭就能省点钱”之类的话。</p><p>　　老爸煮着面，看我的钱包说着还不少，还有好几十（在给钱包的时候应该不止，不过梦里转个镜头就少了）。特写我在看装面的卷纸，上面还有几根断面条卡在粘圆筒的夹缝里。然后也看了看钱包，真的还有好几十。</p><p>　　然后突然听见表弟的声音，他在一个马路边上的水龙头下洗衣服，喊我们的时候正在拧衣服水。他叫我们把温水瓶装满，然后把水烧开。温水瓶接满水烧开后，再倒满水壶，看意思是剩下的水晾衣服。我爸说知道了，把一个温水瓶接满放到灶头上烧，然后就醒了。</p><h2 id="其它细节"><a href="#其它细节" class="headerlink" title="其它细节"></a>其它细节</h2><ol><li>梦中那女生放那卷散钱的桌子很小，就是平时50cm*50cm那种小桌子，钱摆在一个角。</li><li>大表弟洗衣服水龙头旁边的马路是一个斜坡，他出租屋在下面，是一排楼中间，这排楼和马路是垂直的。</li><li>那个女生没有名字，就是不是现实中人物的映射。</li></ol><h1 id="自我解析"><a href="#自我解析" class="headerlink" title="自我解析"></a>自我解析</h1><h2 id="现实情况"><a href="#现实情况" class="headerlink" title="现实情况"></a>现实情况</h2><ol><li>最近一段时间，也不算短，好几个月，老爸在考完得到驾照之后都有意愿买辆车来开开。虽然是有这个打算，但是一来不知道买哪种车，二来也是外出打工住在狭小的厂房，不知道买来车的其它用处。</li><li>6月的端午节我去爸妈那边玩，和姑爷有争论过“谈恋爱是百利而无一害”这个观点。</li><li>5月中期一个关系还不错的高中女同学跟我讲，她遇到一个一看到就很喜欢的男生，然后我有鼓励她去大胆发展。后续她也说如果他们结婚了可以让我少给点彩礼。</li><li>同事上个月不久回去参加了他朋友的结婚典礼，我们也聊了一些相关话题。我也一直有主观情感上想找个女朋友的愿望，但是总拿客观现实做借口而完全没有实际行动。</li><li>大表弟在上大学，平时周末我们有一起玩手游。不过最近一两周临近大学期末考试月，没有一起玩了。</li></ol><h2 id="心理近况"><a href="#心理近况" class="headerlink" title="心理近况"></a>心理近况</h2><ol><li>最近几天都比较烦躁，有点焦虑，可能是工作上的琐事和对生活和工作前景的担忧。</li><li>没有发生什么与平常有异常或者特殊的事情。</li></ol><h1 id="梦境反映"><a href="#梦境反映" class="headerlink" title="梦境反映"></a>梦境反映</h1><ol><li>梦见老爸可能是因为6月初的端午节我才到他那边玩了几天，也说到了买车的问题。不过仔细想想，他只是有问过路边停着或我看到的车那辆好看之类的话题。因为我对这个也不了解，所以没有提出什么建议。不过我倒是从来没有说过或表示过如果他要买车，我能给多少钱给他。虽然现实情况中他如果要买个车来开也是最多十来万的车，如果是钱的话他也拿得出来。但是他没跟我说，我也没有意识到他如果买车我也可以提供一点钱，虽然我也才工作三年，工作前景看起来也不是很好，但是几万块还是可以给的。这也正巧是梦中我在给他钱的情景。</li><li>梦中人物大多是有现实人员映射的关系，这个女生并没有，而且在梦中能感觉到我们相互有好感，比如我在和老爸说钱的问题，她指着她的桌上的钱给我说拿。现实中，可能是因为我也25岁了，平时也看到很多情侣段子，内心也有想找个女朋友的愿望，加上最近一段时间类似的事情有遇到几件，所以可能导致梦中也在想这个事，而且还是期待的两情相悦而不是一厢情愿。</li><li>梦里面对人物说的话印象深刻，这个女生说的“钱嘛到处都是，要的话拿就是。”现实大环境下，看物质的女生还是多的，但是我也喜欢那种看重两个人在一起是一起过日子而不是只看重物质生活的女生。不过也可能反映出现实我可能提供不了非常好的物质基础。我的现实情况也是如此，只有一点死工资，而且还不是很稳定的工作（主要是我自己想长久做现在这个工作的意愿不强，又对找到其它符合兴趣又待遇优渥的工作的期望很低）。</li><li>大表弟的出现，我自己想来觉得只是现实中周期性的一周一起玩几把游戏，规律性的作业突然中断了几次，就突出强调了一下。对一起玩的游戏之前可以说是很喜欢，也享受和队友一起玩，一个人玩就基本不会玩。不过最近兴趣变低了很多。</li><li>大表弟洗衣服叫我们接水的场景，梦里没什么逻辑，和那个钱转个镜头数量也变少了一样，我没办法和最近的现实生活中对应起来。</li></ol><h1 id="总结说明"><a href="#总结说明" class="headerlink" title="总结说明"></a>总结说明</h1><p>　　总的来说，这个梦的关键字是：老爸、女生、钱、表弟。老爸、钱和表弟应该是对最近经历的事情的一种反映，尤其是给钱给老爸这个动作，联系到现实情况老爸想买车一条，似乎是我忽略了生活中的一点细节。<br>　　女生这点是少有和现实对不上的角色，可能只是我内心对美好爱情的渴望体现在梦境中了。从和这个互有好感一点，反映了我现实想法，我也希望是找个能过一辈子而且感情坚实的女人，而不只是想有个女朋友的想法。<br>　　梦中反映自我需求，真实事情梦中体现。</p><p align="right">2019/6/19 21:14</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 梦之解析 </category>
          
          <category> 想梦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解梦 </tag>
            
            <tag> 梦境与现实 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦中搞砸你擅长的事</title>
      <link href="/2019/06/20/EmotionTalk/dreams/20190618/"/>
      <url>/2019/06/20/EmotionTalk/dreams/20190618/</url>
      
        <content type="html"><![CDATA[<h1 id="梦醒时间："><a href="#梦醒时间：" class="headerlink" title="梦醒时间："></a>梦醒时间：</h1><p>　　2019/06/18 06:16　　</p><h1 id="梦境概况"><a href="#梦境概况" class="headerlink" title="梦境概况:"></a>梦境概况:</h1><h2 id="场景简述"><a href="#场景简述" class="headerlink" title="场景简述"></a>场景简述</h2><p>　　做个噩梦，梦到语文老师临时上课让做题，本来要一节课做完，但是我完全不会做。一节课过去了，很多题都不会，都没做。<br>　　<br>　　因为还有一些人没有做完，老师就说第二节课继续做，没做完不能放学。好友CT第一节课就做完了，我跟他示意我不会做，让他帮忙能不能给我抄答案。但是老师在上面看着不好抄。偷偷摸摸弄了一节课，还是很多题空着。眼看要下课了，然后就潦草乱七八糟地写了字，看都看不清的字，交了题。交的时候我哭着对老师说，对不起，让你失望了。</p><p>　　交完卷之后回到位置上，CWR突然递给我半瓶好像是冰冻过的泡酒。本来她是笑着的，我喝了好大一口，然后就泪流不止，她看见了慢慢不笑了。旁边她的好友YXY还是笑着，然后和CWR交头轻轻说什么。</p><p>　　然后我被吓醒了。</p><h2 id="其它细节"><a href="#其它细节" class="headerlink" title="其它细节"></a>其它细节</h2><ol><li>我能回忆起梦中的语文测验上面有英语题和数学题。</li><li>语文老师就是实际生活的高中语文老师。</li></ol><h1 id="自我解析："><a href="#自我解析：" class="headerlink" title="自我解析："></a>自我解析：</h1><h2 id="现实情况"><a href="#现实情况" class="headerlink" title="现实情况"></a>现实情况</h2><ol><li><p>在实际的读书期间，我可能很多科目都比较不算好，但是语文一定是我最自信和最喜欢的科目，所以在实际生活中，不可能发生语文做不出来，而且还哭着对老师说让她失望的事情。</p></li><li><p>CT是实际生活中读书那段时间的一个存在的好朋友。梦中人物其实可能记不清面貌身形，但是就是可以知道名字或者现实生活中可以指代的人。这个好友CT如果是在生活中，如果是发生要协助我作弊的事情，在后果不严重的情况下，例如只是平时测验，不是重大期末考之类的，是可能会帮我的。</p></li><li><p>CWR是我高中同学，整个高中三年可以说几乎没有任何交集，没有发生任何事情。实际上，在我记忆中我们好像做了快一学期的同桌，就只说过一句话，就像两个毫无关系的人。高中一排是三个人 ，CWR坐中间，我坐面向黑板的左边，而YXY就是坐她右边的人。虽然我和YXY也很少说话，但关系还是比CWR缓和点，而CWR和YXY倒的确是好朋友。</p></li><li><p>现实生活中，在大学时我是比较喜欢喝酒的，高中时主要在农忙时，家中有喝酒。不过在做这个梦时，我已经有一段时间没有喝酒了。</p></li><li><p>最近几天内，我看了一部电影《天才枪手》，印象还不错，影片根据2014年轰动一时的亚洲考场作弊案改编，讲述了天才学霸利用高智商考场作弊牟取暴利的故事。这可能是梦境发生场景是高中语文测验且语文测验中有英语题和数学题的原因。</p></li></ol><h2 id="心理近况"><a href="#心理近况" class="headerlink" title="心理近况"></a>心理近况</h2><ol><li>最近几天都比较烦躁，有点焦虑，可能是工作上的琐事和对生活和工作前景的担忧。</li><li>没有发生什么与平常有异常或者特殊的事情。</li></ol><h1 id="梦境反映"><a href="#梦境反映" class="headerlink" title="梦境反映"></a>梦境反映</h1><ol><li>对于我一直以来都比较有自信的语文测验出现不会做题，可能反映对目前在做的熟悉的事情有一点的担忧和危机感。这倒是事实，我对我自己的工作技能还是比较不满意的，因为感觉工作上，我的位置是很容易就可以被代替的。虽然我有想过提升工作能力和技术，但是这也是最近我在担忧烦躁的问题之一，我已经在怀疑目前的工作是否是我希望做的事情，是否是我想做的事情。<strong>可能是一种居安思危的想法，也可能是反映最常用的，最熟悉的，最懂行的东西，就是会让你哭泣的，让你跌落到失败悬崖的东西。</strong>也可能是内心想要走出去，走出舒适区的念头，或者是想要学习新东西的念头。</li><li>而对老师哭着说对不起这一现象，可能反映了我对这种熟悉作业出现失败还是很在乎的。不是不以为然，轻描淡写，这和我内心希望做好事情而不是敷衍做事的愿望是一样的。但是严格来讲现实和愿望可能还是有点差距。而对一次语文测试预期会产生较差的结果，而对教授、培养的语文老师道歉，也可反映我可能对在工作中栽培我的领导之类的有种愧疚感。事实上，我个人觉得工作上目前领导给的指导并对我没有很多的帮助，相反可能他们认为是培养对我个人觉得是浪费时间，一种沟通不善观念不一样的东西，但我认为初衷是对的。不过我的确有这个观点：现在辞职离开感觉对不起他们自以为是培养的培养。</li><li>梦中我有梦到CT。读书期间我们关系很好，也经常联系，不过毕业工作后就很少联系了。如果说在高中期间真的要到找人作弊的话，他可能是第一人选。这可能反映了我对老朋友的想念，也可能是担心失去。虽说君子之交淡如水，但这可能只是我个人逃避维护人际关系的借口。我的确觉得有时候去维护人际是很费力的事情，但是现实社会没有人可以独自活下去。可能是督促我需要交朋友了。的确我一直在内心都很想广交朋友，但是都不想深交，觉得维护和夯实都很费精力。</li><li>高中和CWR没什么关系算得上我感觉比较遗憾的事情，虽然现在想来这对我原本的高中生活经历不会起到多少影响，但是从现在这个年纪的我的个人内心来讲，我还是那种希望与别人搞好关系的人。客观来讲，我算性格比较开朗，不算内向，但高中可能有点相反。最近并没有与人发生矛盾，所以这个情景有可能只是在看过电影之后，联系到了自己高中生活的情况，脑中想着改变的样子。</li><li>现在在6月份，我身在广东东莞，最近的天气比较热，这可能是CWR请我喝的酒是冰冻过的原因。大学毕业之后喝酒少了，是因为我觉得喝酒我一个人喝没有意义，要亲朋好友人多一起喝才高兴。可能在内心中，我还是觉得有点孤独，结合上一条一个真实经历的身为同桌却感觉毫无关系的人看我哭了请我喝酒，说不定是我内心对一个热闹生活的期待和对孤独内心感受的不满。</li><li>本来是笑着的CWR，看到我喝酒后哭了都没有笑了。在现实来讲，这是熟悉的人遇到这种情况的正常反应，而YXY这个角色在这个梦里感觉就是反映CWR和YXY是好朋友，是实际生活是一致的。而YXY还是笑着和CWR说话，说明在梦中我和YXY的关系就有可能像当年的现实中我和CWR的关系一样。除了对朋友的渴望，可能也预示着不是所有人都能够成为朋友，也许有那么一些人，不是自己想交个朋友，就会和别人成为朋友。</li></ol><h1 id="总结说明："><a href="#总结说明：" class="headerlink" title="总结说明："></a>总结说明：</h1><p>　　最近看的电影《天才枪手》的场景构建了梦中类似的高中测验的情景，一些细节例如语文测验中有英语题和数学题也是由此而来。<br>　　有反映出最近的心理状况，例如对工作的忧虑，和一些内心深处的想法，比如觉得有点孤独，想交深交的朋友。梦境反映了现实中的一些担忧焦虑的现状和内心渴望得到的东西，但是还没有给点想法，总体上说，是对自我的反映，不是对现实中的事物和人的折射。<br>　　自我需求，与人无关。</p><p align="right">2019/6/18 21:46</p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 梦之解析 </category>
          
          <category> 噩梦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解梦 </tag>
            
            <tag> 梦境与现实 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦的分类</title>
      <link href="/2019/06/20/EmotionTalk/dreams/categoryDescription/"/>
      <url>/2019/06/20/EmotionTalk/dreams/categoryDescription/</url>
      
        <content type="html"><![CDATA[<p>古人根据梦的内容不同，把梦分为以下十五类：</p><h5 id="直梦"><a href="#直梦" class="headerlink" title="直梦"></a>直梦</h5><p>　　即梦见什么就发生社么，梦见谁就见到谁。人的梦都是象征性的，有的含蓄，有的直露，后者就是直梦。如你与朋友后就不见，夜里梦之，白日见之，此直梦也。</p><h5 id="象梦"><a href="#象梦" class="headerlink" title="象梦"></a>象梦</h5><p>　　即梦意在梦境内容中通过象征手段表现出来。我们所梦到的一切，都是通过象征手法表现的。入梦到登天，其实人是无法登天的，在此，天是具有象征意义的。如天象征阳刚、尊贵、帝王；地象征阴柔、母亲、生育等等。</p><h5 id="因梦"><a href="#因梦" class="headerlink" title="因梦"></a>因梦</h5><p>　　由于睡眠时武官的刺激而作的梦。”阴气壮则梦涉大水，阳气壮则梦涉大火，藉带而寝则梦蛇，飞鸟衔发则梦飞”，此即因梦。</p><h5 id="想梦"><a href="#想梦" class="headerlink" title="想梦"></a>想梦</h5><p>　　想梦是意想所作之梦，是内在精神活动的产物，通常所说”日有所思，也有所梦”即想梦也。</p><h5 id="精梦"><a href="#精梦" class="headerlink" title="精梦"></a>精梦</h5><p>　　由精神状态导致的梦，是凝念注神所作的梦，使近于想梦的一种梦。</p><h5 id="性梦"><a href="#性梦" class="headerlink" title="性梦"></a>性梦</h5><p>　　是由于人的性情和好恶不同引起的梦。性梦主要不是讲做梦的原因，而是讲做梦者的对梦的态度。</p><h5 id="人梦"><a href="#人梦" class="headerlink" title="人梦"></a>人梦</h5><p>　　人梦是指同样的梦境对于不同的人有不同的意义。</p><h5 id="感梦"><a href="#感梦" class="headerlink" title="感梦"></a>感梦</h5><p>　　由于气候因素造成的梦为感梦。即由于外界气候的原因，使人有所感而作之梦。</p><h5 id="时梦"><a href="#时梦" class="headerlink" title="时梦"></a>时梦</h5><p>　　时乃四时，由于季节因素造成的梦为时梦。”春梦发生，夏梦高明，秋冬梦熟藏，此谓时梦也”</p><h5 id="反梦"><a href="#反梦" class="headerlink" title="反梦"></a>反梦</h5><p>　　反梦就是相反的梦，阴极则吉，阳极则凶，谓之反梦。在民间解梦，常有梦中所作与事实相反之说，在历代典籍中，亦多有反梦之记载，成语中亦有黄梁美梦的典故，唐·沈既济《枕中记》，说卢生在梦中享尽了荣华富贵，醒来时，蒸的黄粱米饭尚未熟，只落得一场空。可见反梦在人的梦中占有很大的比重。</p><h5 id="籍梦"><a href="#籍梦" class="headerlink" title="籍梦"></a>籍梦</h5><p>　　也就是托梦，此类梦在古代书籍中也有不少记载。人们认为神灵或祖先会通过梦来向我们预告吉凶祸福。</p><h5 id="寄梦"><a href="#寄梦" class="headerlink" title="寄梦"></a>寄梦</h5><p>　　就是甲的吉凶祸福在乙的梦中出现，乙的吉凶祸福在甲的梦中出现，或者异地感应做同样的梦。寄梦是由于人们之间的感应而形成的梦。</p><h5 id="转梦"><a href="#转梦" class="headerlink" title="转梦"></a>转梦</h5><p>　　转梦是指梦的内容多变，飘忽不定。</p><h5 id="病梦"><a href="#病梦" class="headerlink" title="病梦"></a>病梦</h5><p>　　病梦是人体病变的梦兆，从中医角度来讲，是由于人体的阴阳五行失调而造成的梦。</p><h5 id="鬼梦"><a href="#鬼梦" class="headerlink" title="鬼梦"></a>鬼梦</h5><p>　　即噩梦，梦境可怕恐怖的梦。鬼梦多是由于睡觉姿势不正确，或由于身体的某些病变而造成的梦。</p><p>梦的分类来源：<a href="https://www.nongli.com/item5/augury/qi1-12.htm" target="_blank" rel="noopener">https://www.nongli.com/item5/augury/qi1-12.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> 心理说法 </category>
          
          <category> 梦之解析 </category>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解梦 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
