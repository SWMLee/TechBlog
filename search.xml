<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>（十八）Git管理项目开发一般规范和开发使用Git常规作业流程</title>
      <link href="/2019/12/30/TechnicalEssays/AboutGit/18use-git-as-a-team/"/>
      <url>/2019/12/30/TechnicalEssays/AboutGit/18use-git-as-a-team/</url>
      
        <content type="html"><![CDATA[<h1 id="团队开发使用代码版控也是有必要的"><a href="#团队开发使用代码版控也是有必要的" class="headerlink" title="团队开发使用代码版控也是有必要的"></a>团队开发使用代码版控也是有必要的</h1><p>一个开发者想要对自己的代码进行管控，有很多的云带代码托管平台，喜闻乐见的 github、gitlab、gitee、coding(原)、华为云、阿里云代码托管等等。<br>个人使用，那么了解一点点 git 的知识即可满足需求，且也不需要什么规范，如果管理凭自己喜好即可。</p><p>但若是一个团队，需要使用代码托管工具管理自己的代码，那就不一样了。团队协助，最好不能各自按照各自的喜好，统一的作业流程能更加做好合作开发工作，缩短作业流程。</p><p>毕竟，使用这样的方式，肯定比用 U 盘把代码拷来拷去，然后复制粘贴好的多。可能需要传统行业的软件开发代码合并方式就是如此，并不需要惊讶。虽然这样做的风险和不足很明显，但是简单，不出错的话成本也低。</p><h1 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h1><p>本篇主要讲解，一个团队，想要统一使用 git 搭配 gitlab 做代码管理的一般思路规范，并不一定适用，但是可以做参考，指定符合自己团队需要的规范。</p><p>基本内容有：</p><ul><li>明确团队组织架构分层；</li><li>项目准备工作<ul><li>根据组织架构分成，做 group/subgroup 准备</li><li>项目初始化准备</li><li>小组成员开发就绪</li><li>后续步骤</li><li>Git 补充的一些说明</li></ul></li><li>开发使用 Git 常规操作<ul><li>gitlab 协作开发模式说明</li><li>日常 Git 操作</li></ul></li></ul><p>具体内容参考<a href="https://github.com/Sanotsu/git-gitlab-advanced-notes" target="_blank" rel="noopener">github 分享 PPT</a>之《17-Git管理项目开发准备和开发使用Git常规作业流程.pdf》。</p><p>到这里，这个 git/gitlab 使用系列的内容基本就说完了，不算全面，看起来也不算专业，若是能有所收获固然是极好了。倘若真的看完还是一无所获，那真是对你浪费的宝贵时间表示遗憾和难过了。</p><p>“只有用心，才能做出最好的菜。”相关内容网络资源还是很多的，多多学习，总有收获，并不一定需要在这里。</p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十七）Git进阶与测试--使用Git、Git LFS搭配gitlab管控大文件</title>
      <link href="/2019/12/29/TechnicalEssays/AboutGit/17about-git-lfs/"/>
      <url>/2019/12/29/TechnicalEssays/AboutGit/17about-git-lfs/</url>
      
        <content type="html"><![CDATA[<p>本章主要测试讲解</p><ul><li>git lfs 一些基本命令使用；</li><li>使用 Git/Git LFS 搭配 gitlab 管控大文件之测试。</li></ul><p>测试过程内容较多，每个步骤都逐一截图以便真实说明，也有列示用法。若不感兴趣，可直接查看总结部分。</p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><ul><li>1、Git 本身作为代码管控软件，是以代码为主，没有直接管控到比较大的文件。</li><li>2、目前比较流行的 git 管理大文件的方式是使用 git-lfs。</li><li>3、git-lfs 是 git 的一个插件，官网说明如下：</li></ul><p><img alt="1.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/1.png" class="lazyload"></p><ul><li>4、使用比较简单，简单两三步即可完成大文件的提交。</li><li>5、gitlab 新版本默认已经支持 lfs，在配置文件 gitlab.rb 中可见：</li></ul><p><img alt="2.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/2.png" class="lazyload"></p><h2 id="预期中可能出现的问题"><a href="#预期中可能出现的问题" class="headerlink" title="预期中可能出现的问题"></a>预期中可能出现的问题</h2><ul><li>1、因为是管理到大文件，所以在 push 到远程服务器或者从远程服务器 pull 可能会因为网络带宽、文件大小、同时操作人员过多等因素导致操作耗时较长。</li><li>2、git 记录每次 add、commit 等操作，又以大文件为主，本地的.git 文件夹可能会极速增大。</li><li>3、gitlab 服务器若是还添加定期备份，因为文件管理可能导致 gitlab server 需要较大的硬盘存储数据。</li></ul><h2 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h2><ul><li>1 安装 git lfs 插件</li><li>2 准备两份大文件，两份 txt，分别作为文件管理和代码管理。</li><li>3 在 gitlab server 新建仓库，作为文件管理远程仓库。</li><li>4 使用 git lfs 将文件上传到 gitlab server 远程仓库。</li><li>5 克隆远程仓库到本地，查看文件是否完整。</li></ul><h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><h3 id="下载安装插件"><a href="#下载安装插件" class="headerlink" title="下载安装插件"></a>下载安装插件</h3><p>在<a href="https://git-lfs.github.com/" target="_blank" rel="noopener">git lfs 官网</a>下载插件并安装。</p><h3 id="本地项目准备"><a href="#本地项目准备" class="headerlink" title="本地项目准备"></a>本地项目准备</h3><p>本地新建文件夹 gitLfsTest，并准备两个较大压缩包文件作文件管理对象。同时新建两份 test3.txt，test4.txt 作为代码管理对象。</p><p>如下图：</p><p><img alt="3.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/3.png" class="lazyload"></p><h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><p>在 gitlab server 创建一个仓库，作为远程仓库</p><p><img alt="4.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/4.png" class="lazyload"></p><h3 id="初始化文件夹为本地-git-仓库，初始化-git-lfs。"><a href="#初始化文件夹为本地-git-仓库，初始化-git-lfs。" class="headerlink" title="初始化文件夹为本地 git 仓库，初始化 git lfs。"></a>初始化文件夹为本地 git 仓库，初始化 git lfs。</h3><p>执行命令：</p><pre><code>git initgit lfs install</code></pre><p>如下图：</p><p><img alt="5.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/5.png" class="lazyload"></p><h3 id="使用-git-lfs-追踪大文件"><a href="#使用-git-lfs-追踪大文件" class="headerlink" title="使用 git lfs 追踪大文件"></a>使用 git lfs 追踪大文件</h3><p>使用 git lfs 追踪（track）大文件（*指代所有），执行之后，在文件根目录会出现.gitattributes 文件，内容即为追踪的大文件类型。<br>执行命令：</p><pre><code>git lfs track &quot;*.zip&quot;</code></pre><p>如下图</p><p><img alt="6.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/6.png" class="lazyload"></p><h3 id="确保-gitattributes-文件会被添加到追踪（tracked）"><a href="#确保-gitattributes-文件会被添加到追踪（tracked）" class="headerlink" title="确保.gitattributes 文件会被添加到追踪（tracked）"></a>确保.gitattributes 文件会被添加到追踪（tracked）</h3><p>执行命令：</p><pre><code>git add .gitattributes</code></pre><p>一般来说如果都是执行的<code>git add .</code>，那就没有必要再这样作</p><p>如下图：</p><p><img alt="7.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/7.png" class="lazyload"></p><p>到这里，git lfs 追踪管理大文件就基本完成了，后续就像是管理一般代码一样，进行 add，commit，push 等操作。</p><h3 id="将-gitLfsTest-专案-push-到远程仓库。"><a href="#将-gitLfsTest-专案-push-到远程仓库。" class="headerlink" title="将 gitLfsTest 专案 push 到远程仓库。"></a>将 gitLfsTest 专案 push 到远程仓库。</h3><p>当然，要记得先 add，commit。<br>注意：首次 add 时，我使用的是<code>add .</code>，会添加 2 个 zip 文件合计 2.26G 左右，2 个 txt 文件，总共 4 个文件，使用 time 指令记录耗时：</p><pre><code>time git add .</code></pre><p>如下图：</p><p><img alt="8.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/8.png" class="lazyload"></p><p>再 commit：</p><pre><code>time git commit -m &#39;初次提交两个大文件&#39;</code></pre><p>如下图：</p><p><img alt="9.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/9.png" class="lazyload"></p><p>后续常规，添加远程仓库地址，推送到远程仓库：</p><pre><code>git remote add origin http://192.168.28.83/david/gitlfstest.gittime git push -u origin master</code></pre><p>如下图：</p><p><img alt="10.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/10.png" class="lazyload"></p><p>远程仓库内容如下：</p><p><img alt="11.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/11.png" class="lazyload"></p><p>可见两个 zip 包后面有 LFS 标识。</p><h3 id="修改本地的-zip-包，再上传到远程仓库。"><a href="#修改本地的-zip-包，再上传到远程仓库。" class="headerlink" title="修改本地的 zip 包，再上传到远程仓库。"></a>修改本地的 zip 包，再上传到远程仓库。</h3><p>修改文件前，留意下.git 文件的大小,如下图：</p><p><img alt="12.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/12.png" class="lazyload"></p><p>修改 test2.zip 文件大小<br>修改前如下图：</p><p><img alt="13.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/13.png" class="lazyload"></p><p>修改后如下图：</p><p><img alt="14.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/14.png" class="lazyload"></p><p>同样的，add，commit，push：</p><pre><code>time git add .time git commit -m &#39;修改test2.zip文件大小&#39;time git push -u origin master</code></pre><p>如下图：</p><p><img alt="15.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/15.png" class="lazyload"></p><p>远程也是一样有新的 commit 信息</p><p>如下图：</p><p><img alt="16.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/16.png" class="lazyload"></p><p>此时，再关注下.git 文件夹的大小</p><p>如下图：</p><p><img alt="17.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/17.png" class="lazyload"></p><p>由 2.26G 上升到了 2.99G。<br>所以，看起来随着修改的次数变多，.git 文件会无休止的增大下去。<br>不过 git lfs 有相关指令避免它：</p><pre><code>git lfs prune</code></pre><p>它会删除本地旧的 fls 文件。</p><p>如下图：</p><p><img alt="18.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/18.png" class="lazyload"></p><h3 id="从远程仓库-clone-一份-gitLfsTest-项目，查看文件内容。"><a href="#从远程仓库-clone-一份-gitLfsTest-项目，查看文件内容。" class="headerlink" title="从远程仓库 clone 一份 gitLfsTest 项目，查看文件内容。"></a>从远程仓库 clone 一份 gitLfsTest 项目，查看文件内容。</h3><p>此时的项目应该是这样的：如下图：</p><p><img alt="19.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/19.png" class="lazyload"></p><p>我们从远程克隆一份下来：</p><p>查看内容，注意.git 的大小。如下图：</p><p><img alt="20.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/20.png" class="lazyload"></p><p>可见项目内容是完整的，test1.zip 和 test2.zip 都完整存在。至此使用 git 搭配插件 git lfs 管理大文件的测试就完成。</p><p>如下图：</p><p><img alt="21.png" data-src="/../images/TechnicalEssays/AboutGit/about-git-lfs/21.png" class="lazyload"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>git 配合 git lfs 和 gitlab server 管控大文件操作还算简单方便，在系统安装完插件之后，在 git 管理的项目内：</li></ol><pre><code class="sh">    # 添加对大文件的追踪(.zip后缀)    git lfs install    git lfs track &quot;*.zip&quot;    git add .gitattributes    # 常规的添加、提交、推送    git add .    git commit -m &#39;{message}&#39;    git remote add origin {origin-url}    git push -u origin master    # 删除本地旧的fls文件    git lfs prune</code></pre><ol start="2"><li>即便是针对大文件，add，commit 等在本机的 git 指令依旧不算耗时；</li><li>在将项目需要放到远程 server 管理时，主要的耗时，来源于 push 和 clone 等跨主机操作，因此可以考虑到主要耗时取决网络。</li><li>.git 中的确会保留 fls 文件操作历史，导致 size 变得很大，不过可以使用<br><code>git lfs prune</code>尽量减少大小。</li><li>更多<code>git lfs</code>指令，可參看<a href="https://github.com/git-lfs/git-lfs/tree/master/docs/man" target="_blank" rel="noopener">official man pages.</a>,或者直接終端輸入：</li></ol><pre><code class="sh">    git lfs help &lt;command&gt;    # 或    git lfs &lt;command&gt; -h</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十六）Git进阶与测试--将单一项目拆成多个小项目并保留各自的历史记录</title>
      <link href="/2019/12/28/TechnicalEssays/AboutGit/16project-split/"/>
      <url>/2019/12/28/TechnicalEssays/AboutGit/16project-split/</url>
      
        <content type="html"><![CDATA[<p>本章主要测试讲解</p><ul><li>如何将一个 git 管理的较大的项目按文件夹拆分成几个小项目，且各个小项目只保留自己文件夹中的文件的历史记录。</li><li>两种方式实现<ul><li>使用<code>git filter-branch</code>的实现</li><li>使用<code>git subtree</code>的实现(推荐)</li></ul></li></ul><p>本篇内容，不建议跳过，如果有这个需求，还请仔细详细查看，谢谢。</p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><p>与项目合并相反，这是需要把单一项目的.git 的提交记录，抽取出各自子项目想要的部分。不过，相对于合并，拆分要简单些。</p><p>就不考虑把一个单独的文件拆成一个项目了。如果实在需要，就把这个单个文件，也放到一个文件夹中，再拆这个文件夹即可。</p><p>本地 git 仓库使用的是相对路径，所以直接修改 root folder 不会影响 git 历史记录</p><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>不将上一篇合并好的 timetools 再拆开。直接使用之前从 github 上克隆的 dayjs 项目作业。</p><p>在作业前，dayjs 的结构是这样的：</p><p><img alt="1.png" data-src="/../images/TechnicalEssays/AboutGit/project-split/1.png" class="lazyload"></p><p>查看一下，此时所有的日志 log 修改的文件名。如下图（这里是可以看到所有文件修改内容和提交数量）：</p><p><img alt="2.png" data-src="/../images/TechnicalEssays/AboutGit/project-split/2.png" class="lazyload"></p><p>dayjs 项目中，dayjs/src/有两个文件夹，locale/和 plugin/，示例假装 locale/需要拆出来，做一个单独的项目。</p><h2 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h2><ul><li><p>1 使用<code>git filter-branch</code></p><ul><li>重写提交历史记录</li><li>清除.git 的 object 文件夹(如果觉得有必要的话)</li><li>查看日志信息</li></ul></li><li><p>2 使用<code>git subtree</code></p><ul><li>进入 dayjs，创建一个临时分支</li><li>创建一个新的 git 空项目</li><li>将原仓库的临时分支 my-locale 拉到新仓库</li></ul></li></ul><h2 id="使用git-filter-branch实现–不推荐-仅作了解-不感兴趣可略过"><a href="#使用git-filter-branch实现–不推荐-仅作了解-不感兴趣可略过" class="headerlink" title="使用git filter-branch实现–不推荐,仅作了解,不感兴趣可略过"></a>使用<code>git filter-branch</code>实现–不推荐,仅作了解,不感兴趣可略过</h2><h3 id="重写提交历史记录"><a href="#重写提交历史记录" class="headerlink" title="重写提交历史记录"></a>重写提交历史记录</h3><pre><code>$ git filter-branch --tag-name-filter cat --prune-empty --subdirectory-filter src/locale -- --all</code></pre><p>命令说明：</p><p><code>git filter-branch</code>通过重写分支来重写 Git 修订历史记录，并在每个修订版上应用自定义过滤器。</p><ul><li>–tag-name-filter &lt;command&gt; 该参数控制我们要如何处理旧的 tag，cat 即表示原样输出；</li><li>–prune-empty 删除空的（对子目录没有影响的）提交；</li><li>–subdirectory-filter &lt;directory&gt; 指定子目录路径；</li><li>– –all <code>-- all</code>参数必须跟在 – 后面，表示对所有分支进行操作。如果你只想保存当前分支，也可以不添加此参数。</li></ul><p>此操作会花点时间，执行完成，可以看到，原版的 dayjs 下的文件，变成了这样：</p><p><img alt="执行后" data-src="/../images/TechnicalEssays/AboutGit/project-split/3.png" class="lazyload"></p><h3 id="清除-git-的-object-文件夹-如果觉得有必要的话"><a href="#清除-git-的-object-文件夹-如果觉得有必要的话" class="headerlink" title="清除.git 的 object 文件夹(如果觉得有必要的话)"></a>清除.git 的 object 文件夹(如果觉得有必要的话)</h3><pre><code>git reset --hardgit for-each-ref --format=&quot;%(refname)&quot; refs/original/ |xargs -n 1 git update-ref -dgit reflog expire --expire=now --allgit gc --aggressive --prune=now</code></pre><p>git for-each-ref 根据给定的集合对它们进行排序之后，迭代所有匹配的 ref &lt;pattern&gt;并根据给定的显示它们。</p><ul><li>–format=&lt;format&gt; %(fieldname)从所显示的 ref 及其指向的对象插入的字符串。</li></ul><p>git-update-ref-安全地更新存储在 ref 中的对象名称</p><ul><li>带-d 标志，它在验证命名的&lt;ref&gt;仍然包含&lt;oldvalue&gt;后将其删除</li></ul><p>git reflog expire 修剪较旧的引用日志条目。</p><ul><li>–expire=&lt;time&gt; 修剪早于指定时间的条目。</li><li>–all 处理所有引用的引用日志。</li></ul><p>git-gc 清理不必要的文件并优化本地存储库</p><ul><li>–aggressive 此选项将导致 git gc 更积极地优化存储库，但花费更多时间。</li><li>–prune=&lt;date&gt; 修剪比日期更旧的松散对象（默认为 2 周前)</li></ul><p>清除的执行如下图：</p><p><img alt="清除object" data-src="/../images/TechnicalEssays/AboutGit/project-split/4.png" class="lazyload"></p><h3 id="查看日志信息"><a href="#查看日志信息" class="headerlink" title="查看日志信息"></a>查看日志信息</h3><p>其实最重要就只有第一步而已，完成之后，现在可以查看到现在的 dayjs 的日志<br>如下图：</p><p><img alt="执行后的日志" data-src="/../images/TechnicalEssays/AboutGit/project-split/5.png" class="lazyload"></p><p>现在只有原来在 dayjs/src/locale 里面的文件被修改的提交记录被保留，其它的都丢掉了。</p><p>只要把这个现在的 dayjs 修改成 locale，就完成了大项目拆分成子项目的操作。</p><h2 id="使用git-subtree实现–推荐做法"><a href="#使用git-subtree实现–推荐做法" class="headerlink" title="使用git subtree实现–推荐做法"></a>使用<code>git subtree</code>实现–推荐做法</h2><p>同样，使用最开始的从 github 中拉下来的 dayjs 做源项目。</p><h3 id="进入-dayjs，创建一个临时分支"><a href="#进入-dayjs，创建一个临时分支" class="headerlink" title="进入 dayjs，创建一个临时分支"></a>进入 dayjs，创建一个临时分支</h3><pre><code>git subtree split -P src/locale -b my-locale</code></pre><p>命令说明：</p><p><code>git subtree</code> 合并子树并将存储库拆分为子树。<br>这个命令不在原本的 git 参考文件上，不过用法比较简单，可以在<a href="https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt" target="_blank" rel="noopener">这里</a>查看的更多用法。</p><ul><li>split<br>从&lt;prefix&gt;子树的历史中提取一个新的合成项目历史。新的历史记录仅包括影响&lt;prefix&gt;的提交（包括合并），并且这些提交中的每个现在都在项目的根目录而不是子目录中具有&lt;prefix&gt;的内容。因此，新创建的历史记录适合作为单独的 git 存储库导出。</li><li>-P &lt;prefix&gt; = –prefix=&lt;prefix&gt; 在存储库中指定的子树的路径</li><li>-b &lt;branch&gt; 创建一个分支</li></ul><p>如下图</p><p><img alt="创建临时分支" data-src="/../images/TechnicalEssays/AboutGit/project-split/6.png" class="lazyload"></p><h3 id="创建一个新的-git-空项目"><a href="#创建一个新的-git-空项目" class="headerlink" title="创建一个新的 git 空项目"></a>创建一个新的 git 空项目</h3><p>在与 dayjs 平级的路径下，创建一个文件夹，例如 my-locale(和上一步创建的分支名没任何关系)，并进入，然后 git 初始化</p><pre><code>cd ..mkdir my-localecd my-localegit init</code></pre><p>如下图：</p><p><img alt="新建空git项目" data-src="/../images/TechnicalEssays/AboutGit/project-split/7.png" class="lazyload"></p><h3 id="将原仓库的临时分支-my-locale-拉到新仓库"><a href="#将原仓库的临时分支-my-locale-拉到新仓库" class="headerlink" title="将原仓库的临时分支 my-locale 拉到新仓库"></a>将原仓库的临时分支 my-locale 拉到新仓库</h3><pre><code>git pull ../dayjs my-locale</code></pre><p>如下图</p><p><img alt="空项目完成临时分支的拉取" data-src="/../images/TechnicalEssays/AboutGit/project-split/8.png" class="lazyload"></p><p>查看日志，效果一致，如下图：</p><p><img alt="一样的日志" data-src="/../images/TechnicalEssays/AboutGit/project-split/9.png" class="lazyload"></p><p>对于一开始说的，单个文件，想要这样做，似乎不行。如下图。</p><p><img alt="单个文件拆成项目" data-src="/../images/TechnicalEssays/AboutGit/project-split/10.png" class="lazyload"></p><p>还是放到文件夹吧。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用<code>git filter-branch</code>拆分子项目，是会把除了需要被拆分的部分，全部都删除了，包括.git 仓库里的东西。这是在原本的项目上进行作业。</li><li>使用<code>git subtree</code>是在原项目中创建了临时分支，再拉取到新的 git 空项目，不会对原项目进行异动，原项目甚至不会知道子项目的存在。</li><li>如果提交的次数较多，为了筛选所有的历史记录，都会比较耗时间。但不修改原项目的<code>git subtree</code>，显然更好。</li><li>git subtree 创建子项目命令小计</li></ul><pre><code>        cd &lt;source-project&gt;        git subtree split -P &lt;prefix&gt;  -b &lt;temp-branch&gt;        cd ..        mkdir &lt;sub-project&gt;        cd &lt;sub-project&gt;        git init        git pull &lt;source-project path&gt; &lt;temp-branch&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十五）Git进阶与测试--合并两个项目为一个并保留合并前所有历史记录</title>
      <link href="/2019/12/27/TechnicalEssays/AboutGit/15combine-projects/"/>
      <url>/2019/12/27/TechnicalEssays/AboutGit/15combine-projects/</url>
      
        <content type="html"><![CDATA[<p>本章主要测试讲解</p><ul><li>如何将两个 git 管理的项目合并成一个项目，并保留住各自项目中所有的历史提交记录。(后续可以自行拓展到三个、四个……的合并)</li></ul><p>本篇内容，不建议跳过，如果有这个需求，还请仔细详细查看，谢谢。</p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><p>git 管理的项目合并，还要保留之前的提交历史记录，则表明不能直接异动到原项目.git 文件夹仓库，需要通过其它方式把子项目的.git 文件夹合并到一起，才能保存住所有提交信息。</p><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><ul><li>先从 github 克隆了两个项目用于测试，一个是 dayjs，一个是 moment；</li><li>计划是把 dayjs 和 moment 合并为一个项目，名为 timetools；<ul><li>该项目包含两个文件夹，一是 dtool，对应原本的 dayjs；</li><li>二是 mtool，对应原本的 moment。</li></ul></li></ul><p>效果，合并前</p><pre><code>- dayjs                 =&gt; 独立的 dayjs 项目，有自己的.gitignore 和 .git/- moment                =&gt; 独立的 moment 项目，有自己的.gitignore 和 .git/</code></pre><p>合并后：</p><pre><code>- timetools/            =&gt; 即最开始的 dayjs，整合完后更名  - .gitignore          =&gt; 合并两个 repos 的忽略文件  - .git/               =&gt; 最终仅余一个 repo  + dtool/              =&gt; 对应 dayjs  + mtool/              =&gt; 对应 moment</code></pre><p>克隆的项目，内容如下：</p><p><img alt="1.png" data-src="/../images/TechnicalEssays/AboutGit/combine-projects/1.png" class="lazyload"></p><p>使用<code>git log --oneline | wc -l</code>获取提交数量。</p><p>粗略可见，dayjs 的提交为 1046 次，moment 提交为 3724 次。<br><strong>注意分支名，dayjs 为 dev，moment 为 develop。</strong></p><h2 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h2><ul><li>1 进入 dayjs 文件夹，将 moment 作为远程仓库添加到 dayjs 来；</li><li>2 合并添加的库 moment 到原本的 dayjs 项目；</li><li>3 创建 mtool 文件夹，把 moment 的 develop 分支合并到 mtool 文件夹；</li><li>4 完成 moment 转移提交；</li><li>5 完成 dayjs 文件的迁移；</li><li>6 完成项目合并并查看历史记录。</li></ul><h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><h3 id="进入-dayjs-文件夹，将-moment-作为远程仓库添加到-dayjs-来"><a href="#进入-dayjs-文件夹，将-moment-作为远程仓库添加到-dayjs-来" class="headerlink" title="进入 dayjs 文件夹，将 moment 作为远程仓库添加到 dayjs 来"></a>进入 dayjs 文件夹，将 moment 作为远程仓库添加到 dayjs 来</h3><p>使用命令：</p><pre><code>git remote add -f moment D:/davidsu/Desktop/GitlabTest/full/moment</code></pre><p>命令说明：<br><code>git remote add</code> 添加远程仓库路径</p><ul><li>-f 的作用是在添加后立刻 fetch。</li><li><code>D:/davidsu/Desktop/GitlabTest/full/</code>为需要被合并 moment 项目的<strong>绝对路径</strong> 。</li></ul><p>如下图：</p><p><img alt="2.png" data-src="/../images/TechnicalEssays/AboutGit/combine-projects/2.png" class="lazyload"></p><h3 id="合并添加的库-moment-到原本的-dayjs-项目"><a href="#合并添加的库-moment-到原本的-dayjs-项目" class="headerlink" title="合并添加的库 moment 到原本的 dayjs 项目"></a>合并添加的库 moment 到原本的 dayjs 项目</h3><p>使用命令（注意分支名）：</p><pre><code>git merge --strategy ours --no-commit --allow-unrelated-histories moment/develop</code></pre><p>命令说明：<br><code>git merge</code> 为合并分支</p><ul><li>–strategy ours 解析合并，在合并时，如果遇到冲突，以我的为准。（本例是在 dayjs 中合并 moment，遇到冲突以 dayjs 的为准）。结果就是：<ul><li>moment 的历史记录被合并到 dayjs 的历史记录中。</li><li>moment 的文件树被读取并和 dayjs 的文件树比对进行冲突解析。</li></ul></li><li>–no-commit 合并解析完成后中断，停留在最后的提交步骤之前。<ul><li>只要你还没 commit，那么 merge 的结果就暂时保存在缓存区中，只有完成提交步骤合并才算彻底完成（文件树被正式改变）。</li></ul></li><li>–allow-unrelated-histories 允许合并无关的历史记录。<ul><li>如果不添加此选项，可能会出现<code>fatal: refusing to merge unrelated histories</code>错误。</li></ul></li></ul><p>如下图：</p><p><img alt="3.png" data-src="/../images/TechnicalEssays/AboutGit/combine-projects/3.png" class="lazyload"></p><h3 id="创建-mtool-文件夹，把-moment-的-develop-分支合并到-mtool-文件夹"><a href="#创建-mtool-文件夹，把-moment-的-develop-分支合并到-mtool-文件夹" class="headerlink" title="创建 mtool 文件夹，把 moment 的 develop 分支合并到 mtool 文件夹"></a>创建 mtool 文件夹，把 moment 的 develop 分支合并到 mtool 文件夹</h3><p>使用命令：</p><pre><code class="sh">mkdir mtool    # 创建文件夹git read-tree --prefix=mtool/ -u moment/develop</code></pre><p>命令说明：<br><code>git read-tree</code> 给定的树信息读入索引</p><ul><li>–prefix 用于指定文件树读取后保存的路径，相对于当前路径并且一定要追加 /。</li><li>-u 是说在读取后更新 index，使得 working tree 与 index 保持同步。</li></ul><p>这个命令的意义在于，之前的<code>git merge</code>命令可能会在解决冲突的时候，把 moment 的文件树弄得比较混乱，再使用<code>read-tree</code>去修复一下。</p><p>如下图(再次提醒，=前后不要空格)：</p><p><img alt="4.png" data-src="/../images/TechnicalEssays/AboutGit/combine-projects/4.png" class="lazyload"></p><h3 id="完成-moment-转移提交"><a href="#完成-moment-转移提交" class="headerlink" title="完成 moment 转移提交"></a>完成 moment 转移提交</h3><p>上一步已经修复了文件数，执行完之后，仍然在 MERGING 状态，需要提交一次修改。</p><p>使用命令：</p><pre><code>git commit --message &#39;完成moment 的迁移，新目录为 mtool&#39;</code></pre><p>如下图（MERGING 过成已完成）：</p><p><img alt="5.png" data-src="/../images/TechnicalEssays/AboutGit/combine-projects/5.png" class="lazyload"></p><h3 id="完成-dayjs-文件的迁移"><a href="#完成-dayjs-文件的迁移" class="headerlink" title="完成 dayjs 文件的迁移"></a>完成 dayjs 文件的迁移</h3><p>以上，已把 momet 项目迁移到了 dayjs 下的 mtool 文件夹了。现在要迁移 dayjs 文件夹了。</p><p>在 dayjs 文件夹下，新建文件夹 dtool</p><pre><code>mkdir dtool</code></pre><p>再把所有原本属于 dayjs 的文件移动到新建的 dtool 去。<br>也就是除了 dtool/、mtool/、.git/、.gitignore 之外的所有。</p><p>剪切完之后，把这个原本的 dayjs 的文件夹重命名为 timetools。</p><h3 id="完成项目合并并查看历史记录"><a href="#完成项目合并并查看历史记录" class="headerlink" title="完成项目合并并查看历史记录"></a>完成项目合并并查看历史记录</h3><p>到这一步，原本的 dayjs 项目，就变成了 timetools 项目，里面的 dtool 文件夹就是 dayjs 项目。</p><p>不过还差一点，之前只是把文件放进去了，还需要合并.gitignore 文件。</p><p>在新的 timetools 文件夹下，运行：</p><pre><code>cat mtool/.gitignore &gt;&gt; .gitignore</code></pre><p>把原本 moment 项目，现在的 mtool 文件夹下的.gitignore 的内容，合并到现在 timetools 文件夹下的.gitignore 中，完成忽略文件的合并。</p><p>如下图：</p><p><img alt="6.png" data-src="/../images/TechnicalEssays/AboutGit/combine-projects/6.png" class="lazyload"></p><p>到这里，合并作业就基本完成了，最后在添加提交一次，做合并项目的记录</p><pre><code>git add --all;git commit --message &#39;迁移整合完成！&#39;</code></pre><p>如下图：</p><p><img alt="7.png" data-src="/../images/TechnicalEssays/AboutGit/combine-projects/7.png" class="lazyload"></p><p>合并前后的文件夹结构如下：</p><p><img alt="8.png" data-src="/../images/TechnicalEssays/AboutGit/combine-projects/8.png" class="lazyload"></p><p>查看合并后的项目历史记录，如下图：</p><p><img alt="9.png" data-src="/../images/TechnicalEssays/AboutGit/combine-projects/9.png" class="lazyload"></p><p>提交数：4772 = 1046 + 3724 + 2。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上，完成了两个项目合并到一个项目的示例接操作演示，后续有更多的项目想要合并，可以类似。</p><p>本示例使用步驟</p><ul><li>进入 dayjs</li><li>git remote add -f moment D:/davidsu/Desktop/GitlabTest/full/moment</li><li>git merge –strategy ours –no-commit –allow-unrelated-histories moment/develop</li><li>mkdir mtool</li><li>git read-tree –prefix=mtool/ -u moment/develop</li><li>git commit –message ‘完成 moment 的迁移，新目录为 mtool’</li><li>mkdir dtool （还在 dayjs 下面）</li><li>拷贝 dayjs 的原始项目文件（除了 .git/ 和 .gitignore 以外）至 dtool/；</li><li>拷贝完之后，可以把原本文件夹名 dayjs 改为 timetools；</li><li>把此时 mtool 下的.gitignore 文件内容，整理合并到 timetools 下的.gitignore 文件中去。</li><li>合并完之后，再全部添加提交一次，做为整合操作的记录：<ul><li>git add –all; git commit –message ‘迁移整合完成！’</li></ul></li></ul><p><strong>整理引用原作者步骤：</strong><br>目标：将 frontend 项目与 backend 项目，合并到 project 项目下的 client 文件夹与 server 文件夹。</p><blockquote><ol><li>$ [~] <code>cd frontend</code></li><li>$ [frontend] <code>git remote add -f backend /fullpath/to/backend</code></li><li>$ [frontend] <code>git merge --strategy ours --no-commit backend/master</code></li><li>$ [frontend] <code>mkdir -p server</code></li><li>$ [frontend] <code>git read-tree --prefix=server/ -u backend/master</code></li><li>$ [frontend] <code>git commit --message &#39;完成 backend 的迁移，新目录为 server&#39;</code></li><li>$ [frontend] <code>mkdir -p client</code></li><li><code># 拷贝 frontend 的原始项目文件(除了 .git/ 和 .gitignore 以外) 至 client/</code></li><li>$ [frontend] <code>cd ..; mv frontend/ project/; cd project</code></li><li>$ [project] <code>cat server/.gitignore &gt;&gt; .gitignore</code></li><li><code># 整理合并后的 .gitignore，修复其中的路径缺失并保存；修复各种项目依赖的缺失，本地测试。</code></li><li>$ [project] <code>git add --all; git commit --message &#39;迁移整合完成！&#39;</code></li></ol></blockquote><p>参考文件：<br><a href="https://segmentfault.com/a/1190000000678808" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000678808</a></p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十四）Git进阶与测试--如何把文件真正的从Git里删除</title>
      <link href="/2019/12/26/TechnicalEssays/AboutGit/14delete-file-permanently/"/>
      <url>/2019/12/26/TechnicalEssays/AboutGit/14delete-file-permanently/</url>
      
        <content type="html"><![CDATA[<p>本章主要测试讲解</p><ul><li>利用<code>git filter-branch</code>命令，彻底删除已提交文件。</li></ul><p>测试过程内容较多，每个步骤都逐一截图以便真实说明，也有列示用法。若不感兴趣，可直接查看总结部分。</p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><p>例如在开发过程中，把私用账号密码文件提交了，或者其它机密文件提交了，那么在 git 中就会保留那份文件，如果 push 到远程，那么其它人也有可能看到这份他们可能不应该看到的文件，所以，如何把这份文件从 git 中移除掉？</p><h2 id="大概流程："><a href="#大概流程：" class="headerlink" title="大概流程："></a>大概流程：</h2><ul><li>1、新建一个项目 test-filter-branch，git 初始化，并放入两个文件，初始化提交</li><li>2、模拟误操作添加了不应该提交的 password.txt 文件，并提交</li><li>3、误提交 password.txt 之后，模拟又多次提交</li><li>4、将每个提交中的 password.txt 移除，并清理垃圾回收中的相关设定</li></ul><h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><p>新建一个在 test-filter-branch 项目并初次提交</p><p><img alt="1.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/1.png" class="lazyload"></p><p>之后，在项目中创建了一个 config，里面有个 password.txt 文件。<br>假设属于私有机密文件，不应该被提交，但是又忘记在创建前加入.gitignore 文件。且已经提交了。</p><p><img alt="2.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/2.png" class="lazyload"></p><p>密码提交之后，又进行了很多次提交。</p><p><img alt="3.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/3.png" class="lazyload"></p><p>突然想起密码被提交，需要从 commit 中，把文件删除，此时 commit 记录如下</p><p><img alt="4.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/4.png" class="lazyload"></p><p>使用以下命名：</p><pre><code>git filter-branch -f --tree-filter &quot;rm -f config/password.txt&quot;</code></pre><p><img alt="5.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/5.png" class="lazyload"></p><p>此时，config/password.txt 文件是不见了</p><p><img alt="6.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/6.png" class="lazyload"></p><p>即便如此，还是可以通过 git reset 指令找回来。<br>所以，还有几个跟资源回收有关的事情需要处理一下<br>删除备份点：<code>rm .git/refs/original/refs/heads/master</code><br>设置 reflog 立即过期：<code>git reflog expire --all --expire=now</code></p><p><img alt="7.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/7.png" class="lazyload"></p><p>此时再查看 git reflog 会发现没有记录，使用 git fsck 指令就可以看到很多 Unreachable 的对象了</p><p><img alt="8.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/8.png" class="lazyload"></p><p>不过，查看日志还能看到提交秘密时的 commit id，使用 git reset 能恢复 password.txt 文件吗，试一下。</p><p>查看日志（注意，删除后 commit 日志和删除之前的，有涉及到 password.txt 的 commit id 全都变了。）</p><p><img alt="9.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/9.png" class="lazyload"></p><p>使用 git reset 之后，可以看到已然没有 config/password.txt 文件了。</p><p><img alt="10.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/10.png" class="lazyload"></p><p>注意：删除 commit 中 password.txt 文件，在本地已经完成了，如果在之前已经推送到了远程，则需要使用<code>git push -f</code>覆盖掉。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>删除文件步骤主要使用命令：</p><pre><code class="sh">git filter-branch -f --tree-filter &quot;rm -f config/password.txt&quot; # 重写分支rm .git/refs/original/refs/heads/master # 删除备份点git reflog expire --all --expire=now # 设置reflog立即过期git push -f # 同步远程</code></pre><p><strong>特别说明</strong>：  重写的历史将具有所有对象的不同对象名称，并且不会与原始分支会聚。您将无法在原始分支的顶部轻松推送和分发重写的分支。如果您不知道完整的含义，请不要使用此命令，并且无论如何都要避免使用它。</p><p><img alt="11.png" data-src="/../images/TechnicalEssays/AboutGit/delete-file-permanently/11.png" class="lazyload"></p><p>此外 git 官网<a href="https://git-scm.com/docs/git-filter-branch#_warning" target="_blank" rel="noopener">git-filter-branch WARNING</a>也不建议使用此命令：</p><p><a href="https://linux.die.net/man/1/git-filter-branch" target="_blank" rel="noopener">https://linux.die.net/man/1/git-filter-branch</a></p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十三）Git进阶与测试--多样化处理本地commit记录</title>
      <link href="/2019/12/25/TechnicalEssays/AboutGit/13handle-local-commit-message/"/>
      <url>/2019/12/25/TechnicalEssays/AboutGit/13handle-local-commit-message/</url>
      
        <content type="html"><![CDATA[<p>本章主要测试讲解</p><ul><li>利用<code>git rebase</code>命令，多样化处理本地 commit 记录。例如<ul><li>修改提交信息</li><li>删除提交信息</li><li>合并提交信息</li><li>……</li></ul></li></ul><p>测试过程内容较多，每个步骤都逐一截图以便真实说明，也有列示用法。若不感兴趣，可直接查看总结部分。</p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><p>在本地开发时，有提交很多次，但是其中提交信息，可能有些是可以合并到一起，有的可能没必要可以删除，有的需要修改 commit measssge……</p><p>这些都可以使用<code>git rebase</code>命令的相关参数指令实现。</p><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>在本地的 tensorflow 项目中添加几次提交</p><p><img alt="1.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/1.png" class="lazyload"></p><h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><h3 id="修改非最近一次的提交信息"><a href="#修改非最近一次的提交信息" class="headerlink" title="修改非最近一次的提交信息"></a>修改非最近一次的提交信息</h3><p>假如需要修改 commit id 为 699b10610 的 commit message。<br>因为这不是最近的一条 commit，所以 <code>git commit --amend</code>无法使用。</p><p>需要使用 git rebase 指令相关参数</p><p>输入<code>git rebase -i &lt;commit id&gt;</code>，进入 interactive 模式<br>其中<commit id>为此次想要调整这个节点(commit id)开始至 HEAD 中间的提交纪录。</commit></p><p><strong>因为我们要修改 commit id 为 699b10610 的 commit message，所以此处<code>git rebase -i</code> 后面的 commit id，可以是 699b10610 的前一个 4f092caa。</strong></p><p><img alt="2.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/2.png" class="lazyload"></p><p>输入指令后，会弹出文件，编辑需要调整的 commit 记录，以及指令说明，如下图</p><p><img alt="3.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/3.png" class="lazyload"></p><p><strong>注意：在 Rebase 状态看到的这个纪录是跟我们平常看的纪录是反过来的，越新的 Commit 在越下面。</strong></p><p>常用指令说明：</p><ul><li>pick: 只接使用这个 commit，不做任何调整</li><li>reword: 使用这个 commit，只调整 commit message</li><li>squash: 使用这个 commit 融入前一个 commit 中，合并两个 commit message 来表示(可以修改)</li><li>fixup: 使用这个 commit 融入前一个 commit 中，使用前一个 commit 的 message 来表示(不可修改)</li><li>drop: 直接移除这个 commit</li></ul><p>所以，我需要修改 commit id 为 699b10610 的 commit message，只需要把这份文件中第一行改为<code>reword + 修改后的message</code>再保存执行即可</p><p>修改后的文件</p><p><img alt="4.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/4.png" class="lazyload"></p><p>保存并关闭文件之后，会弹出一份新的文件，主要用于确认和修改 commit meassge，如下图</p><p><img alt="5.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/5.png" class="lazyload"></p><p>保存并退出后，可以看到<code>git rebase</code>命令执行完成</p><p><img alt="6.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/6.png" class="lazyload"></p><p>查看日志，之前 commit id 为 699b10610 的提交，已经被修改为 commit id 为 11d4ec53，内容也为修改后的内容。但是其它内容没有异动。</p><p><img alt="7.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/7.png" class="lazyload"></p><h3 id="合并多条-commit-内容"><a href="#合并多条-commit-内容" class="headerlink" title="合并多条 commit 内容"></a>合并多条 commit 内容</h3><p>同上，使用<code>git rebase -i</code> 指令即可修改</p><blockquote><ul><li>squash: 使用这个 commit 融入前一个 commit 中，合并两个 commit message 来表示(可以修改)</li><li>fixup: 使用这个 commit 融入前一个 commit 中，使用前一个 commit 的 message 来表示(不可修改)</li></ul></blockquote><p>根据上述指令说明，这可能需要执行多次。如果需要一并修改 commit message，要使用 squash，用第一条代替合并后的 commit message，使用 fixup。<br>示例：合并 commit id aa0312a 和 c78d4fe 和 026345ca，并修改 commit meassge 为：“修改 tensorflow1.txt 内容”<br>使用<code>git rebase -i</code>进入 interactive 模式</p><p><img alt="8.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/8.png" class="lazyload"></p><p>修改弹出文件第三句指令为 squash （注意，这个 commit 的 squash，需要从下往上合并，否则可能会报 error: <code>cannot &#39;squash&#39; without a previous commit</code>错误）</p><p><img alt="9.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/9.png" class="lazyload"></p><p>然后会弹出合并 commit message 的确认和修改画面</p><p><img alt="10.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/10.png" class="lazyload"></p><p>我修改如下</p><p><img alt="11.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/11.png" class="lazyload"></p><p>保存退出后可看到如下信息</p><p><img alt="12.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/12.png" class="lazyload"></p><p>此时查看日志，就发现之前的 3 条 commit，变成两条了</p><p><img alt="13.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/13.png" class="lazyload"></p><p>所以，再执行一次，即可达到最开始的需求，3 合 1</p><p><img alt="14.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/14-1.png" class="lazyload"></p><p><img alt="15.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/14-2.png" class="lazyload"></p><p>修改后</p><p><img alt="16.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/15.png" class="lazyload"></p><p>修改前</p><p><img alt="17.png" data-src="/../images/TechnicalEssays/AboutGit/handle-local-commit-message/16.png" class="lazyload"></p><h3 id="删除指定-commit-message"><a href="#删除指定-commit-message" class="headerlink" title="删除指定 commit message"></a>删除指定 commit message</h3><p>这个不再赘述，同样使用<code>git rebase -i &lt;commit id&gt;</code>进入 interactive 模式，把需要删除的信息从 pick 改为 drop，或者直接删除掉，再保存即可。</p><p>注意：<br>不想删除的信息，就不要异动；<br>rebase 的 <code>&lt;commit id&gt;</code>要在被删除提交信息之前，不然看不到；<br>如果删除的那次提交会导致冲突，根据解决冲突的效果，影响对应 commit 信息保留结果。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>其它指令不再一一说明，简单带过。例如</p><p>想要<strong>调整提交信息顺序</strong>，直接把 interactive 模式中看到的信息对应调整即可，诸如此类。</p><p>想要<strong>在已提交信息中间添加新的 commit 信息</strong>，   在新增起点的&lt;commit id&gt;的 interactive，模式改为 edit，<br> 这会中止 rebase，然后就可以使用<code>git commit --amend</code>修改当前信息，<br> 或者实际修改文件/夹，再使用<code>git add</code>和<code>git commit</code>命令去添加新的 commit 信息。<br> 直到添加完成，再使用<code>git rebase --continue</code>即可。</p><p>……</p><p><strong>不要一定要注意，慎重，因为有一些提交和后续的提交是相互依存的，删除或者变动之前的可能会导致后续的提交出现异常，导致项目出现问题。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用<code>git rebase -i &lt;commit id&gt;</code>，可以对本地的提交记录做很多变动。<br>在进入 interactive 模式后，对该文件(git-rebase-todo)做相应修改：</p><ul><li>想要删除，使用 drop；</li><li>想要修改，使用 reword；</li><li>想要合并，使用 squash 和 fixup；</li><li>想要新增，使用 edit；</li><li>想要调整顺序，调整 pick</li><li>……</li></ul><p>更多内容可以自行尝试。</p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十二）Git进阶与测试--三种实现undo(还原)操作的命令对比</title>
      <link href="/2019/12/24/TechnicalEssays/AboutGit/12git-three-undo/"/>
      <url>/2019/12/24/TechnicalEssays/AboutGit/12git-three-undo/</url>
      
        <content type="html"><![CDATA[<p>本章主要测试讲解</p><ul><li><code>git reset</code>、<code>git checkout</code>和<code>git revert</code>在撤销修改，内容还原功能中的对比。</li></ul><p>测试过程内容较多，每个步骤都逐一截图以便真实说明，也有列示用法。若不感兴趣，可直接查看总结部分。</p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><p>使用需求大概都是一致，就是在修改了代码之后，想要会到旧版本去。虽然列示的三种操作过程不一样，但都达到了那样的效果。</p><h2 id="指令原理说明"><a href="#指令原理说明" class="headerlink" title="指令原理说明"></a>指令原理说明</h2><p>简单说明区别<br>git revert：只能用于 commit-level，会新建一个 commit，在历史记录中说明还原了什么</p><p><img alt="1.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/1.png" class="lazyload"></p><p>git reset：可用于 commit-level 和 file-level，用于撤销未被提交到远程(remote)的改动，即撤销本地(local)的修改。</p><p><img alt="2.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/3.png" class="lazyload"></p><p>可以将其 git revert 视为撤销已提交更改的工具，同时 git reset HEAD 用于撤销未提交的更改。</p><p>git checkout：可用于 commit-level 和 file-level，是将 HEAD 指针移动到想要回退的版本，不会修改历史记录</p><h2 id="示例演示说明"><a href="#示例演示说明" class="headerlink" title="示例演示说明"></a>示例演示说明</h2><p>项目准备，一个有简单修改的 tensorflow 项目</p><h3 id="git-checkout-lt-commit-id-gt-示例"><a href="#git-checkout-lt-commit-id-gt-示例" class="headerlink" title="git checkout &lt;commit id&gt;示例"></a><code>git checkout &lt;commit id&gt;</code>示例</h3><p>例如，查看 tensorflow 的历史记录，HEAD 目前在 12589</p><p><img alt="3.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/4.png" class="lazyload"></p><p>使用<code>git checkout</code>到 47092caa 去。<br>再查看历史记录，HEAD 已经指向了 4f092caa 了。</p><p><img alt="4.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/5.png" class="lazyload"></p><p>项目中也把文件还原到了当时提交的情况</p><p><img alt="5.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/6.png" class="lazyload"></p><h3 id="git-revert-lt-commit-id-gt-示例"><a href="#git-revert-lt-commit-id-gt-示例" class="headerlink" title="git revert &lt;commit id&gt;示例"></a><code>git revert &lt;commit id&gt;</code>示例</h3><p>先将分支切回到 dev</p><p><img alt="6.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/7.png" class="lazyload"></p><p>使用 git revert 还原到 a122a10dcd<br>还原过程中会弹窗窗口提示输入 commit 内容</p><p><img alt="7.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/8.png" class="lazyload"></p><p>revert 完成之后，查看日志可以看到，会看到新增一条 commit</p><p><img alt="8.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/9.png" class="lazyload"></p><p>而项目中已经有还原到当时的文件</p><p><img alt="9.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/10.png" class="lazyload"></p><p>但是通常情况下，git revert 不会带 commit id，直接使用，用于撤销最近一次提交。</p><h3 id="git-reset示例"><a href="#git-reset示例" class="headerlink" title="git reset示例"></a><code>git reset</code>示例</h3><p>注意 git reset 的参数</p><p><img alt="10.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/11.png" class="lazyload"></p><p>在实际使用时，如果有确切的撤销需求，例如撤销后的提交内容都应该是不需要的，历史记录也不在保留，index 和工作区也回退到撤销的版本，那么就需要使用–hard 参数。</p><p>使用<code>git reset</code>前的日志</p><p><img alt="11.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/12.png" class="lazyload"></p><p>使用<code>git reset</code>恢复到 4f092caa</p><p><img alt="12.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/13.png" class="lazyload"></p><p>直接使用<code>git log</code>，则看到第一条已经是 4f092caa 那条提交</p><p><img alt="13.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/14.png" class="lazyload"></p><p>不过使用<code>git log --all --oneline</code>还是可以看到</p><p><img alt="14.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/15.png" class="lazyload"></p><p>但是注意，使用 <code>git log --pretty=oneline</code>是不行的</p><p><img alt="15.png" data-src="/../images/TechnicalEssays/AboutGit/git-three-undo/16.png" class="lazyload"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>表格列示三种指令的作用范围和效果：</p><table><thead><tr><th>git 命令</th><th>作用范围</th><th>常见用例</th></tr></thead><tbody><tr><td>git reset</td><td>commit-level</td><td>放弃在私有分支中的提交或丢弃未提交的更改</td></tr><tr><td>git reset</td><td>file-level</td><td>取消暂存文件</td></tr><tr><td>git checkout</td><td>commit-level</td><td>在分支之间切换或检查旧快照</td></tr><tr><td>git checkout</td><td>file-level</td><td>放弃工作目录中的更改</td></tr><tr><td>git revert</td><td>commit-level</td><td>撤消在公共分支中提交</td></tr><tr><td>git revert</td><td>file-level</td><td>(N/A)</td></tr></tbody></table><p>git 官方文档已有做出意见：</p><blockquote><ul><li>git revert is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one).</li><li>If you want to throw away all uncommitted changes in your working directory, you should see git-reset[1], particularly the –hard option.</li><li>If you want to extract specific files as they were in another commit, you should see git-checkout[1], specifically the git checkout <commit> – <filename> syntax.</filename></commit></li></ul></blockquote><p>即：</p><blockquote><ul><li>git revert 用于记录一些新的提交，以逆转某些较早提交的效果（通常只有一个错误的提交）。</li><li>如果要丢弃工作目录中所有未提交的更改，则应看到 git-reset，尤其是–hard 选项。</li><li>如果要提取特定文件，就像在另一个提交中一样，则应该看到 git-checkout ，特别是<code>git checkout &lt;commit&gt;-&lt;filename&gt;</code>语法。</li></ul></blockquote><p>参考内容：</p><ul><li><a href="https://git-scm.com/docs/git-revert" target="_blank" rel="noopener">https://git-scm.com/docs/git-revert</a></li><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86</a></li><li><a href="https://segmentfault.com/a/1190000009126517" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009126517</a></li><li><a href="https://dev.to/neshaz/when-to-use-git-reset-git-revert--git-checkout-18je" target="_blank" rel="noopener">https://dev.to/neshaz/when-to-use-git-reset-git-revert--git-checkout-18je</a></li><li><a href="https://stackoverflow.com/questions/8358035/whats-the-difference-between-git-revert-checkout-and-reset" target="_blank" rel="noopener">https://stackoverflow.com/questions/8358035/whats-the-difference-between-git-revert-checkout-and-reset</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十一）Git进阶与测试--clone远程仓库很慢的处理</title>
      <link href="/2019/12/24/TechnicalEssays/AboutGit/11handle-slow-clone/"/>
      <url>/2019/12/24/TechnicalEssays/AboutGit/11handle-slow-clone/</url>
      
        <content type="html"><![CDATA[<p>上一篇有讲到克隆远程仓库，在 clone 时，如果每次都 clone 完整的仓库的话，随着提交的次数变多，在项目变大之后，clone 的速度会非常的慢。</p><p>所以克隆时可以设定参数 <code>--depth 1</code>，加快 clone 速度</p><p><code>-- depth</code>代表克隆的深度，<code>--depth 1</code>代表只克隆最新一次提交记录以及这次提交之后的最新内容，不克隆历史提交。</p><p>这样所造成的影响就是不能查看历史提交记录，但是克隆速度大大提升。</p><p>完整命令：</p><pre><code>git clone --branch &lt;branch_name&gt; &lt;remote-address&gt; --depth 1</code></pre><p>查看 commit 总数，可用：</p><pre><code>git rev-list --all --count或者git log --oneline | wc -l</code></pre><p>后续补充：<br><strong>注意，这里 git rev-list 查看到的提交数量，并不一定和仓库中显示的提交数一样，获取的原理不同。后者是一致的。</strong><br>详细请查看官方文档关于<a href="https://git-scm.com/docs/git-rev-list" target="_blank" rel="noopener">git rev-list</a>的说明。</p><p>查看简要显示日志，可用：</p><pre><code>git log --all --oneline</code></pre><p>示例，今日(2019/12/25)克隆 github 中 tensorflow 项目，深度只有 1 层，<br>编写本文示例测试耗时大约<strong>4 分 15 秒</strong>，其它内容如下图：</p><p><img alt="1.png" data-src="/../images/TechnicalEssays/AboutGit/handle-slow-clone/1.png" class="lazyload"></p><p>而直接 clone master 分支的全部，<br>编写本文示例测试耗时大约<strong>13 分 30 秒</strong>，其它内容如下图：</p><p><img alt="2.png" data-src="/../images/TechnicalEssays/AboutGit/handle-slow-clone/2.png" class="lazyload"></p><p><strong>2019/12/26 补充，如果想看实际耗时，在 git 命令前加 time 关键词。</strong></p><p>如果后续想看完整的历史记录，可以将浅层克隆转换为常规克隆。使用：</p><pre><code>git pull --unshallow或者git fetch --unshallow</code></pre><p>不过，这就是重新抓取了该分支所有的提交，也就不如直接一开始就拉取所有了。</p><p>使用示例(同样编写本文示例测试耗时大约<strong>13 分 30 秒</strong>)：</p><p><img alt="3.png" data-src="/../images/TechnicalEssays/AboutGit/handle-slow-clone/3.png" class="lazyload"></p><p>查看当前分支所有提交者及其提交次数，按次数由高到低排序，可用：</p><pre><code>git log | grep &quot;^Author: &quot; | awk &#39;{print $2}&#39; | sort | uniq -c | sort -k1,1nr</code></pre><p><img alt="4.png" data-src="/../images/TechnicalEssays/AboutGit/handle-slow-clone/4.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十）使用docker安裝gitlab-ce</title>
      <link href="/2019/12/23/TechnicalEssays/AboutGit/10folder-or-file-not-effect-restore/"/>
      <url>/2019/12/23/TechnicalEssays/AboutGit/10folder-or-file-not-effect-restore/</url>
      
        <content type="html"><![CDATA[<p>本章主要测试讲解</p><ul><li>项目中的文件数量消长(新增或删除文件时) 与 存在的文件内容消长(同一份文件修改多次) ，这两种情境的版本还原有无区别</li><li>测试误删除文件，然后还原</li><li>本章使用 git reset，更多还原操作可参看下一章</li></ul><p>测试过程内容较多，每个步骤都逐一截图以便真实说明，也有列示用法。若不感兴趣，可直接查看总结部分。</p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><p>这里是测试不同正常修改的操作会不会影响到项目还原，按道理来讲，代码写到一般，文件未保存计算机电源被扒了，这部分如果编辑器没有缓存，应该是不会在 git 的还原操作内了。</p><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>1、远程仓库准备</p><ul><li>在 github 上找到了一个 commit 次数较多的项目，放置到测试的远程仓库，本例是 tensorflow</li></ul><p><img alt="1.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/1.png" class="lazyload"></p><p>2、本地仓库的准备</p><ul><li>clone 一个到本地，作为测试仓库</li><li>创建一个 dev 分支，进行测试</li><li>将本地 dev 分支推到远程 dev 分支</li></ul><h2 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h2><ul><li>1、使用 git rm 指令删除 tensorflow 子文件夹，commit 一次；</li><li>2、然后再新建 tensorflow 文件夹，并加上两个文件，commit 第二次；</li><li>3、再使用手动删除 third_party 文件夹，commit 第三次；</li><li>4、然后再新建 third_party 文件夹，并放上两个文件，commit 第四次；</li><li>5、最后 push 到远程 dev 分支。</li><li>6、再删除本地 tensorflow，clone 一份远程 dev 分支的 tensorflow，查看此时的 tensorflow 和 third_party 子文件夹内容</li><li>7、还原 clone 下来的项目到删除文件前，比较是否和之前的内容一致。</li></ul><p><strong>注意都是在同一分支（示例使用 dev）中进行的</strong></p><p><img alt="2.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/2.png" class="lazyload"></p><h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><p>1 操作前，项目中的 tensorflow 和 third_party 文件夹信息如下：</p><p><img alt="3.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/3.png" class="lazyload"></p><p>2 指令删除，添加，并提交</p><pre><code>git rm tensorflow -r -fgit add .git commit -m &#39;指令删除tensorflow子文件夹&#39;</code></pre><p><img alt="4.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/4.png" class="lazyload"></p><p>3 新建 tensorflow 子文件夹并放两个文件</p><p><img alt="5.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/5.png" class="lazyload"></p><p>添加并提交</p><p><img alt="6.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/6.png" class="lazyload"></p><p>4 手动删除 third_party 文件夹，并提交</p><p><img alt="7.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/7.png" class="lazyload"></p><p>5 新建 third_party 子文件夹并放两个文件</p><p><img alt="8.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/8.png" class="lazyload"></p><p>添加并提交</p><p><img alt="9.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/9.png" class="lazyload"></p><p>6 推送到远程 dev 分支<br>最好先 pull（因为与 origin 的 dev 比较，文件夹中内容有冲突，pull 会先合并 merge，因此会多一条 commit），<br>再 push 到 origin</p><p><img alt="10.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/10.png" class="lazyload"></p><p>7 删除本地项目，再 clone 一份远程的 dev 分支项目</p><p><img alt="11.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/11.png" class="lazyload"></p><p>查看内容与推送 push 之前是一致的（一致的）</p><p><img alt="12.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/12.png" class="lazyload"></p><p>查看一下近 10 条记录</p><p><img alt="13.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/13.png" class="lazyload"></p><p>8 将 clone 下来的项目，还原到 27cfc……提交的状态</p><p><img alt="14.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/14.png" class="lazyload"></p><p>查看一下文件内容，完全一致</p><p><img alt="15.png" data-src="/../images/TechnicalEssays/AboutGit/folder-or-file-not-effect-restore/15.png" class="lazyload"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由此看出：</p><ul><li>无论是手动删除，使用 git 命令删除，<br>无论子文件夹是否有多个层级，还是删除后有其它 commit 操作，<br>只要找到对应的 commit id，使用 git reset 方法都能还原到该次 commit 的状态，文件保持一致。</li><li>文件数量的增减，文件内容的增减，提交后的还原效果一致。</li></ul><p>（更多还原方式，参看下一章）</p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（九）Git进阶与测试--merge和rebase分支合并、解决冲突及特征对比</title>
      <link href="/2019/12/22/TechnicalEssays/AboutGit/9git-merge-and-rebase/"/>
      <url>/2019/12/22/TechnicalEssays/AboutGit/9git-merge-and-rebase/</url>
      
        <content type="html"><![CDATA[<p>本章主要测试讲解</p><ul><li><code>git merge</code>和<code>git rebase</code>指令的用法和进行分支合并，并做简单比较分析。</li></ul><p>测试过程内容较多，每个步骤都逐一截图以便真实说明，也有列示用法。若不感兴趣，可直接查看总结部分。</p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><p>关于无论是使用 merge 还是 rebase 进行合并，出现冲突的原因都是在不同的分支修改了同一处的代码，合并时版控工具 git 不知道保留哪一份的修改，从而导致冲突，需要合并人员去判断并解决。</p><p>使用 merge 和 rebase 合并的做法</p><p><img alt="1.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/1.png" class="lazyload"></p><h2 id="大概流程："><a href="#大概流程：" class="headerlink" title="大概流程："></a>大概流程：</h2><p>测试 git merge 和 git rebase 的合并及解决冲突效果：</p><ul><li>1 准备测试项目及分支记录<ul><li>创建 master、dev1、dev2 三个分支</li><li>除了 master 创建 dev1 和 dev2 的初始提交外，3 个分支各自有两个不同的提交记录<ul><li>时间顺序为：<br>master 新建空文件，再初始提交 –&gt;<br>创建 dev2 –&gt; dev2 commit 第一次文件修改 –&gt; dev2 commit 第二次文件修改 –&gt;<br>切回 master 创建 dev1 –&gt; dev1 commit 第一次文件修改 –&gt; dev1 commit 第二次文件修改 –&gt;<br>切回 master –&gt; master commit 第一次文件修改 –&gt; master commit 第二次文件修改 –&gt;<br>进行使用 git merge/git merge 合并测试……</li></ul></li></ul></li><li>2 使用 git merge 进行合并</li><li>3 使用 git rebase 进行合并</li><li>4 对比两者合并的历史记录，分析优缺点和使用场景</li></ul><h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><h3 id="准备测试项目及分支记录"><a href="#准备测试项目及分支记录" class="headerlink" title="准备测试项目及分支记录"></a>准备测试项目及分支记录</h3><p><em>相关命令请看截图</em></p><p>准备测试项目 test-conflict，新建一个 test1.txt 文件（后续新建的文件，最好都改成 UTF-8，windows 下默认是 ANSI，操作可能会产生乱码），内容为空，并 master 分支初始提交。</p><p><img alt="2.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/2.png" class="lazyload"></p><p>以 master 分支创建 dev2 分支</p><p><img alt="3.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/3.png" class="lazyload"></p><p>dev2 以 master 分支为基准，所以 test1.txt 还是为空的，两次修改 test1.txt</p><p><img alt="4.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/4.png" class="lazyload"></p><p>此时 dev2 的历史记录为</p><p><img alt="5.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/5.png" class="lazyload"></p><p>切换到 master 分支，并创建分支 dev1 并修改文件 test1.txt，然后分别提交</p><p><img alt="6.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/6.png" class="lazyload"></p><p>然后再修改一次，然后第二次提交</p><p><img alt="7.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/7.png" class="lazyload"></p><p>此时 dev1 的日志记录如下</p><p><img alt="8.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/8.png" class="lazyload"></p><p>此时切回到 master 分支，自行也修改并提交两次 test1.txt 的修改</p><p><img alt="9.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/9.png" class="lazyload"></p><p>此时 master 分支的记录为</p><p><img alt="10.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/10.png" class="lazyload"></p><p>直至，准备工作完整，我们打包一份，保留 2 个一模一样的项目，一个测试 git merge，一个测试 git rebase</p><h3 id="使用-git-merge-进行合并测试"><a href="#使用-git-merge-进行合并测试" class="headerlink" title="使用 git merge 进行合并测试"></a>使用 git merge 进行合并测试</h3><p>步骤说明：</p><ul><li>切换到 master 分支，先合并 dev1 到 master，再合并 dev2 到 master</li><li>因为 dev1、dev2 和 master 原本分支都有修改到 test1.txt 的同一行，所以会出现多次的合并冲突，需要手动解决</li><li>合并完成之后，查看 git merge 的 master 的日志</li></ul><p>创建时现有 dev2 的提交，但是合并时，先合并 dev1<br>合并 dev1 到 master，出现冲突</p><p><img alt="11.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/11.png" class="lazyload"></p><p>手动解决冲突并提交</p><p><img alt="12.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/12.png" class="lazyload"></p><p>再合并 dev2 到 master，依然报冲突</p><p><img alt="13.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/13.png" class="lazyload"></p><p>手动解决并提交</p><p><img alt="14.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/14.png" class="lazyload"></p><p>至此，使用 git merge 已把 dev1 和 dev2 合并到 master 分支，查看 master 分支的日志。</p><p><img alt="15.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/15.png" class="lazyload"></p><p>至此使用 git merge 合并和解决冲突测试完成。</p><h3 id="使用-git-rebase-合并冲突"><a href="#使用-git-rebase-合并冲突" class="headerlink" title="使用 git rebase 合并冲突"></a>使用 git rebase 合并冲突</h3><p>使用之前的备份项目测试 git rebase</p><p>步骤说明：</p><ul><li>切到 dev1 分支，rebase dev1 到 master，解决合并冲突</li><li>切回 master 分支（此时 master 的日志还没变），进行一次快速合并到 dev1（现在就变了）</li><li>切到 dev2 分支，rebase dev2 到 master，解决合并冲突</li><li>切回 master 分支，进行一次快速合并到 dev2</li><li>合并完成之后，查看 git rebase 的 master 的日志</li></ul><p>切回 dev1 分支，rebase dev1 到 master，会产生冲突。</p><p><img alt="16.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/16.png" class="lazyload"></p><p>修改成以下内容之后，再执行 git add .(没有执行 commit),然后继续进行 rebase</p><p><img alt="17.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/17.png" class="lazyload"></p><p>继续进行 rebase，则弹出第二次冲突提示</p><p><img alt="18.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/18.png" class="lazyload"></p><p>从文本来看，因为有两行是冲突的，第一次解决冲突是 master 中于 dev1 第一次提交有冲突的内容，现在报的是与 dev1 第二次提交有冲突的内容，同样手动解决，然后继续，可见 rebase 完成。</p><p><img alt="19.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/19.png" class="lazyload"></p><p>至此，使用 rebase，已经把 dev1 上的两次提交的修改变基到了 master 分支的提交修改上。</p><p>现在切回 master 分支（当然，此时 master 的日志还没变），进行一次快速合并到 dev1（现在就变了）</p><p><img alt="20.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/20.png" class="lazyload"></p><p>同样的，再合并 dev2，同样解决两次冲突，<br>第一次冲突</p><p><img alt="21.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/21.png" class="lazyload"></p><p>解决如下</p><p><img alt="22.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/22.png" class="lazyload"></p><p>第二次冲突</p><p><img alt="23.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/23.png" class="lazyload"></p><p>解决如下：</p><p><img alt="24.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/24.png" class="lazyload"></p><p>合并完成</p><p><img alt="25.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/25.png" class="lazyload"></p><p>同样，现在切回 master 分支，进行一次快速合并到 dev2，查看日志</p><p><img alt="26.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/26.png" class="lazyload"></p><h3 id="git-merge-和-git-rebase-的结果对比"><a href="#git-merge-和-git-rebase-的结果对比" class="headerlink" title="git merge 和 git rebase 的结果对比"></a>git merge 和 git rebase 的结果对比</h3><p>使用 git rebase 后，3 个分支的历史记录如下</p><p><img alt="27.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/27.png" class="lazyload"></p><p>git merge 历史记录如下</p><p><img alt="28.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/29.png" class="lazyload"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>git merge 和 git rebase 进行合并的区别：</p><ol><li>历史记录不同<ul><li>git merge 保留了各个分支各自的提交记录，如果有解决冲突，会单独创建一次 commit 记录冲突的解决，历史记录完整。</li><li>git rebase 只有一根线的分支记录历史，手动解决的冲突不会创建保留记录，历史记录清晰简单</li></ul></li><li>操作步骤不同<ul><li>git merge 操作简单，</li><li>git rebase 操作步骤繁琐。</li></ul></li><li>影响范围不同<ul><li>git merge 操作未对 dev1 和 dev2 的项目内容（或提交记录）进行异动，不会影响后续人员对此两个分支进行接续作业。</li><li>git rebase 操作已经对 dev1 和 dev2 分支进行了异动，如果有后续分支使用了这两个分支，可能会导致提交历史记录的混乱和其它异常情况。</li></ul></li></ol><p><strong>建议：</strong><br>只对尚未推送或分享给别人的本地修改执行变基操作清理历史，不要对已推送至别处的提交执行变基操作。</p><p><img alt="29.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/30.png" class="lazyload"></p><p>个人建议<br>对于合并，如果始终不清楚 merge 和 rebase 的区别，推荐使用 merge。<br>merge 的一大优点是简单，不会对其它分支造成影响。<br>唯一可能的不足就是会有比较多（不清晰）的提交记录，这一点可以使用 git rebase -i <commit id>，进入 interactive 模式（后续文章有介绍），对历史记录进行修改</commit></p><p><strong>新手提醒：如果需要合并的分支还有未提交的修改，是没有办法合并的。</strong></p><p><img alt="30.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/31.png" class="lazyload"></p><p><strong>Bonus：修改分支的名字</strong></p><p>假如从 master 分支创建了一个 feature-branch 分支，结果写成了 future-brunch</p><p><img alt="31.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/32.png" class="lazyload"></p><p>直接使用<code>git branch -m</code>参数修改即可</p><pre><code>git branch -m future-brunch feature-branch</code></pre><p><img alt="32.png" data-src="/../images/TechnicalEssays/AboutGit/git-merge-and-rebase/33.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（八）Git进阶与测试--.git文件夹中object数量过大是否影响commit效率？</title>
      <link href="/2019/12/21/TechnicalEssays/AboutGit/8object-effect-commit-performance/"/>
      <url>/2019/12/21/TechnicalEssays/AboutGit/8object-effect-commit-performance/</url>
      
        <content type="html"><![CDATA[<p>在此往后的几篇文章，主要是说明一些使用 Git 时比较高级一点的问题或者比较重要的问题。<br>除了一些测试说明、功能介绍、操作引导之外，还可以增长见识和思考方法，可以一看。</p><p>有些测试截图是比较旧（也就几个月），但是目前来看，依然是 ok 的。</p><p>测试过程内容较多，每个步骤都逐一截图以便真实说明，也有列示用法。若不感兴趣，可直接查看总结部分。</p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><p>众所周知，.git 文件夹是 git 管理项目的本地仓库。objects 目录存储所有数据内容，每一次 git commit 都会将信息存到该文件夹。<br>这部分不清楚，可去官网<a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4%E5%92%8C%E9%AB%98%E5%B1%82%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">Git 内部原理 - 底层命令和高层命令</a>和<a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">Git 内部原理 - Git 对象</a>等地方再巩固。<br>所以，一般情况下来看，git commit 的次数过多，object 文件夹体积就会变大，如果非常巨大了，会不会影响到提交的速度？</p><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>将 github 中的两个项目 tensorflow 和 liunx，clone 一份到本地，并推到自建 gitlab 服务器（内网 1.0Gbps）中，作为测试项目远程仓库。<br>主要说明 Git 客户端的使用，所以本地需要安装 Git</p><h2 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h2><p>准备两个比较大的项目，分别测试单次 add 和 commit 的耗时。</p><h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><p>1 以 tensorflow 项目为例进行 commit 测试<br>准备了一个 git 文件夹有 360M，提交数量超过 5W 的项目 tensorflow</p><p><img alt="1.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/1.png" class="lazyload"></p><p>测试 commit 之前，先提交一次已有的文件，以免出现干扰</p><p><img alt="2.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/2.png" class="lazyload"></p><p>在 tensorflow 中新建一个文件夹 newfoler，并随意放入几个文件</p><p><img alt="3.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/3.png" class="lazyload"></p><p>再测试 add 及 commit 的效果<br><img alt="4.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/4.png" class="lazyload"></p><p>两个命令耗时较短，并没有出现耗时的情况（第一个是 add，第二个是 commit）。排除切换页面和鼠标移动点击的时间，这两个命令耗时只有 1s 左右。</p><p><img alt="5.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/5.png" class="lazyload"></p><p>测试结果看来，一个有着 5W+commit 数量，git 文件夹超过 360M 的项目，在 commit 时并没有发生耗时很长的情况。</p><p>其实 git folder 要大于 500M 其实还是非常少的，我在 github 中找了非常久，到目前为止，就只发现 linux 项目超过 500M，提交数量超过 10W。</p><p>2 1 以 linux 项目为例进行 commit 测试<br>准备了一个提交数量和 git folder 都很大的项目（github 上的 linux 项目）</p><p><img alt="6.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/6.png" class="lazyload"></p><p>测试前，先<code>add .</code>一次，避免对 commit 提交速度进行干扰<br>（实际测试，clone 下来后，第一次<code>git add .</code>是比较耗时间的，好好几分钟）。</p><p>在 linux 下新建一个 new_folder 文件夹，并随意放入几个文件，如下</p><p><img alt="7.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/7.png" class="lazyload"></p><p>测试结果来看，完成 add 和 commit 的速度还是很快的</p><p><img alt="8.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/8.png" class="lazyload"></p><p>两个命令耗时较短，并没有出现耗时的情况（第一个是 add，第二个是 commit）。排除切换页面和鼠标移动点击的时间，这两个命令耗时只有 1s 左右。</p><p><img alt="9.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/9.png" class="lazyload"></p><p>再修改一些文件，删除一些文件</p><p><img alt="10.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/10.png" class="lazyload"></p><p>add 和 commit 的耗时依然不多</p><p><img alt="11.png" data-src="/../images/TechnicalEssays/AboutGit/object-effect-commit-performance/11.png" class="lazyload"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>这个 Linux 项目的 git 文件夹和 commit 数量是目前已经发现最大的项目，测试得出 add 和 commit 的时间都是很短，所以应该是不会出现 commit 非常耗时的情况。</li><li>所以 commit 的数量太大不会影响 commit 的速度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（七）Git入门及常用命令</title>
      <link href="/2019/12/21/TechnicalEssays/AboutGit/7git-basic/"/>
      <url>/2019/12/21/TechnicalEssays/AboutGit/7git-basic/</url>
      
        <content type="html"><![CDATA[<p>罗杰•杜德勒编写整理了一个不错的<a href="https://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">git - 简易指南</a>，可以查看学习。网上也有很多内容，没记住的，要用时搜一下就好了。</p><p>另外，我在<a href="https://github.com/Sanotsu/git-gitlab-advanced-notes" target="_blank" rel="noopener">github</a>有放一个简单的《7-Git入门指南》的 PPT，可以一并查看，主要说明的是：</p><ul><li>Git 是什么？</li><li>Git 简明指南补充说明</li><li>Git 常用指令（本文正文）</li><li>使用 Git 一般开发规范</li><li>Git Client GUI 及在 VS code 中使用 Git</li></ul><p>此处只是列示一些可能常用的 git 指令：</p><p>配置使用 Git 的账号密码：</p><pre><code>git config --global user.name &quot;Your Name&quot;git config --global user.email email@example.com</code></pre><p>初始化一个 Git 仓库：</p><pre><code>git init</code></pre><p>添加文件到 Git 仓库，分两步：<br>添加到暂存区：</p><pre><code class="sh">git add &lt;file&gt; #注意，可反复多次使用，添加多个档；</code></pre><p>提交到仓库</p><pre><code>git commit -m &lt;message&gt;。</code></pre><p>查看工作区的状态：</p><pre><code>git status。</code></pre><p>可以查看修改内容：</p><pre><code>git diff</code></pre><p>关联一个远程库：</p><pre><code>git remote add origin git@server-name:path/repo-name.git；</code></pre><p>关联后，使用命令第一次推送 master 分支的所有内容：</p><pre><code>git push -u origin master</code></pre><p>此后，每次本地提交后，推送最新修改；</p><pre><code>git push origin master</code></pre><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用</p><pre><code>git clone git@server-name:path/repo-name.git。</code></pre><p>查看分支：</p><pre><code>git branch</code></pre><p>创建分支：</p><pre><code>git branch &lt;name&gt;</code></pre><p>切换分支：</p><pre><code>git checkout &lt;name&gt;</code></pre><p>创建+切换分支：</p><pre><code>git checkout -b &lt;name&gt;</code></pre><p>合并某分支到当前分支：</p><pre><code>git merge &lt;name&gt;</code></pre><p>删除分支：</p><pre><code>git branch -d &lt;name&gt;</code></pre><p>看到分支合并图：</p><pre><code>git log –graph</code></pre><p>查看远程库信息：</p><pre><code>git remote -v；</code></pre><p>从本地推送分支</p><pre><code>git push origin &lt;branch-name&gt;，</code></pre><p>抓取远程的新提交；</p><pre><code>git pull</code></pre><p>在本地创建和远程分支对应的分支，使用</p><pre><code class="sh">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt; # 本地和远程分支的名称最好一致；</code></pre><p>建立本地分支和远程分支的关联</p><pre><code>git branch --set-upstream branch-name origin/branch-name；</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（六）远端访问gitlab默认PostgreSQL数据库</title>
      <link href="/2019/12/21/TechnicalEssays/AboutGit/6remote-access-gitlab-ce-postgresql/"/>
      <url>/2019/12/21/TechnicalEssays/AboutGit/6remote-access-gitlab-ce-postgresql/</url>
      
        <content type="html"><![CDATA[<p>gitlab 默认的数据库是 PostgreSQL ，用它官网的话来说就是“The World’s Most Advanced Open Source Relational Database”。</p><p>一般情况下，我们没有必要去直接访问它。但是，没必要不代表没需求。gitlab 结构、用户数据、配置信息等。</p><p>值得注意的是：</p><blockquote><p>在 GitLab 12.1 中删除了对 MySQL 的支持。建议在 MySQL / MariaDB 上使用 GitLab 的现有用户在升级之前迁移到 PostgreSQL。<br>从 GitLab 10.0 开始，需要 PostgreSQL 9.6 或更高版本，并且不支持较早的版本。我们强烈建议用户使用 PostgreSQL 9.6，因为这是用于开发和测试的 PostgreSQL 版本。</p></blockquote><h1 id="本地访问-PostgreSQL"><a href="#本地访问-PostgreSQL" class="headerlink" title="本地访问 PostgreSQL"></a>本地访问 PostgreSQL</h1><p>gitlab 默认有可以直接访问内部 postgreSQL 的命令：</p><pre><code>sudo gitlab-rails dbconsole或者sudo gitlab-psql -d gitlabhq_production</code></pre><p>这样就进入了 postgreSQL 命令窗口，可以输入 sql 语句进行作业。例如，输入<code>\list</code>查看所有数据库：</p><pre><code>sanotsu@sanotsu-ubt18:~$ sudo gitlab-rails dbconsolepsql (10.9)Type &quot;help&quot; for help.gitlabhq_production=&gt; \list                                             List of databases        Name         |    Owner    | Encoding |   Collate   |    Ctype    |        Access privileges---------------------+-------------+----------+-------------+-------------+--------------------------------- gitlabhq_production | gitlab      | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | postgres            | gitlab-psql | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | template0           | gitlab-psql | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | =c/&quot;gitlab-psql&quot;               +                     |             |          |             |             | &quot;gitlab-psql&quot;=CTc/&quot;gitlab-psql&quot; template1           | gitlab-psql | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | =c/&quot;gitlab-psql&quot;               +                     |             |          |             |             | &quot;gitlab-psql&quot;=CTc/&quot;gitlab-psql&quot;(4 rows)gitlabhq_production=&gt;</code></pre><p>或者输入<code>select * from namespaces;</code>查看 gitlab 中已经有了哪些用户。<br>输入<code>select * from projects;</code>查看有哪些项目文件等等。</p><p><strong>注意，在不能完全把控风险的情况下，最好不要擅自使用 SQL 的 DDL、DML、DCL 语言，避免造成 gitlab 运行意外。</strong></p><p><strong>特别注意：</strong><br>这里显示的 Name 有 4 个，除了 gitlabhq_porduction 的 owner 是 gitlab 之外，其它的是 gitlab-psql。<br>所以，在连接到 gitlab 内部的 postgresql 数据库时，指定数据库名称为 gitlabhq_porduction 才有实际意义，才能看到需要的信息。<br>这里的 dbconsole 默认是选择的 gitlabhq_production，但后续外部连接就不一定了。<br><del>因为我去看过其它几个数据库，啥都没有，我还以为是权限问题，不让我看，搞了半天……</del></p><h1 id="配置远程访问-PostgreSQL"><a href="#配置远程访问-PostgreSQL" class="headerlink" title="配置远程访问 PostgreSQL"></a>配置远程访问 PostgreSQL</h1><p>默认情况下，外部是无法访问 Gitlab 内部的 postgreSQL 的。实际上，现在很多的数据库，在初始默认安装时，都不允许外部直接访问的。</p><h2 id="了解一下-Gitlab-数据库各个配置文件-不感兴趣可跳到下一节"><a href="#了解一下-Gitlab-数据库各个配置文件-不感兴趣可跳到下一节" class="headerlink" title="了解一下 Gitlab 数据库各个配置文件(不感兴趣可跳到下一节)"></a>了解一下 Gitlab 数据库各个配置文件(不感兴趣可跳到下一节)</h2><p>要验证上述结论，除了亲自在外部试连之外，还可以直接看配置文件。</p><p>默认的 gitlab 数据库配置文件在<code>/var/opt/gitlab/gitlab-rails/etc/databse.yml</code>。</p><p>打开之后，看到的内容应该如下：</p><pre><code># This file is managed by gitlab-ctl. Manual changes will be# erased! To change the contents below, edit /etc/gitlab/gitlab.rb# and run `sudo gitlab-ctl reconfigure`.production:  adapter: postgresql  encoding: unicode  collation:  database: gitlabhq_production  pool: 1  username: &quot;gitlab&quot;  password:  host: &quot;/var/opt/gitlab/postgresql&quot;  port: 5432  socket:  sslmode:  sslcompression: 0  sslrootcert:  sslca:  load_balancing: {&quot;hosts&quot;:[]}  prepared_statements: false  statements_limit: 1000  fdw:</code></pre><p>可以看到，host 属性的值是本地文件路径，外部自然连不到的。</p><p>当然，可以直接查看 postgreSQL 的用户权限配置文件查看，默认路径在<code>/var/opt/gitlab/postgresql/data/pg_hba.conf</code>。</p><p>打开默认应该可以看到只有这样一句配置（Local）：</p><pre><code># TYPE  DATABASE    USER        CIDR-ADDRESS          METHOD# &quot;local&quot; is for Unix domain socket connections onlylocal   all         all                               peer map=gitlab</code></pre><p>此外，在同路径下的<code>postgresql.conf</code>文件中，也能看到（监控地址为空）：</p><pre><code># - Connection Settings -listen_addresses = &#39;&#39;    # what IP address(es) to listen on;          # comma-separated list of addresses;          # defaults to &#39;localhost&#39;, &#39;*&#39; = all          # (change requires restart)port = 5432        # (change requires restart)max_connections = 200      # (change requires restart)</code></pre><p>以上内容，也为了更加清楚的认识各个文件的构成和作用。</p><h2 id="修改-gitlab-配置文件实现远程访问-PostgreSQL"><a href="#修改-gitlab-配置文件实现远程访问-PostgreSQL" class="headerlink" title="修改 gitlab 配置文件实现远程访问 PostgreSQL"></a>修改 gitlab 配置文件实现远程访问 PostgreSQL</h2><p>实际上，可以一一修改上述文件去实现远程访问，只不过就是重启 gitlab 之后失效。<br>但是从配置文件修改，更加简单，一劳永逸。</p><p>打开<code>/etc/gitlab/gitlab.rb</code>配置文件，找到<code>## Gitlab PostgreSQL</code>区块，在<code>### Advanced settings</code>最末，加上以下内容：</p><pre><code>postgresql[&#39;listen_address&#39;] = &#39;{gitlab主机IP}&#39;postgresql[&#39;port&#39;] = 5432postgresql[&#39;trust_auth_cidr_addresses&#39;] = %w(127.0.0.1/24)postgresql[&#39;md5_auth_cidr_addresses&#39;] = %w({gitlab主机IP}/0)postgresql[&#39;sql_user&#39;] = &quot;gitlab&quot;postgresql[&#39;sql_user_password&#39;] = Digest::MD5.hexdigest &quot;gitlab&quot; &lt;&lt; postgresql[&#39;sql_user&#39;]</code></pre><p>把{gitlab 主机 IP}替换成你 gitlab 主机的真实 IP 即可。</p><p>其实把{gitlab 主机 IP}和 127.0.0.1 换成 0.0.0.0 也行。<br><del>如果不清楚限制，全部给到最大总能有效。</del></p><p>这几行的配置分别是：</p><ul><li>添加 postgresql 的监听地址，</li><li>添加 postgresql 的监听端口，</li><li>本地访问(127.0.0.1 或者 localhost)postgresql 不用输密码，</li><li>需要输入密码的访问地址，</li><li>连接到 postgresql 数据库的账号(示例中为 gitlab)，</li><li>连接到 postgresql 数据库的密码(示例中为 gitlab)。</li></ul><p>然后，找到<code>### Gitlab database settings</code>，在最末添加以下内容：</p><pre><code>gitlab_rails[&#39;db_username&#39;] = &quot;gitlab&quot;gitlab_rails[&#39;db_password&#39;] = &quot;gitlab&quot;gitlab_rails[&#39;db_host&#39;] = &quot;{gitlab主机IP}&quot;gitlab_rails[&#39;db_port&#39;] = 5432gitlab_rails[&#39;db_database&#39;] = &quot;gitlabhq_production&quot;</code></pre><p>依次是：数据库用户名、密码、地址、端口和默认数据库名称。<br>如果不设定最后一行，那么默认连接的数据库就是 postgres。</p><p>到这里，配置就修改完了，运行<code>sudo gitlab-ctl reconfigure</code>重新加载配置运行。</p><p><strong>注意，重新加载配置运行时，可能会从出现以下错误：</strong></p><pre><code>There was an error running gitlab-ctl reconfigure:bash[migrate gitlab-rails database] (gitlab::database_migrations line 54) had an error: Mixlib::ShellOut::ShellCommandFailed: Expected process to exit with [0], but received &#39;1&#39;---- Begin output of &quot;bash&quot;  &quot;/tmp/chef-script20191224-30773-18wzcfl&quot; ----STDOUT: rake aborted!PG::ConnectionBad: FATAL:  no pg_hba.conf entry for host &quot;192.168.XX.XX&quot;, user &quot;gitlab&quot;, database &quot;gitlabhq_production&quot;, SSL onFATAL:  no pg_hba.conf entry for host &quot;192.168.XX.XX&quot;, user &quot;gitlab&quot;, database &quot;gitlabhq_production&quot;, SSL off/opt/gitlab/embedded/service/gitlab-rails/lib/tasks/gitlab/db.rake:48:in `block (3 levels) in &lt;top (required)&gt;&#39;/opt/gitlab/embedded/bin/bundle:23:in `load&#39;/opt/gitlab/embedded/bin/bundle:23:in `&lt;main&gt;&#39;Tasks: TOP =&gt; gitlab:db:configure(See full trace by running task with --trace)STDERR:---- End output of &quot;bash&quot;  &quot;/tmp/chef-script20191224-30773-18wzcfl&quot; ----Ran &quot;bash&quot;  &quot;/tmp/chef-script20191224-30773-18wzcfl&quot; returned 1</code></pre><p>那是因为，需要重启 postgresql，重新配置才能生效。<br>所以，先运行<code>sudo gitlab-ctl restart postgresql</code>，再运行<code>sudo gitlab-ctl reconfigure</code>即可。</p><p>在旧一点的版本，7.x，8.x，9.x，10.x，11.x 我似乎都没有遇到过。可能是新数据库需求和版本有了变化吧。</p><p>其它的配置，按照实际需求添加即可，也可访问官网<a href="https://docs.gitlab.com/omnibus/settings/database.html" target="_blank" rel="noopener">数据库设置</a>查看更多信息</p><p>到此，应该就可以在远程连接<code>192.168.XX.XX</code>（你的 gitlab 主机 IP），通过账号 gitlab、密码 gitlab 连接到 gitlab 内部的 postgresql 数据库了。</p><h1 id="关系型数据库图形化工具-GUI-推荐及连接说明"><a href="#关系型数据库图形化工具-GUI-推荐及连接说明" class="headerlink" title="关系型数据库图形化工具(GUI)推荐及连接说明"></a>关系型数据库图形化工具(GUI)推荐及连接说明</h1><p>之前我使用连接到 postgresql 的图形化工具是 PgAdmin4，连接 mysql 用的是 MySQL Workbench，还有连接 SQL Server 用了 SQL Server Management Studio，连接 mariadb 用了 heidiSQL，还有 SQLite 等，遇到一个就去找一个，很麻烦，其实也没必要。</p><p>最近我发现一个还不错的 GUI，ce 版本可以支持连接这绝大部分常用的关系型数据库，叫 DBeaver。nosql 也支持，不过这部分就要收费了。所以我上面才没有列 Redis，MongoDB 什么的。</p><p><img alt="DBeaver连接界面" data-src="/../images/TechnicalEssays/AboutGit/remote-access-gitlab-ce-postgresql/DBeaver%E8%BF%9E%E6%8E%A5%E7%95%8C%E9%9D%A2.png" class="lazyload"></p><p>Windows 下，直接去<a href="https://dbeaver.io/download/" target="_blank" rel="noopener">dbeaver 官网</a>下载一个安装包即可。</p><p>linux 下稍微麻烦一点，以 Ubuntu18 为例，安装 DBeaver：</p><p>1、因为 DBeaver 是 java base，所以需要安装 java，openjdk 即可</p><pre><code>sudo apt-get install openjdk-8-jdk</code></pre><p>2、 添加 GPG key：</p><pre><code>wget -O - https://dbeaver.io/debs/dbeaver.gpg.key | sudo apt-key add -</code></pre><p>3、 添加仓库：</p><pre><code>echo &quot;deb https://dbeaver.io/debs/dbeaver-ce /&quot; | sudo tee /etc/apt/sources.list.d/dbeaver.list</code></pre><p>4、 更新，然后安装</p><pre><code>sudo apt updatesudo apt -y  install dbeaver-ce</code></pre><p>5、 检查 dbeaver 版本,有就安装成功</p><pre><code>apt policy  dbeaver-ce</code></pre><p>使用上就是选择连接的数据库类型，输入地址、端口、账号、密码、数据库名称等等，就不赘述了。</p><p>工作界面如下：</p><p><img alt="DBeaver连接postgresql工作界面" data-src="/../images/TechnicalEssays/AboutGit/remote-access-gitlab-ce-postgresql/DBeaver%E8%BF%9E%E6%8E%A5postgresql%E5%B7%A5%E4%BD%9C%E7%95%8C%E9%9D%A2.png" class="lazyload"></p><p><strong>注意，如果在外部使用 DBeaver 或者其它 GUI 连接到 gitlab 内部的 postgresql 时，没有填写数据库名称为 gitlabhq_production，那默认连接的就是 postgres。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）Gitlab用户数据备份与定时备份</title>
      <link href="/2019/12/20/TechnicalEssays/AboutGit/5gitlab-ce-usedata-backup/"/>
      <url>/2019/12/20/TechnicalEssays/AboutGit/5gitlab-ce-usedata-backup/</url>
      
        <content type="html"><![CDATA[<p>在安装 gitlab 的时候，有使用命令<code>sudo gitlab-rake gitlab:backup:create</code>备份用户数据。该备份路径是默认配置中的路径，我们可以对其进行修改。</p><p>此外，仅仅是备份在 gitlab 的主机中对数据丢失也有风险，例如硬盘坏了。</p><p>所以这里我简单列举了 gitlab-ce userdata(用户数据)备份到本机其它位置、备份到远程主机 2 种方式。</p><p>更多的，gitlab 还默认支持将用户数据备份到云端，配置中列示有 Amazon S3、Digital Ocean Spaces、 Google Cloud Storage 等。</p><p>具体详细的内容，可以查看官网的<a href="https://docs.gitlab.com/ce/raketasks/backup_restore.html" target="_blank" rel="noopener">Backing up and restoring GitLab</a></p><h1 id="常规备份设定——备份到本机其它位置"><a href="#常规备份设定——备份到本机其它位置" class="headerlink" title="常规备份设定——备份到本机其它位置"></a>常规备份设定——备份到本机其它位置</h1><p>打开<code>/etc/gitlab/gitlab.rb</code>文件，找到<code>Backup Settings</code>区块。<br>可以看到，默认的备份地址配置<code>gitlab_rails[&#39;backup_path&#39;] = &quot;/var/opt/gitlab/backups&quot;</code>。</p><p>所以，只需要修改这一句，调整路径，例如<code>gitlab_rails[&#39;backup_path&#39;] = &quot;/home/{username}/gitlab</code>，后续备份的用户数据，就在/home/{username}/gitlab 下了。<br>{username}为你的主机名。</p><h1 id="备份到远程主机"><a href="#备份到远程主机" class="headerlink" title="备份到远程主机"></a>备份到远程主机</h1><p>备份到远程主机，一开始不是很清楚这个配置设定，看着那段英文字翻译成中文没有看懂，假装配置几次失败后，就放弃了。使用了透过 ssh 使用 scp 指令，编写脚本文件，将 gitlab 主机的用户数据，copy 到其它主机。</p><p>以上做法是 ok 的，实际运行这么久也没什么问题。不管，这里我还是说明一下，如何使用 gitlab 的配置完成备份时一并备份到远程主机。<br>当然，前提条件是，在局域网内，可以直接访问指定位置。如果本来就无法访问，那肯定是这么配置都没用的。</p><p>仔细查看<a href="https://docs.gitlab.com/ce/raketasks/backup_restore.html#uploading-to-locally-mounted-shares" target="_blank" rel="noopener">官方文档的说明</a>，整理出实现步骤：</p><ol><li>将远程主机路径，挂载到 gitlab 主机，</li><li>将挂载地址的所有权赋予 git 账号，</li><li>在 gitlab.rb 中配置备份设定，</li><li>重新加载配置文件运行 gitlab。</li></ol><h2 id="ubuntu-中挂载远程主机共享文件夹"><a href="#ubuntu-中挂载远程主机共享文件夹" class="headerlink" title="ubuntu 中挂载远程主机共享文件夹"></a>ubuntu 中挂载远程主机共享文件夹</h2><p>一般情况下，我们在 ubuntu 中，点击‘其它位置’–&gt;’连接到服务器’–&gt;输入服务器地址–&gt;输入授权账号密码网域等，就可以直接访问到对应的位置。此次的挂载效果类似。</p><p>我的示例，是将 gitlab 服务器的用户数据，备份到一台 windows 系统的远程主机，所以需要将 windows 指定文件夹，挂在到 gitlab 所在的 ubuntu 系统。</p><p>1 gitlab 主机安装 cifs 工具</p><p>gitlab 主机是 ubuntu，运行<code>sudo apt-get install cifs-utils</code>即可。</p><p>2 新加需要挂载的目标文件夹</p><p>我的示例，是想把 windows 系统中的<code>//192.168.XX.XX/share/GitlabBackupDir</code>挂载到 ubuntu 中的<code>/mnt/backups</code>中。<br>所以执行<code>mkdir /mnt/backups</code>去创建对应文件夹，权限不够在前面加<code>sudo</code>。</p><p>3 挂载文件夹<br>一般直接使用 mount 指令的话，是临时挂载，计算机重启之后就没有了。现在这个场景，比较适合永久挂在，所以调价配置到文件为佳。<br>在挂载前，仔细阅读一下官网这句话：</p><blockquote><p>The directory pointed to by the local_root key must be owned by the git user when mounted (mounting with the uid= of the git user for CIFS and SMB) or the user that you are executing the backup tasks under (for Omnibus packages, this is the git user).</p></blockquote><p>经过我的测试分析，它的意思大概说明，这个挂载的地址，本例中为<code>/mnt/backups</code>，必须是执行挂载动作时的 git 用户，或者执行备份作业是的用户。使用 Omnibus packages 安装的 gitlab，这个执行的用户，就是 git 用户。</p><p>什么意思呢，简单理解就是，这个挂载地址文件夹的拥有者，必须是 git 用户。</p><p>到这里，我们再来添加挂载配置。</p><p>打开<code>/etc/fstab</code>文件，在最后添加以下内容：</p><pre><code>{被挂载的远程主机源路径}    {gitlab主机的目标路径}    cifs    auto,username={远程主机的用户名},password={远程主机用户名的密码},domain={远程主机的网域},gid={ubuntu下git用户的gid},uid={ubuntu下git用户的uid}    0 0</code></pre><p>空白留个 tab 键间隔或者空格就好了。各个间隔的参数含义，配置文件有说明，分别是</p><p>&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</p><p>如果获取 git 用户的 uid 和 gid？在终端中输入<code>id git</code>即可。<br>其它用户就是<code>id {user}</code>。我的挂载命令就是</p><pre><code>//192.168.XX.XX/share/GitlabBackupDir  /mnt/backups  cifs  auto,username=XXX,password=XXX,domain=XXX,gid=998,uid=998  0  0</code></pre><p>要让挂载立即生效，执行<code>sudo mount -a</code>即可。<br>查看是否挂载成功，执行<code>mount</code>查看，应该可以看到类似如下一句:</p><pre><code>……//192.168.XX.XX/share/GitlabBackupDir on /mnt/backups type cifs (rw,relatime,vers=2.1,cache=strict,username=XXX,domain=XXX,uid=998,forceuid,gid=998,forcegid,addr=192.168.XX.XX,file_mode=0755,dir_mode=0755,soft,nounix,serverino,mapposix,rsize=1048576,wsize=1048576,bsize=1048576,echo_interval=60,actimeo=1)……</code></pre><p>说明挂载成功。</p><p>额外说一句，如果只有临时挂载，重启就没有了，那就不写到配置文件，只需要在终端执行：</p><pre><code>mount -t cifs {被挂载的远程主机源路径} {gitlab主机的目标路径} -o username=&quot;{username}&quot;,password=&quot;{password}&quot;,domain={domain}</code></pre><p><strong>注意：</strong></p><ul><li>如果是 windows10 系统，可能需要在最末加一句 vers=2.0，写在配置文件也是一样要加。</li><li>终端中输入 option 要加引号。写到配置时，不要加，否则会报错。</li><li>如果没有网域，当然就不用添加这个参数。</li></ul><p>到这里挂载文件夹和赋予所有权给 git 用户已完成。</p><h2 id="修改-gitlab-rb-对应配置文件"><a href="#修改-gitlab-rb-对应配置文件" class="headerlink" title="修改 gitlab.rb 对应配置文件"></a>修改 gitlab.rb 对应配置文件</h2><p>打开<code>/etc/gitlab/gitlab.rb</code>文件，找到</p><pre><code># gitlab_rails[&#39;backup_upload_connection&#39;] = {#   &#39;provider&#39; =&gt; &#39;AWS&#39;,#   &#39;region&#39; =&gt; &#39;eu-west-1&#39;,#   &#39;aws_access_key_id&#39; =&gt; &#39;AKIAKIAKI&#39;,#   &#39;aws_secret_access_key&#39; =&gt; &#39;secret123&#39;# }# gitlab_rails[&#39;backup_upload_remote_directory&#39;] = &#39;my.s3.bucket&#39;# gitlab_rails[&#39;backup_multipart_chunk_size&#39;] = 104857600</code></pre><p>最好复制一份，修改为：</p><pre><code>gitlab_rails[&#39;backup_upload_connection&#39;] = {  &#39;provider&#39; =&gt; &#39;Local&#39;,  &#39;local_root&#39; =&gt; &#39;/mnt/backups&#39;}gitlab_rails[&#39;backup_upload_remote_directory&#39;] = &#39;gitlab_backups&#39;</code></pre><p>这个配置完成，那么在执行 geilab 备份时，会在<code>/mnt/backups</code>文件夹下创建<code>gitlab_backups</code>子文件夹，并放入该次备份的用户数据。<br>又因为这个路径，实际是 windows 下<code>//192.168.XX.XX/share/GitlabBackupDir</code>的挂载路径，所以实际上，用户数据的备份文件，就在这里。</p><p>以上，就完成了备份到远程主机的操作。配置好之后可能执行<code>sudo gitlab-rake gitlab:backup:create</code>命令测试一下，看是否在上述的路径下备份了用户数据。</p><p>当然，备份到 U 盘，外挂硬盘什么的，操作类似，不重复。至于备份到云，我没有这个条件，但是<a href="https://docs.gitlab.com/ce/raketasks/backup_restore.html#uploading-backups-to-a-remote-cloud-storage" target="_blank" rel="noopener">文檔</a>也写得比较清楚，照做即可。</p><p>此外，编写脚本，使用其它系统指令也可以实现类似的效果，这个不用 gitlab 进行配置，所以不赘述。</p><h2 id="实现定时备份"><a href="#实现定时备份" class="headerlink" title="实现定时备份"></a>实现定时备份</h2><p>可以将备份操作写到 cron 定时备份任务中去，那么就可以省略手动备份的操作了。</p><p>这个比较简单，在终端执行<code>sudo crontab -e</code>，或者</p><pre><code>sudo su -crontab -e</code></pre><p>系统自动备份的话，用户还是用 root 较好<br>选择一个编辑器，在最末，加一句（示例是每天凌晨 2 点进行备份，等级优先）</p><pre><code>0 2 * * * /opt/gitlab/bin/gitlab-backup create CRON=1</code></pre><p>注意，GitLab 12.1 及之前的版本, 使用 <code>0 2 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create CRON=1</code>.</p><p>保存，重启 cron 服务</p><pre><code>sudo service cron restart</code></pre><p>后续要修改，可以直接修改其文件，位置在<code>/var/spool/cron/crontabs</code>文件夹，如果是 root 账户，这里面就有个 root 文件。如果是其它用户{user},那就是{user}文件。</p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）gitlab-ce设置SMTP</title>
      <link href="/2019/12/20/TechnicalEssays/AboutGit/4gitlab-ce-set-smtp/"/>
      <url>/2019/12/20/TechnicalEssays/AboutGit/4gitlab-ce-set-smtp/</url>
      
        <content type="html"><![CDATA[<h1 id="Gitlab-ce-smtp-设定"><a href="#Gitlab-ce-smtp-设定" class="headerlink" title="Gitlab-ce smtp 设定"></a>Gitlab-ce smtp 设定</h1><p>在安装 Omnibus package 时，有推荐安装 postfix 搭建 mail 服务器。这可能比较麻烦。</p><p>此外，使用 gitlab 作为简单版控工具或其它功能，大部分都不需要接收其它用户发送的邮件，而是发出邮件。例如用户注册需要验证用户账户，合并冲突发送给对应使用者提醒有冲突，重大任务分配设置邮件提醒指定开发者……考虑到这些功能 gitlab 主要是作为发件者，配置 SMTP 即可。gitlab 默认支持 SMTP 的配置。</p><blockquote><p>SMTP 是一种提供可靠且有效的电子邮件传输的协议。SMTP 是建立在 FTP 文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。</p></blockquote><p>它与 POP3 和 IMAP 可共同使用。SMTP 是用于发送邮件，而 POP3 和 IMAP 用于接收邮件。</p><p>基本步骤如下：</p><h2 id="修改-gitlab-ce-默认-SMTP-配置"><a href="#修改-gitlab-ce-默认-SMTP-配置" class="headerlink" title="修改 gitlab-ce 默认 SMTP 配置"></a>修改 gitlab-ce 默认 SMTP 配置</h2><p>打开 gitlab-ce 的配置文件，默认在<code>/etc/gitlab/gitlab.rb</code>，找到对应配置 smtp 的位置，按照实际配置修改，如下图：</p><p><img alt="gitlab邮箱设定" data-src="/../images/TechnicalEssays/AboutGit/gitlab-ce-set-smtp/gitlab%E9%82%AE%E7%AE%B1%E8%AE%BE%E5%AE%9A.png" class="lazyload"><br><img alt="gitlab邮箱服务器设定" data-src="/../images/TechnicalEssays/AboutGit/gitlab-ce-set-smtp/gitlab%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E5%AE%9A.png" class="lazyload"></p><p>(为了方便修改，我把 Email Settings 部分和 GitLab email server settings 内容放到了一起)</p><p>对应的主要配置说明：</p><ul><li><p>设定 Email 相关信息(设定档中「Email Settings」区块为设定 Email 相关信息部分。)</p><ul><li>gitlab_email_enabled：启用 Email 功能。</li><li>gitlab_email_from：寄件人信箱。</li><li>gitlab_email_display_name：寄件人显示名称（预设为 GitLab 或是 GitLab 账号名称）。</li><li>gitlab_email_reply_to：回复信箱（预设为 noreply@ + 外部 URL）</li></ul></li><li><p>设定 SMTP Server(设定档中「GitLab email server settings」区块为设定 SMTP Server 部分)</p><ul><li>smtp_enable：启用 SMTP 功能。</li><li>smtp_address：SMTP Server。</li><li>smtp_port：SMTP Port。</li><li>smtp_user_name：SMTP 使用者账号。</li><li>smtp_password：SMTP 使用者密码。</li><li>smtp_domain：SMTP 网域。</li><li>smtp_authentication：SMTP 验证模式。</li><li>smtp_enable_starttls_auto：SMTP 开启 TLS 设定。</li><li>smtp_tls：使用 TLS 设定。</li><li>smtp_openssl_verify_mode：SMTP SSL 验证模式。</li></ul></li></ul><p>更多对应的配置，可参考一下官网的<a href="https://docs.gitlab.com/omnibus/settings/smtp.html" target="_blank" rel="noopener">SMTP settings</a></p><p>配置更改完成之后，需要执行<code>sudo gitlab-ctl reconfigure</code>使配置生效。</p><h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><h3 id="控制台命令测试"><a href="#控制台命令测试" class="headerlink" title="控制台命令测试"></a>控制台命令测试</h3><p>终端输入<code>sudo gitlab-rails console</code>,进入 gitlab-rails 工作区.</p><p>在命令行输入测试命令,测试命令格式：</p><pre><code>Notify.test_email({收件者邮箱地址},{邮件主题},{邮件内容}).deliver_now</code></pre><p>按照实际内容替换{}及其中文字即可。</p><p>如果发送成功，终端会显示测试命令发出的邮件信息，或者直接到收件者邮箱从查看。如果失败，可以根据终端中错误提示进行判断。</p><p>如下图：</p><p><img alt="终端指令测试SMTP配置" data-src="/../images/TechnicalEssays/AboutGit/gitlab-ce-set-smtp/%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4%E6%B5%8B%E8%AF%95SMTP%E9%85%8D%E7%BD%AE.png" class="lazyload"></p><p><em>值得注意，虽然我确认我是安装的 gitlab-ce 版本，但是这里显示的是 12.6.0-ee。我猜是一个小的 bug。</em></p><h3 id="设定-gitlab-注册用户需验证邮箱"><a href="#设定-gitlab-注册用户需验证邮箱" class="headerlink" title="设定 gitlab 注册用户需验证邮箱"></a>设定 gitlab 注册用户需验证邮箱</h3><p>或者直接使用 giltab 相关功能测试</p><p>可以测试，注册用户时，需要邮件确认之后，才能登入。gitlab 账号注册时验证邮箱的正确性，在注册时可以减少使用不存在的邮箱进行注册，保证 user 的有效性。</p><p>首先开启注册需要邮件验证。</p><p>使用 root 管理员账号登入，点击“管理员区域”–&gt;“设定”–&gt;”注册限制”，把<code>Send confirmation email on sign-up</code>打勾，最后保存。</p><p>然后新注册一个用户。</p><p>注销 root 账号之后，输入注册信息，点击注册按钮，会跳转到发送确认邮件的画面。</p><p>如果直接返回到登入页面，使用刚刚注册的账号登入，则会出现以下<code>You have to confirm your email address before continuing</code>字样。</p><p>这样，说明 gitlab 的注册验证邮箱的设定生效了。</p><p>然后查看刚刚注册账号使用的邮件，如果有收到自己 gitlab 发送的注册确认邮件，那么 gitlab SMTP 设定也是成功了。</p><p>当然，后续点击蓝色连接，则会跳转到登入页面，并有显示邮箱已被成功确认的信息，这时再使用刚刚注册账号登入即可成功。</p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）gitlab-web基本功能说明</title>
      <link href="/2019/12/19/TechnicalEssays/AboutGit/3gitlab-web-basic/"/>
      <url>/2019/12/19/TechnicalEssays/AboutGit/3gitlab-web-basic/</url>
      
        <content type="html"><![CDATA[<p>gitlab 安装成功之后，登录网页，可以看到它提供的很多功能。这个东西要写的话，恐怕还是非常复杂和麻烦。</p><p>例如其核心的自动部署和 CI/CD，到现在我也没有在生产环境下使用过。如果把 gitlab-ce 作为一个内部代码版控工具，也就还用不到这样的功能。</p><p>所以，这部分，使用者的 gitlab 基本功能使用介绍，我不再赘述，可以查看我之前有简单做的 PPT，放置在<a href="https://github.com/Sanotsu/git-gitlab-advanced-notes" target="_blank" rel="noopener">github</a>《3-gitlab基本功能测试使用介绍.pdf》。</p><p>主要内容有介绍：</p><ul><li>项目私有性测试</li><li>问题追踪</li><li>其它实用功能测试说明<ul><li>专案<ul><li>细节</li><li>活动</li></ul></li><li>档案库<ul><li>档案</li><li>更动记录</li><li>分支</li><li>标签</li><li>协作者</li><li>图表</li><li>比较</li><li>统计图</li></ul></li><li>议题<ul><li>里程碑</li><li>标签</li><li>清单</li><li>广告牌</li></ul></li><li>合并请求</li><li>Wiki</li><li>程序代码片段</li></ul></li></ul><p>因为当时作业环境是繁体，截图依旧保留繁体。</p><p>一般使用者和 gitlab 管理员的权限有所区别。主要在于管理员都一个<code>admin area</code>，这个最大最高权限，少数者拥有就好了，更多内容可参看官方文档<a href="https://docs.gitlab.com/ce/user/admin_area/" target="_blank" rel="noopener">GitLab Admin Area</a></p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）omnibus package安裝gitlab-ce</title>
      <link href="/2019/12/19/TechnicalEssays/AboutGit/2omnibus-gitlab-ce/"/>
      <url>/2019/12/19/TechnicalEssays/AboutGit/2omnibus-gitlab-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="omnibus-package-安装-gitlab-ce"><a href="#omnibus-package-安装-gitlab-ce" class="headerlink" title="omnibus-package 安装 gitlab-ce"></a>omnibus-package 安装 gitlab-ce</h1><p><a href="https://about.gitlab.com/install/#ubuntu" target="_blank" rel="noopener">ubuntu 下安装 gitlab-ce 官方推荐安装</a>，步骤也非常简单.</p><h2 id="安装并配置需要的依赖"><a href="#安装并配置需要的依赖" class="headerlink" title="安装并配置需要的依赖"></a>安装并配置需要的依赖</h2><p>1 先更新 apt-get:</p><pre><code>sudo apt-get update</code></pre><p>2 再安装 openssh-server</p><pre><code>sudo apt-get install -y curl openssh-server ca-certificates</code></pre><p>注意,在 ubuntu18 安装时 openssh-server 时，可能会出现类似这样的错误：</p><pre><code>sanotsu@sanotsu-ubt18:~$ sudo apt-get install -y curl openssh-server ca-certificates正在读取软件包列表... 完成正在分析软件包的依赖关系树正在读取状态信息... 完成ca-certificates 已经是最新版 (20180409)。ca-certificates 已设置为手动安装。curl 已经是最新版 (7.58.0-2ubuntu3)。有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件包尚未被创建或是它们已被从新到(Incoming)目录移出。下列信息可能会对解决问题有所帮助：下列软件包有未满足的依赖关系： openssh-server : 依赖: openssh-client (= 1:7.6p1-4)                  依赖: openssh-sftp-server 但是它将不会被安装                  推荐: ssh-import-id 但是它将不会被安装E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。sanotsu@sanotsu-ubt18:~$</code></pre><p>这是因为安装 openssh-server 依赖 openssh-client。ubuntu 默认有安装 openssh-client，但是版本可能不满足，所以只需再安装一次需要的版本。</p><p>例如上面的出错信息，则需要降级，命令安装如下：</p><pre><code>sudo apt-get install openssh-client=1:7.6p1-4</code></pre><p>安装成功之后，再安装 openssh-server 即可。</p><h2 id="安装邮箱服务器-Postfix-非必要，大可不必"><a href="#安装邮箱服务器-Postfix-非必要，大可不必" class="headerlink" title="安装邮箱服务器 Postfix(非必要，大可不必)"></a>安装邮箱服务器 Postfix(非必要，大可不必)</h2><pre><code>sudo apt-get install -y postfix</code></pre><p>然后按照提示，输入自己的配置。大概有需要输入的邮箱服务器地址，邮件名等等，还有一些使用 default 就好了。</p><p>如果不用 Postfix 来配置邮件收发，例如 gitlab 配置使用 SMTP 来发送邮件（后续文章再说明），这个部分可以跳过。</p><p>如果安装之后，想要移除，可使用<code>sudo apt-get remove postfix</code>来卸载。</p><h2 id="添加-GitLab-软件包存储库并安装软件包"><a href="#添加-GitLab-软件包存储库并安装软件包" class="headerlink" title="添加 GitLab 软件包存储库并安装软件包"></a>添加 GitLab 软件包存储库并安装软件包</h2><p>添加 GitLab 软件包存储库命令：</p><pre><code>curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash</code></pre><p>安装命令：</p><pre><code>sudo EXTERNAL_URL=&quot;http://192.168.XX.XX&quot; apt-get install gitlab-ce</code></pre><p>其中 EXTERNAL_URL 为 gitlab-ce 的访问地址，如果不设定，默认就是 <code>http://127.0.0.1</code>。</p><p><strong>注意，在之前的版本，设置<code>EXTERNAL_URL=&quot;192.168.XX.XX&quot;</code>是可以的，不过我现在使用 12.6.0 这样设置，会报错，错误如下：</strong></p><pre><code>There was an error running gitlab-ctl reconfigure:GitLab external URL must include a schema and FQDN, e.g. http://gitlab.example.com/</code></pre><p>下载和安装过程需要一点时间。</p><p>安装成功之后，打开之前设置的访问地址，应该会出现修改管理员密码画面，就表示 gitlab 安装成功。</p><p><strong>如果安装完成之后的自动运行配置出现错误，例如 url 配置出错等等，解决问题后再手动再运行一次<code>sudo gitlab-ctl reconfigure</code>。</strong></p><p>安装完成之后的组件分析：</p><p>gitlab 的结构分析，可参看<a href="https://docs.gitlab.com/ce/development/architecture.html#simplified-component-overview" target="_blank" rel="noopener">官网说明</a>,有助于理解各个组件的作用。</p><h2 id="一些常用指令"><a href="#一些常用指令" class="headerlink" title="一些常用指令"></a>一些常用指令</h2><p>1.查看状态：</p><pre><code>sudo gitlab-ctl status</code></pre><p>2.停止/启动/重启 gitlab</p><pre><code>sudo gitlab-ctl stopsudo gitlab-ctl startsudo gitlab-ctl restart</code></pre><p>3.重新加载配置</p><pre><code>sudo gitlab-ctl reconfigure</code></pre><p>3 关闭/启用开机自启动(<strong>慎重</strong>)这个 Gitlab 默认是开机自启动的。</p><p>Ubuntu 下禁止 Gitlab 开机自启动：</p><pre><code>sudo systemctl disable gitlab-runsvdir.service</code></pre><p>如果要设置开机自启动，Ubuntu 下启用 Gitlab 开机自启动：</p><pre><code>sudo systemctl enable gitlab-runsvdir.service</code></pre><p>自启动也还 ok，如果 disable 掉，开机在使用<code>sudo gitlab-ctl start</code>就启动不了了，因为所有的服务都关了，要启动起来才行。</p><p><strong>注意，如果 docker 的 gitlab 和 omnibus-package gitlab 安装在同一台机器，注意只开一个，因为端口什么的是一样的。</strong></p><p>如果安装完 omnibus-package gitlab，发现启动不了 docker 的 gitlab，并提示端口 22 已被占用，可能就是 sshd 占用了端口，关闭 ssh 即可。</p><pre><code>/etc/init.d/ssh stop</code></pre><p>当然，开启就是</p><pre><code>/etc/init.d/ssh start</code></pre><p>如果要关闭开机自启动 ssh（沒必要），删除其自动配置</p><pre><code>sudo mv /etc/init/ssh.conf /etc/init/ssh.conf/disabled</code></pre><h1 id="备份和还原用户数据"><a href="#备份和还原用户数据" class="headerlink" title="备份和还原用户数据"></a>备份和还原用户数据</h1><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>对应命令：</p><pre><code>sudo gitlab-rake gitlab:backup:create</code></pre><p>默认的备份地址在<code>/var/opt/gitlab/backups</code>中，查看该路径可以看到以下内容，即为备份的 userdata。</p><p>格式是：<code>{时间戳10位}_{年_月_日}_{gitlab版本号}_gitlab_backup.tar</code>。</p><p><strong>注意，在还原时，版本不一致的备份，是不能还原的，所以需要将 gitlab 的版本保持在一个固定的版本。</strong></p><h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><p>前提条件：</p><ul><li>您已经安装了与创建备份的 GitLab Omnibus 完全相同的版本和类型（CE / EE）。</li><li>你 sudo gitlab-ctl reconfigure 至少跑了一次。</li><li>GitLab 正在运行。如果没有，请使用它 sudo gitlab-ctl start。</li></ul><p>操作步骤：</p><ul><li>停止连接到数据库的进程，剩下部分继续 running</li></ul><pre><code>sudo gitlab-ctl stop unicornsudo gitlab-ctl stop sidekiq</code></pre><p>可以在停止之后，查看 gitlab 的状态<code>sudo gitlab-ctl status</code>，确认一下两个服务已经停止。</p><ul><li>再在已有的备份中，选择需要恢复的版本</li></ul><pre><code>sudo gitlab-rake gitlab:backup:restore BACKUP={备份的文件夹名}</code></pre><ul><li><p>恢复过程中，会有几次确认信息要手动确认，如果是确认要恢复，按照提示点击 yes 就好了。</p></li><li><p>恢复完之后，要重启 gitlab 服务</p></li></ul><pre><code>sudo gitlab-ctl restart</code></pre><p>此时再去访问 gitlab 的访问地址，就恢复到重置 root 密码的状态了。</p><p>如果是例如公司内部需要一个私有的仓库，最好还是使用 omnibus-package 安装，官方推荐，直接在设备的安装，配置等比较方便。</p><p>后续的内容都是以这种方式安装为例子。docker 之类的也可参考，不过是需要透过一层 docker 指令了。</p><p><strong>默认配置文件地址<code>/etc/gitlab/gitlab.rb</code>，后续会说明更多的配置,非常重要。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）使用docker安裝gitlab-ce</title>
      <link href="/2019/12/19/TechnicalEssays/AboutGit/1docker-install-gitlab-ce/"/>
      <url>/2019/12/19/TechnicalEssays/AboutGit/1docker-install-gitlab-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="系列文章前言"><a href="#系列文章前言" class="headerlink" title="系列文章前言"></a>系列文章前言</h1><p>此 git/gitlab 系列文章，预计会分为 3 个部分</p><ul><li><p>gitlab 的安装及常用配置说明</p></li><li><p>Git 入门和高级功能及常见问题的测试与解决</p></li><li><p>gitlab/git 推行使用规范示例</p></li></ul><p>当然不会非常全面，着重于代码托管和合作开发部分。部分章节主用 PPT 说明，可通过相关章节内容去 Github 获取。</p><p>虽然目前相关内容很多，不过对于此份内容部分，都是亲自测试并在内部进行了推广测试，比较详实。对于团体希望使用 git/gitlab 管理代码和合作开发，多多少少能有些参考作用；对于个人学习使用 git 和 gitlab，也有更多一点的帮助。</p><p>一些测试和功能实现部分，未必是最优解，但的确是一个解，可做参考。</p><p>此篇后续十七篇文章，一起入门 git/gitlab 的世界。</p><p>如果命令中有诸如 &lt;XXX&gt; 或者 {XXX}的指代，记得把符号一起替换成实际的参数。</p><p><em>Git入门及常用命令、Gitlab用户数据备份与定时备份、gitlab-web基本功能说明、omnibus package安裝gitlab-ce 的cover图源网络。</em></p><h1 id="docker-安装-gitlab-ce"><a href="#docker-安装-gitlab-ce" class="headerlink" title="docker 安装 gitlab-ce"></a>docker 安装 gitlab-ce</h1><h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><pre><code>sudo apt install docker.io</code></pre><p>安装完成之后，直接使用 docker 命令，可能会出现权限不足（permission denied）。</p><p>解决方法，将一般用户加入可用：</p><pre><code>sudo usermod –aG docker &lt;username&gt;</code></pre><p>设置完之后，一定要注销用户，再登入，才能生效，生效之后。<br>ubuntu18 可能需要重启。</p><p>更多 docker 常用指令的简单说明，可参看之前使用 《Ubuntu18.04下docker基本指令和使用docker安装mysql》</p><h2 id="安装前的清理"><a href="#安装前的清理" class="headerlink" title="安装前的清理"></a>安装前的清理</h2><p>因为重头来过，所以，我们先查看下是否有之前安装过的名叫 gitlab 的容器</p><pre><code>docker ps </code></pre><p>此处若没有，则没有 gitlab 的 docker；如果有，则用命令：<code>docker rm gitlab</code>移除</p><h2 id="抓取官方-gitlab-image-并使用-docker-运行容器"><a href="#抓取官方-gitlab-image-并使用-docker-运行容器" class="headerlink" title="抓取官方 gitlab image 并使用 docker 运行容器"></a>抓取官方 gitlab image 并使用 docker 运行容器</h2><p>直接终端输入指令</p><pre><code>docker pull gitlab/gitlab-ce:latest</code></pre><p>pull 可能需要一点时间，取决你下载的网速。</p><p>下载成功之后，使用<code>docker images</code>命令可以看到下载的 docker 镜像列表。</p><p>使用下载好的 images，创建容器，例如:</p><pre><code>docker run --detach \--hostname 192.168.XX.XX \--publish 443:443 --publish 80:80 --publish 22:22 \--name gitlab \--restart always \--volume /srv/gitlab-ce/config:/etc/gitlab \--volume /srv/gitlab-ce/logs:/var/log/gitlab \--volume /srv/gitlab-ce/data:/var/opt/gitlab \gitlab/gitlab-ce:latest</code></pre><p>以上配置了：<br>hostname：gtilab 的访问地址；<br>publish：映像主机端口和 docker 中访问 gitlab 的端口;<br>name：docker 容器名称;<br>restart：是否自动重启;<br>–volume：设定创建存放配置、日志、数据的文件夹.</p><p>在设定的位置(–volume)，会生成以下几个文件夹，如下图</p><p><img alt="创建的gitlab文件夹" data-src="/../images/TechnicalEssays/AboutGit/docker-install-gitlab-ce/%E5%88%9B%E5%BB%BA%E7%9A%84gitlab%E6%96%87%E4%BB%B6%E5%A4%B9.png" class="lazyload"></p><p>其作用可参考以下：</p><table><thead><tr><th>本地位置</th><th>容器位置</th><th>用途</th></tr></thead><tbody><tr><td>/srv/gitlab-ce/data</td><td>/var/opt/gitlab</td><td>For storing application data</td></tr><tr><td>/srv/gitlab-ce/logs</td><td>/var/log/gitlab</td><td>For storing logs</td></tr><tr><td>/srv/gitlab-ce/config</td><td>/etc/gitlab</td><td>For storing the GitLab configuration files</td></tr></tbody></table><p>正常的话，在创建完之后，会自动开启，开启成功之后，效果如下图（当看到 STATUS 为 healthy，表明已经正常启动）：</p><p><img alt="docker正常启动gitlab容器" data-src="/../images/TechnicalEssays/AboutGit/docker-install-gitlab-ce/docker%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8gitlab%E5%AE%B9%E5%99%A8.png" class="lazyload"></p><p>登入之前创建 container 时的 hostname，可以查看到，如下图：</p><p><img alt="gitlab初始首页" data-src="/../images/TechnicalEssays/AboutGit/docker-install-gitlab-ce/gitlab%E5%88%9D%E5%A7%8B%E9%A6%96%E9%A1%B5.png" class="lazyload"></p><p>首次访问时，需要设定 root 管理员的密码，账号默认为 root，修改密码成功之后，则进入到登入画面，即可输入 root 账号密码，进入查看。</p><p>如果需要关闭容器，使用 stop 命令，例如停止/开启已有的 gitlab( 例如 docker name 为 gitlab)</p><pre><code class="sh">docker stop gitlab  # 停止docker start gitlab # 开启</code></pre><p>如果发现启动不了 docker 的 gitlab，并提示端口 22 已被占用，可能就是 sshd 占用了端口。</p><p>关闭 ssh 即可：</p><pre><code>/etc/init.d/ssh stop</code></pre><p>当然，开启就是</p><pre><code>/etc/init.d/ssh start</code></pre><p>如果配置有错，需要修改 gitlab 的配置文件<code>gitlab.rb</code>,可是使用命令</p><pre><code>sudo docker exec -it gitlab editor /etc/gitlab/gitlab.rb</code></pre><p>去打开文件编辑。不过一旦打开了这个文件，就注意给<code>external_url</code>参数，赋予一个有效的值。就是 gitlab 访问地址需要可用。</p><p>修改了配置文件，需要重启该容器使其生效：</p><pre><code>docker restart gitlab</code></pre><h1 id="备份和还原用户数据"><a href="#备份和还原用户数据" class="headerlink" title="备份和还原用户数据"></a>备份和还原用户数据</h1><h2 id="手动备份用户数据"><a href="#手动备份用户数据" class="headerlink" title="手动备份用户数据"></a>手动备份用户数据</h2><p>目前除了设定了一个 root 账号的密码之外，其它什么都没有，我现在备份一次此时的 gitlab user data，使用指令</p><pre><code>docker exec -it gitlab gitlab-rake gitlab:backup:create</code></pre><p>备份成功之后，默认位置在存放 data 的路径下，也就是创建并运行容器时的配置路径：<code>/srv/gitlab-ce/data/backups</code>。</p><p>在 root 权限或者当前用户取得该文件夹权限后，可以看到该文件夹内部文件，gitlab-ce 备份的用户数据的格式例如：</p><p><code>{时间戳10位}_{年_月_日}_{gitlab版本号}_gitlab_backup.tar</code></p><p>或者可直接使用命令行查看：<code>docker exec -it gitlab ls /var/opt/gitlab/backups/</code></p><h2 id="还原备份的文件"><a href="#还原备份的文件" class="headerlink" title="还原备份的文件"></a>还原备份的文件</h2><p>备份之后，后续作业如果出现问题，可以还原到这个原始版本；当然，如果定时备份，则可以随时还原到需要的时间节点版本。</p><p>还原命令：</p><pre><code>docker exec -it gitlab /opt/gitlab/bin/gitlab-rake gitlab:backup:restore BACKUP={时间戳10位}_{年_月_日}_{gitlab版本号}</code></pre><p>BACKUP=后面输入需要返回的备份文件名称</p><p><strong>注意,gitlab 只能还原版本相同的备份文件,版本不同不能还原。</strong></p><p>使用 docker 安装就像是装在了沙盒，不想要了可以直接删除，没有什么顾虑。但是操作起来比较麻烦，毕竟中间隔了一层。用于测试等轻量使用较宜。</p>]]></content>
      
      
      <categories>
          
          <category> Git/Gitlba系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular i18n使用说明</title>
      <link href="/2019/12/18/TechnicalEssays/angular-i18n-demo/"/>
      <url>/2019/12/18/TechnicalEssays/angular-i18n-demo/</url>
      
        <content type="html"><![CDATA[<p>angular 项目，在实际使用开发时，难免会遇到需要使用多国语言的需求，也就是 angular 的国际化 i18n 的需求。</p><p>那么如何做到呢？</p><p>本文主要通过对一个常见的注册页面，实现多国语言版本的切换，来说明 angular i18n 的用法。代码已放到<a href="https://github.com/Sanotsu/angular-i18n-demo" target="_blank" rel="noopener">github</a>。</p><h1 id="创建一个-angular-项目，并编写英文版注册页面"><a href="#创建一个-angular-项目，并编写英文版注册页面" class="headerlink" title="创建一个 angular 项目，并编写英文版注册页面"></a>创建一个 angular 项目，并编写英文版注册页面</h1><h2 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h2><p>创建就是直接终端输入<code>ng new angular-i18n-demo</code>即可。<br>因为只是说明 i18n 的使用，不会过多复杂，不需要其他的模块例如 router、service 等。</p><p>目前前端开发，不使用一些样式（说白了就是 UI 组件）就很累，所以创建好 angular 项目之后，添加 angular material，使得注册页面稍微好看一点。<br>在 angular 项目根目录终端输入<code>ng add @angular/material</code>即可。</p><h2 id="2、编写页面"><a href="#2、编写页面" class="headerlink" title="2、编写页面"></a>2、编写页面</h2><p>不需要实现注册功能，构建一个注册页面就好了。因为已经使用了 angular material，就稍微用几个模块。</p><h3 id="2-1、在-app-module-ts-引入-angular-material-模块"><a href="#2-1、在-app-module-ts-引入-angular-material-模块" class="headerlink" title="2.1、在 app.module.ts 引入 angular material 模块"></a>2.1、在 app.module.ts 引入 angular material 模块</h3><p>在 app.module.ts 的@NgModule 装饰器下的 imports 属性中，添加以下内容：</p><pre><code>BrowserAnimationsModule,MatToolbarModule,MatCardModule,MatInputModule,MatButtonModule,MatIconModule</code></pre><p>然后逐一导入，在顶部应该会有：</p><pre><code>import { BrowserAnimationsModule } from &#39;@angular/platform-browser/animations&#39;;import {   MatInputModule,   MatCardModule,   MatToolbarModule,   MatButtonModule,   MatIconModule} from &#39;@angular/material&#39;;</code></pre><h3 id="2-2-在-app-目录下，创建一个注册的组件"><a href="#2-2-在-app-目录下，创建一个注册的组件" class="headerlink" title="2.2 在 app 目录下，创建一个注册的组件"></a>2.2 在 app 目录下，创建一个注册的组件</h3><p>如下图：</p><p><img alt="新建注册组件" data-src="/../images/TechnicalEssays/angular-i18n-demo/%E6%96%B0%E5%BB%BA%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6.png" class="lazyload"></p><p>我这个是直接使用指令<code>ng g component register</code>生成，angular-cli 工具的操作，它会直接把这个组件也添加到模块文件：</p><p><img alt="自动添加到app.module.ts文件" data-src="/../images/TechnicalEssays/angular-i18n-demo/%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%88%B0app.module.ts%E6%96%87%E4%BB%B6.png" class="lazyload"></p><h3 id="2-3-添加代码："><a href="#2-3-添加代码：" class="headerlink" title="2.3 添加代码："></a>2.3 添加代码：</h3><p>修改<code>register.component.html</code>代码如下：</p><pre><code>&lt;div class=&#39;my-div&#39;&gt;  &lt;mat-toolbar&gt;    &lt;mat-icon&gt;create&lt;/mat-icon&gt;&amp;nbsp;&amp;nbsp; Registration  &lt;/mat-toolbar&gt;  &lt;mat-card&gt;    &lt;mat-card-content&gt;      &lt;form&gt;        &lt;div class=&quot;word-align&quot;&gt;First Name&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;First name&quot; name=&quot;fname&quot; required&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;        &lt;div class=&quot;word-align&quot;&gt;Last Name&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;Last Name&quot; name=&quot;lname&quot; required&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;        &lt;div class=&quot;word-align&quot;&gt;Address&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;Address&quot; name=&quot;address&quot; required&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;        &lt;div class=&quot;word-align&quot;&gt;Email&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;Email&quot; name=&quot;email&quot;&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;        &lt;div class=&quot;word-align&quot;&gt;Password&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;Password&quot; name=&quot;password&quot;&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;        &lt;div class=&quot;word-align&quot;&gt;Confirm Password&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;mat-form-field&gt;          &lt;input matInput placeholder=&quot;Confirm Password&quot; name=&quot;confirmPassword&quot;&gt;        &lt;/mat-form-field&gt;        &lt;br /&gt;      &lt;/form&gt;    &lt;/mat-card-content&gt;    &lt;mat-card-actions&gt;      &lt;button mat-raised-button (click)=&quot;register()&quot; color=&quot;primary&quot;&gt;REGISTER&lt;/button&gt;    &lt;/mat-card-actions&gt;  &lt;/mat-card&gt;</code></pre><p>修改<code>register.component.scss</code>代码如下：</p><pre><code>// div居中.my-div {  width: 40%;  margin-left: 30%;}// 设定form中label等宽.word-align {  display: inline-block;  text-align: justify;  text-justify: distribute-all-lines; /*ie6-8*/  text-align-last: justify; /* ie9*/  -moz-text-align-last: justify; /*ff*/  -webkit-text-align-last: justify; /*chrome 20+*/  width: 70px;  margin-right: 0px;}</code></pre><p>因为我们不会去实现注册功能，所以在<code>register.component.ts</code>中，只需要添加一个空白注册函数就好了：</p><pre><code>import { Component, OnInit } from &#39;@angular/core&#39;;@Component({  selector: &#39;app-register&#39;,  templateUrl: &#39;./register.component.html&#39;,  styleUrls: [&#39;./register.component.scss&#39;]})export class RegisterComponent implements OnInit {  constructor() { }  ngOnInit() {  }  register() { } // 新建一个空白注册函数}</code></pre><h3 id="2-4-将注册页面显示出来"><a href="#2-4-将注册页面显示出来" class="headerlink" title="2.4 将注册页面显示出来"></a>2.4 将注册页面显示出来</h3><p>现在运行这个 angular 项目，首页看到的还是默认的界面。<br>删除 app.component.html 原本的所有东西，添加一句各个注册组件的 selector：</p><pre><code>&lt;app-register&gt;&lt;/app-register&gt;</code></pre><p>我用<code>ng server -o --port 1234</code>启动，在浏览器中应该看到如下画面：</p><p><img alt="默认的注册画面" data-src="/../images/TechnicalEssays/angular-i18n-demo/%E9%BB%98%E8%AE%A4%E7%9A%84%E6%B3%A8%E5%86%8C%E7%94%BB%E9%9D%A2.png" class="lazyload"></p><p>到这里，常规的注册页面就完成了，是个英文版本，i18n 准备工作就好了，下面开始实现变简体中文。</p><h1 id="修改注册页面为简体中文版本"><a href="#修改注册页面为简体中文版本" class="headerlink" title="修改注册页面为简体中文版本"></a>修改注册页面为简体中文版本</h1><p>在 angular 官方文档中，我们可以看到<a href="https://angular.cn/guide/i18n#template-translations" target="_blank" rel="noopener">i18n 模板翻译分为 4 个阶段</a>,主要就是</p><ol><li>在组件模板中标记需要翻译的静态文本信息。</li><li>创建翻译文件：使用 Angular CLI 的 xi18n 命令，把标记过的文本提取到一个符合行业标准的翻译源文件中。</li><li>编辑所生成的翻译文件：把提取出的文本翻译成目标语言。</li><li>把翻译完成的文件合并回应用</li></ol><p>一步一步来。</p><h2 id="1、组件模板中标记需要翻译的静态文本信息"><a href="#1、组件模板中标记需要翻译的静态文本信息" class="headerlink" title="1、组件模板中标记需要翻译的静态文本信息"></a>1、组件模板中标记需要翻译的静态文本信息</h2><p>常规的标签直接在标签中添加 i18n 关键字即可，如下图：</p><p><img alt="i18n翻译常规标签" data-src="/../images/TechnicalEssays/angular-i18n-demo/i18n%E7%BF%BB%E8%AF%91%E5%B8%B8%E8%A7%84%E6%A0%87%E7%AD%BE.png" class="lazyload"></p><p>要翻译的内容的元素标签中其他内容时，可以使用 ng-container 将文本包裹起来，示例如下：</p><p><img alt="i18n翻译标签内文本" data-src="/../images/TechnicalEssays/angular-i18n-demo/i18n%E7%BF%BB%E8%AF%91%E6%A0%87%E7%AD%BE%E5%86%85%E6%96%87%E6%9C%AC.png" class="lazyload"></p><p>如果是要翻译某个标签的属性值，则需要添加 i18n-&lt;属性名&gt;标签，示例如下：</p><p><img alt="i18n翻译标签内属性" data-src="/../images/TechnicalEssays/angular-i18n-demo/i18n%E7%BF%BB%E8%AF%91%E6%A0%87%E7%AD%BE%E5%86%85%E5%B1%9E%E6%80%A7.png" class="lazyload"></p><p>更多用法参看 angular 官网<a href="https://angular.cn/guide/i18n#template-translations" target="_blank" rel="noopener">i18n 模板翻译</a></p><h2 id="2、创建翻译源文件"><a href="#2、创建翻译源文件" class="headerlink" title="2、创建翻译源文件"></a>2、创建翻译源文件</h2><p>将模板做好标记后，使用指令<code>ng xi18n --output-path &lt;path&gt;</code>,生成翻译源文件，&lt;path&gt;则是文件位置。</p><p>此外还有属性：</p><ul><li>–i18nFormat：明确指定想用的格式（默认 XLIFF 1.2）</li><li>–out-file： 为提取工具生成的翻译源文件改名（默认为 messages ）</li><li>–i18n-locale：指定应用的基本地区（对 angular 没有，但可能对其他需求有用）</li><li>等等</li></ul><p>我的指令是<code>ng xi18n --output-path src/locale --out-file register.zh-Hans.xlf</code>，生成的翻译源文件如下图：</p><p><img alt="生成的翻译源文件" data-src="/../images/TechnicalEssays/angular-i18n-demo/%E7%94%9F%E6%88%90%E7%9A%84%E7%BF%BB%E8%AF%91%E6%BA%90%E6%96%87%E4%BB%B6.png" class="lazyload"></p><h2 id="3、翻译文本节点"><a href="#3、翻译文本节点" class="headerlink" title="3、翻译文本节点"></a>3、翻译文本节点</h2><p>打开生成的翻译源文件，找到文中的<trans-unit>标签，可以看到里面有一个<source>标签，这标签里面的文字，就是需要多国语言需要翻译的文字。</trans-unit></p><p>现在要做的就是，复制<source>标签这一行，放到原本<source>这一行下面，并把它的标签名名为 target，并把它的内容改为需要翻译的语言文字。</p><p>例如，我现在要做的是把英文翻译成简体中文，那么修改示例如下：</p><p><img alt="修改翻译源文件" data-src="/../images/TechnicalEssays/angular-i18n-demo/%E4%BF%AE%E6%94%B9%E7%BF%BB%E8%AF%91%E6%BA%90%E6%96%87%E4%BB%B6.png" class="lazyload"></p><p>注意所有的<source>标签都添加对应的<target>标签。</target></p><p><strong>特别注意：</strong></p><ul><li>翻译源文件里面有很多的 id，而且还特别长.</li><li>这是因为在“1、组件模板中标记需要翻译的静态文本信息”时，没有给每一个标记 i18n 的地方添加 id，所以工具自动生成了随机 id。</li><li>这个 id 最好不要修改，一旦修改可能在文字替换时就对应不上。</li><li>如果模板文件有修改，则可能需要重新再生成一份翻译源文件，因为这些随机 id 可能已经变了。</li></ul><p>当然，如果不嫌麻烦，可以给每个模板文件有标记 i18n 的地方，都给他添加 id，那么生成的翻译源文件的 id 就不会变。</p><p>模板中添加 id 使用示例：</p><pre><code> &lt;div class=&quot;word-align&quot; i18n=&quot;@@firstName&quot;&gt;First Name&lt;/div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;</code></pre><p><del>(因为工具会生成随机 id，且如果需要翻译的文字太多，逐一设置 id 比较麻烦，所以我没有这样设 id)</del></p><h2 id="4、修改-angular-json-配置文件"><a href="#4、修改-angular-json-配置文件" class="headerlink" title="4、修改 angular.json 配置文件"></a>4、修改 angular.json 配置文件</h2><h3 id="4-1、添加编译配置"><a href="#4-1、添加编译配置" class="headerlink" title="4.1、添加编译配置"></a>4.1、添加编译配置</h3><p>打开 angular.json 文件，找到属性 projects–&gt;{angular-i18n-demo(angular 项目名)}–&gt;architect–&gt;build–&gt;configurations;在 production 同级属性，添加对不同语言的编译配置，如下图：</p><p><img alt="添加i8n多国语言编译配置" data-src="/../images/TechnicalEssays/angular-i18n-demo/%E6%B7%BB%E5%8A%A0i8n%E5%A4%9A%E5%9B%BD%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE.png" class="lazyload"></p><p>配置内容简单说明：</p><ul><li>使用 AOT 方式编译</li><li>文件输出路径</li><li>i18n 文件位置</li><li>i18n 使用的格式</li><li>i18n 的位置</li><li>如果翻译有缺失报警告</li><li>添加基本路径</li></ul><p>最后一条需要多说一点，就是翻译后，例如英文版本编译后访问的地址是<code>http://localhost:4200/register</code>，如果要看到中文版，则需要访问<code>http://localhost:4200/register/zh-Hans</code></p><h3 id="4-2、添加测试运行配置"><a href="#4-2、添加测试运行配置" class="headerlink" title="4.2、添加测试运行配置"></a>4.2、添加测试运行配置</h3><p>同样在 angular.json 文件，就在添加编译配置的父级 build 下一个属性 server，在 server–&gt;configurations 属性，在 production 同级属性，添加以下内容：</p><p><img alt="添加测试运行配置" data-src="/../images/TechnicalEssays/angular-i18n-demo/%E6%B7%BB%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE.png" class="lazyload"></p><p><strong>注意：ng serve 运行时只能一次运行一种语言的翻译，无法同时加载多种语言。</strong></p><h2 id="5、测试运行，查看效果"><a href="#5、测试运行，查看效果" class="headerlink" title="5、测试运行，查看效果"></a>5、测试运行，查看效果</h2><p>到这里，我们就有了一个简体中文版本的注册页面可以看了。<br>启动项目，在项目根目录启动终端输入</p><pre><code>ng serve --configuration=zh-Hans -o --port 1234</code></pre><p>项目启动成功，则可以看到简体中文版注册页面了，如下图:</p><p><img alt="简体中文版注册页面" data-src="/../images/TechnicalEssays/angular-i18n-demo/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E7%89%88%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2.png" class="lazyload"></p><p>注意看 url，之前的英文版是直接的<code>http://localhost:1234</code>，现在简体中文版是<code>http://localhost:1234/zh-Hans</code></p><p>如果觉得每次测试运行查看修改输入文字太长，可以修改 package.json 文件，在 script 属性下，新加一句</p><pre><code>&quot;zh-Hans&quot;: &quot;ng serve --configuration=zh-Hans -o --port 1234&quot;</code></pre><p>就可以使用<code>npm run zh-Hans</code>启动了。</p><p>后续将 angular 项目便已打包部署到服务器例如 nginx，则可以设计点击按钮切换 url，切换语言，<br>就和 MDN 一样效果。</p><p>例如<code>https://developer.mozilla.org/en-US/docs/Glossary/JavaScript</code>是英文，<br>直接修改 url 为<code>https://developer.mozilla.org/zh-CN/docs/Glossary/JavaScript</code>就变成简体了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到这里，angular i18n 多国语言使用说明就基本完了，更多的细节可以去 angular 官方<a href="https://angular.cn/guide/i18n" target="_blank" rel="noopener">国际化 i18n</a>升华。</p><p>总结一下基本步骤：</p><ol><li>准备好需要翻译的页面模板；</li><li>根据需要翻译的页面模板，创建对应的翻译源文件；</li><li>修改翻译源文件，添加<target>标签即内容；</target></li><li>修改 angular 项目的配置；</li><li>运行查看结果。</li></ol><p>源代码已放到<a href="https://github.com/Sanotsu/angular-i18n-demo" target="_blank" rel="noopener">github</a>，已经整理添加了中文繁体、中文简体、英语、百度翻译版本日语，可参考配置 angular i18n 多国语言。</p>]]></content>
      
      
      <categories>
          
          <category> angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
            <tag> i18n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Node.js项目打包为一个可执行文件</title>
      <link href="/2019/12/18/TechnicalEssays/pack-nodejs-project/"/>
      <url>/2019/12/18/TechnicalEssays/pack-nodejs-project/</url>
      
        <content type="html"><![CDATA[<p>实际上，nodejs 项目本来不需要做什么打包编译动作的，因为 js 本来也就不是编译型语言，只是个解释型语言，所以只要有 nodejs 运行环境，代码拷过去就能运行。</p><p>但是难免有些机器可能并没有安装 nodejs 运行环境，或者项目代码指定了 nodejs 的运行环境版本与实际不符合，就会多一个步骤去规整化运行环境的问题。</p><p>这本来不是个问题，那么简单打包后，变成一个可执行文件，就可以不用担心运行环境的问题了。</p><p><strong>本文目的：将 Node 项目打包为可执行文件，可以在没有安装 Node.js 运行环境的设备上运行。</strong></p><p>主要介绍两种将 nodejs 项目打包的工具，pkg 和 nexe。</p><h1 id="使用-pkg-打包-nodejs-项目（网上推荐较多）"><a href="#使用-pkg-打包-nodejs-项目（网上推荐较多）" class="headerlink" title="使用 pkg 打包 nodejs 项目（网上推荐较多）"></a>使用 pkg 打包 nodejs 项目（网上推荐较多）</h1><h2 id="注意-pkg-支持的-nodejs-版本问题"><a href="#注意-pkg-支持的-nodejs-版本问题" class="headerlink" title="注意 pkg 支持的 nodejs 版本问题"></a>注意 pkg 支持的 nodejs 版本问题</h2><p><strong>注意：pkg 各个版本所支持的 Node 版本有所不同（主要集中在长期支持版本）。</strong><br>例如最新版本之 pkg4.4 不支持 Node9 版本。</p><p>如何查看 pkg 支持的 nodejs 版本？</p><p>访问 pkg 源码 <a href="https://github.com/zeit/pkg/blob/master/package.json" target="_blank" rel="noopener">package.json</a>,在”dependencies”属性中，查看”pkg-fetch”的版本。这个 pkg-fetch 可以获取的 nodejs 版本，就是 pkg 工具包可以打包的版本。</p><p>例如现在的 pkg 默认是 4.4.2，对应的 pkg-fetch 是 2.6.4，找到 pkg-fetch 对应版本的源文件中的 patches.json 文件，地址[<a href="https://github.com/zeit/pkg-fetch/blob/master/patches/patches.json],得到以下数据：" target="_blank" rel="noopener">https://github.com/zeit/pkg-fetch/blob/master/patches/patches.json],得到以下数据：</a></p><p><img alt="查看pkg支持的nodejs版本" data-src="/../images/TechnicalEssays/pack-nodejs-project/%E6%9F%A5%E7%9C%8Bpkg%E6%94%AF%E6%8C%81%E7%9A%84nodejs%E7%89%88%E6%9C%AC.png" class="lazyload"></p><p>如果安装的 pkg 版本，和实际需要打包的 nodejs 项目的版本不同，则可能会出现类似<code>pkg error no available node version satisfies &#39;node 9&#39;</code>的报错信息。</p><p>为了节约大家的时间，秉承用新不用旧，我简单列举以下(2019/12/17 记)：</p><p>nodejs 版本为 v12、v10、v8、v6、v4、v0.12，用 pkg4.4 版本；<br>nodejs 版本为 v9，用 pkg4.3 版本；<br>nodejs 版本为 v7，用 pkg4.2 版本；</p><p>我好像没找到 pkg-fetch 中的 patches.json 有支持 nodejs v11、v5 版本的，所有就不列示了。</p><p>一般习惯，还是使用长期支持版本的 nodejs 开发为好，这样也可以直接使用最新版本的 pkg 而忽略版本问题了。</p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="全局安装："><a href="#全局安装：" class="headerlink" title="全局安装："></a>全局安装：</h3><pre><code>npm install -g pkg</code></pre><p>安装成功，输入<code>pkg -h</code>就可以看到指令信息了。</p><h3 id="一般操作说明如下："><a href="#一般操作说明如下：" class="headerlink" title="一般操作说明如下："></a>一般操作说明如下：</h3><p>pkg 的基本语法是<code>pkg [options] &lt;input&gt;</code>，那么</p><p><strong>[option] 简单说明：</strong></p><p>-t:指定打包的目标平台和 Node 版本，如-t node12-linux-x64,node12-win-x64,node12-macos-x64.<br>-c：指定一个 JSON 配置文件，用来配置额外的打包脚本或资源。<br>–options:指定 Node 或 V8 运行时选项，打包后默认执行，通过–option name 取消。<br>-o：指定输出可执行文件名称，若使用了-t 指定多个目标，则需要使用—out-path 指定输出路径。<br>-d：输出打包日志，以便排查问题。<br>-b：从 node 源代码编译 node 二进制文件，默认会下载官方预编译的文件，使用该选项便不会有前面说明的 Node 版本支持问题，初次编译会耗用大量时间。</p><p><strong>&lt;input&gt;可通过三种方式指定:</strong></p><p>项目的入口文件如：pkg app.js;<br>项目的 package.json 文件，pkg 会使用 package.json 中配置 bin 属性作为入口文件。<br>项目的路径，pkg 会寻找路径中的 package.json。</p><h3 id="打包项目："><a href="#打包项目：" class="headerlink" title="打包项目："></a>打包项目：</h3><p>我简单的生成一个 express 项目，然后用来说明打包过程</p><p>创建 express 项目（如果没有安装过 express-generator，需要先安装<code>npm install express-generator -g</code>，再使用）</p><pre><code>express node-express-demo</code></pre><p>1、首先在 package.json 中配置 bin 属性作为入口。添加以下属性（express 项目默认入口文件就是./bin/www）：</p><pre><code> &quot;bin&quot;: &quot;./bin/www&quot;</code></pre><p>如存在不能自动打包的文件（如：require（变量）、非 Javascript 文件），则需要通过 pkg 属性手动配置。同样在 package.json 中添加 pkg 属性，类似：</p><pre><code> &quot;pkg&quot;: {    &quot;scripts&quot;: [&quot;xxx&quot;,&quot;xx&quot;],    &quot;assets&quot;: [&quot;xxx&quot;,&quot;xx&quot;]  }</code></pre><p>再执行 pkg 打包命令（注意你的 os 平台和 nodejs 版本，例如我的是 ubuntu 下 nodejs12.16 版本）：</p><pre><code>david@ubuntu:~/TTT/node-express-demo$ pkg -t node12-linux-x64 -o pkg-ned -b package.json&gt; pkg@4.4.2&gt; Building base binary from source:  built-v12.13.1-linux-x64&gt; Cloning Node.js repository from GitHub...  git                          [====================] 100%&gt; Checking out v12.13.1&gt; Applying patches&gt; Compiling Node.js from sources...  make                         [====================] 100%david@ubuntu:~/TTT/node-express-demo$</code></pre><p><strong>这个首次编译打包等待时间可能会有好长，好长，好长，耐心等待一下。别看着没进度就忍不住把它终止了。</strong><br>但这是第一次执行时，后续同样的编译需求，则直接使用缓存的编译环境资源，就几秒钟了。</p><p>pkg 无法自动打包二进制模块文件，该类文件与平台有关，若依赖中包含此类文件需手动复制到打包后可执行文件目录下<br>如 node-java 有编译 nodejavabridge_bindings.node 文件，需从 node_modules/java/build/Release 中复制出来。</p><p>运行打包后文件，程序可正常运行。</p><p>为方便使用，将 pkg 打包命令写入到 package.json,打包时运行 <code>npm run pkg</code>。</p><p>在 package.json 的 script 属性下，加入一句，例如：</p><pre><code>&quot;pkg&quot;: &quot;pkg -t node12-linux-x64 -o pkg-ned -b package.json&quot;</code></pre><p>打包成功后，可以在 nodejs 项目的根目录下看见生成了 pkg-ned 文件，直接运行示例如下：</p><p><img alt="pkg打包文件运行结果" data-src="/../images/TechnicalEssays/pack-nodejs-project/pkg%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" class="lazyload"></p><p>待解决问题：<br>我之前使用成品的项目打包时没有遇到，但是这次直接使用的 express-generator 生成的模板项目打包，则出现了，运行打包后可执行文件，首页访问报错的问题，如下图：</p><p><img alt="pkg打包文件运行访问首页报错" data-src="/../images/TechnicalEssays/pack-nodejs-project/pkg%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E8%AE%BF%E9%97%AE%E9%A6%96%E9%A1%B5%E6%8A%A5%E9%94%99.png" class="lazyload"></p><p>这个问题待我找到原因再补充上。</p><h1 id="使用-nexe-打包-nodejs-项目（实际测试较好用）"><a href="#使用-nexe-打包-nodejs-项目（实际测试较好用）" class="headerlink" title="使用 nexe 打包 nodejs 项目（实际测试较好用）"></a>使用 nexe 打包 nodejs 项目（实际测试较好用）</h1><p>nexe 可以通过命令行将 Node 项目打包为可执行文件。<br><strong>值得一说的是，nexe 预编译之 Node 只有偶数版本，所以例如使用 v9 版本，只能自行编译。</strong></p><p>安装 nexe：<br>npm install -g nexe</p><p>安装成功后，终端输入 <code>nexe -h</code>就可以看到命令格式了。</p><p>一般使用格式是</p><pre><code>nexe &lt;entry-file&gt; [options]</code></pre><p><strong>简单说明[options]:</strong><br>-i：指定 Node 项目入口文件<br>-o：指定输出可执行文件路径名称<br>-t：指定編譯平臺 Node 版本（支援版本）<br>-n：指定主模块名称<br>-r：添加资源文件<br>-a：指定已构建的 nexe 二进制文件<br>–build：从源码编译 Node</p><p>最简单的使用 ，在 nodejs 项目下运行 <code>nexe &lt;入口文件&gt;</code>，例如我的是 .bin/www，但是 nodejs 版本是 9.x</p><pre><code>david@ubuntu:~/TTT/node-express-demo$ nvm use 9.11.2Now using node v9.11.2 (npm v5.6.0)david@ubuntu:~/TTT/node-express-demo$ nexe ./bin/wwwℹ nexe 3.3.2✔ Downloading pre-built Node.js✔ Finished in 1.037sError: https://github.com/nexe/nexe/releases/download/v3.0.0/linux-x64-9.11.2 is not available, create it using the --build flagSee nexe -h for usage..david@ubuntu:~/TTT/node-express-demo$</code></pre><p>因为没有 nodev9 不是预编译版本，所以报错。因此就需要使用–build，如下：</p><pre><code>nexe -i app.js -o nexe-ned -t linux-x64-9.11.2 --build</code></pre><p>需要等待一些时间，还需要联网。整个过程就是下载对应的 node 资源，然后编译，写文件。当然，这也是第一次执行时，后续同样的编译需求，则直接使用缓存的编译环境资源。</p><p>具体显示流程如下：</p><pre><code>david@ubuntu:~/TTT/node-express-demo$ nexe -i ./bin/www -o nexe-ned -t linux-x64-9.11.2 --buildℹ nexe 3.3.2✔ Node source extracted to: /home/david/.nexe/9.11.2✔ Node binary compiled✔ Entry: &#39;bin/www&#39; written to: nexe-ned✔ Finished in 2057.42sdavid@ubuntu:~/TTT/node-express-demo$</code></pre><p>运行效果如下：</p><p><img alt="运行nexe打包后文件" data-src="/../images/TechnicalEssays/pack-nodejs-project/%E8%BF%90%E8%A1%8Cnexe%E6%89%93%E5%8C%85%E5%90%8E%E6%96%87%E4%BB%B6.png" class="lazyload"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总结起来，感觉使用 nexe 效果更好一点：<br>首先没有版本限制，只是看能不能预编译(LTS 版本有预编译)；<br>额外的配置需求相对较少；<br>测试模板项目测试没有出现意外；<br>首次编译打包的时间相对较短很多。</p><p>当然这只是我的个人看法，也有人询问过 nexe 和 pkg 的<a href="https://github.com/zeit/pkg/issues/42" target="_blank" rel="noopener">区别</a>,也引用如下：</p><blockquote><p>nexe:</p><ul><li>Bundles the application if desired using webpack.</li><li>Downloads node source (or a prebuilt binary)</li><li>Adds your application bundle as a native module (like fs, http, path etc)</li><li>Applies arbitrary source patches.</li><li>Maybe compiles downloaded source</li><li>Inserts bundle into pre-sized binary</li><li>Code is run as main when executable is run (instead of the repl)</li></ul></blockquote><blockquote><p>pkg:</p><ul><li>Bundles the application with a custom v8 script compiler into a snapshot</li><li>Downloads the node source (or a prebuilt binary)</li><li>Applies arbitrary source patches</li><li>Maybe compiles downloaded source</li><li>Appends snapshotted output to the end of the binary</li><li>Snapshot (cachedData from v8) is loaded/run when binary executes.</li></ul></blockquote><p><del>(以上可窥见 pkg 打包文件首页访问出错原因)</del></p><p>不过两者都是不错的 nodejs 打包工具了，有需求都可能尝试一下。</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> pkg </tag>
            
            <tag> nexe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Verdaccio 搭建 npm 私有仓储</title>
      <link href="/2019/12/18/TechnicalEssays/verdaccio-private-registry/"/>
      <url>/2019/12/18/TechnicalEssays/verdaccio-private-registry/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 2018 年 1 月份的时候，我有开始搭建 npm 私有仓库，那个时候的 Sinopia 也已经停止维护 3 年了，而 verdaccio 还可能不是特别受欢迎，只有 1700 个 star，搭建 npm 私有仓库的工具还有不少。</p><p><img alt="2018年1月的verdaccio" data-src="/../images/TechnicalEssays/verdaccio-private-registry/2018%E5%B9%B41%E6%9C%88%E7%9A%84verdaccio.png" class="lazyload"></p><p>但在我今天写此文的时候，已经有 8.5K 的 star 了，版本也从 2.7.1 更新到了 4.4，而且基本上没有别的比较好的选择可以替代了。</p><p><del>无营养的话，两年前 sinopia 有 4318 个 star，现在还是增加为 5.3k 了，即便一直没更新，优秀的作品依旧优秀。</del></p><h1 id="安裝使用-Verdaccio（本文是在-Ubuntu-下）"><a href="#安裝使用-Verdaccio（本文是在-Ubuntu-下）" class="headerlink" title="安裝使用 Verdaccio（本文是在 Ubuntu 下）"></a>安裝使用 Verdaccio（本文是在 Ubuntu 下）</h1><p>1、安裝 verdaccio</p><p>verdaccio 是个发布在 npm 上的命令行工具。可以通过 npm 直接下载安装：</p><pre><code>npm install -g verdaccio</code></pre><p>2、開啓服務<br>verdaccio 在文件系统上存储数据，没有额外依赖，而且提供了一套默认配置，我们可以直接启动仓储服务。</p><p>在终端直接输入：</p><pre><code>verdaccio</code></pre><p><img alt="启动verdaccio" data-src="/../images/TechnicalEssays/verdaccio-private-registry/%E5%90%AF%E5%8A%A8verdaccio.png" class="lazyload"></p><p>终端上的日志显示了默认配置文件路径和 verdaccio 工作的地址端口。</p><p>3、查看安裝成功效果<br>浏览器打开<a href="http://localhost:4873/" target="_blank" rel="noopener">http://localhost:4873/</a> ，页面如下：</p><p><img alt="verdaccio启动成功画面" data-src="/../images/TechnicalEssays/verdaccio-private-registry/verdaccio%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E7%94%BB%E9%9D%A2.png" class="lazyload"></p><p>不得不说，这比两年前有自我辨识度，之前看起来就像是山寨 npmjs。</p><p>4、修改 npm 默认仓库地址</p><p>不过目前直接使用的 npm install 还是会去找 npmjs 的，所以，如果需要将默认寻找的地址改为自己的私有仓库，则需要修改 npm 默认的仓库地址，修改如下：</p><pre><code>npm set registry http://localhost:4873/</code></pre><p>查看有没有修改成功，使用<code>npm get registry</code>，查看显示的地址即可。</p><p>5、卸载 verdaccio</p><p>当然，如果不想用了，就是一个 npm 下载的工具包而已，直接卸载即可：</p><pre><code>npm uninstall -g verdaccio</code></pre><h1 id="常规的配置说明"><a href="#常规的配置说明" class="headerlink" title="常规的配置说明"></a>常规的配置说明</h1><p>配置文件一般在<code>home/{user}/.config/verdaccio/config.yaml</code>，把{user}替换成你的主机用户名。</p><p>简单说明如下（注意与实际配置对比参看）：</p><pre><code>- storage: 设置托管或缓存包的存放目录- auth: 权限控制  - htpasswd: 启用 htpasswd 插件管理权限  - file: 制定 htpasswd 文件路径，htpasswd 中存储者用户名和加密过的秘钥  - max\*users: 最多允许注册用户数- uplinks: 设置外部仓储，如果 verdaccio 找不到请求的包（非 verdaccio 托管），就会查找外部仓储。常见的有  - {name}: 外部仓储名称    - url: 访问路径    - timeout: 超时    - maxage: 默认值 2m，2m 钟内不会就同样的请求访问外部仓储    - fail\*timeout: 如果外部访问失败，在多长时间内不回重试    - headers: 添加自定义 http 头当外部仓储访问请求中，例如 authorization: &quot;Basic YourBase64EncodedCredentials==&quot;    - cache: 是否启用缓存，默认启用。      # 常用仓储有      npmjs:        url: https://registry.npmjs.org      yarnjs:        url: https://registry.yarnpkg.com      cnpmjs:        url: https://registry.npm.taobao.org- packages: 包访问或发布控制  - {regexp}: 包名匹配正则。    - access: 访问控制，可选值有      - \$all（用户不限制）,      - \$anonymous（用户不限制）,      - \$authenticated（所有登录用户）,        username( 用户名，需指定具体用户，可指定多个用户，用户间空格隔开，如 secret super-secret-area ultra-secret-area)。    - publish: 发布控制，    - proxy: 代理控制，设置的值必选现在 uplinks 中定义。    # 常用的包名正则有：    \*\*            # 匹配任意包    @\*/\_          # 匹配任意 scope 包    @npmuser/\_     # 匹配 scope 为 npmuser 的包    npmuser-\*      # 匹配包名有 npmuser- 前缀的包    # 包名正则规范通 gitignore 一致，verdaccio 内部使用 minimatch 实现的，如果需要书写更复杂的正则，可以参考 [minimatch](https://www.npmjs.com/package/minimatch/) 文档。- web: 前端展示页面控制  - title: 设置页面标题  - logo: 指定 logo 图片文件路径- publish: 发布包是的全局配置  - allow_offline: 在外部仓储离线时是否允许发布。在发布包是 verdaccio 会检查依赖包有效性，这个过程中需要访问外部仓储。- url_prefix: 设置资源文件路径前缀。默认不需要设置，但如果使用 nginx 代理并改写了请求路径，就需要指定了。  - listen: 设置服务运行地址端口，默认为 http://localhost:4873    支持的配置有：    localhost:4873              # default value    http://localhost:4873       # same thing    0.0.0.0:4873                # listen on all addresses (INADDR_ANY)    https://example.org:4873    # if you want to use https    [::1]:4873                  # ipv6    unix:/tmp/verdaccio.sock    # unix socket- https: HTTPS 证书配置  - key: path/to/server.key  - cert: path/to/server.crt  - ca: path/to/server.pem- log: 日志控制  - type: file, stdout, stderr, 其中 stdout 需要同时指定 path  - level: trace | debug | info | http (default) | warn | error | fatal  - format: json | pretty | pretty-timestamped- http_proxy: 设置以 http 形式访问外部仓储时使用的代理- https_proxy: 设置以 https 形式访问外部仓储时使用的代理- no_proxy: 不使用代理的请求路径- max_body_size: 请求时上传的 json 允许的最大值- notify: 当有包发布成功时，verdaccio 会发送通知。通知实际上是一次 http 请求。支持配置多套通知  - method: 请求方法 GET,POST 等 HTTP Method  - packagePattern: 包匹配正则， 这儿为 js 正则，仅当发布的包名匹配正则时才发送通知  - packagePatternFlags: js 正则标志位，如 i 忽略大小写  - headers: 自定义请求头  - endpoint: 请求地址  - content: handlebar 格式 html 模板，可以使用变量详见 Package Metadata</code></pre><h1 id="上传私有包"><a href="#上传私有包" class="headerlink" title="上传私有包"></a>上传私有包</h1><p>1、创建包</p><p>新建一个文件夹，并<code>npm init</code>，再创建一个 index.js 文件，内容如下图，将此包示例为个人私有包。</p><p><img alt="私有package示例文件" data-src="/../images/TechnicalEssays/verdaccio-private-registry/%E7%A7%81%E6%9C%89package%E7%A4%BA%E4%BE%8B%E6%96%87%E4%BB%B6.png" class="lazyload"></p><p>2、发布包</p><p>首先在私有仓库服务器注册一个用户，此处注册成功会自动登入仓库，输入注册语句（之前访问<code>http://localhost:4873</code>上面有显示）：</p><pre><code>david@ubuntu:~$ npm adduser --registry http://localhost:4873Username: davidPassword:Email: (this IS public) 183318×××@qq.comLogged in as david on http://localhost:4873/.david@ubuntu:~$</code></pre><p>如果之前有注册用户，此处可以直接登入</p><pre><code>david@ubuntu:~$ npm login --registry http://localhost:4873Username: davidPassword:Email: (this IS public) 183318×××@qq.comLogged in as david on http://localhost:4873/.david@ubuntu:~$</code></pre><p>登入成功之后，在刚刚创建的私有包的根目录下，运行发布包命令 npm publish，即可将包发布到私有仓库。</p><p><strong>如果没有设定本机默认的 npm 仓库是指定的私有仓库，最好还是指定仓库位置，否则有可能是发布到 npmjs 上去。</strong></p><pre><code>david@ubuntu:~/TTT/privatePackage$ npm publish --registry http://localhost:4873npm noticenpm notice 📦  privatepackage@1.0.0npm notice === Tarball Contents ===……省略一些npm notice……npm notice+ privatepackage@1.0.0david@ubuntu:~/TTT/privatePackage$</code></pre><p>发布成功之后，再访问<code>http://localhost:4873</code>页面，就能看到已发布的私有包了。</p><p><img alt="私有仓库可见私有包" data-src="/../images/TechnicalEssays/verdaccio-private-registry/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%8F%AF%E8%A7%81%E7%A7%81%E6%9C%89%E5%8C%85.png" class="lazyload"></p><p>当然后续下载使用，就和访问 npmjs 公共包是一样的。</p><h1 id="其他常用操作与配置"><a href="#其他常用操作与配置" class="headerlink" title="其他常用操作与配置"></a>其他常用操作与配置</h1><h2 id="使用-pm2-启动"><a href="#使用-pm2-启动" class="headerlink" title="使用 pm2 启动"></a>使用 pm2 启动</h2><p>verdaccio 毕竟还是一个 nodejs 程序，直接在命令行输入<code>verdaccio</code>启动了，保不齐因为何种原因崩溃。这类守护型工具，常用的就例如 forever 或者 pm2。<br>以 pm2 为例，用最简单的<code>pm2 start {program}</code>来启动。</p><p>全局安装：</p><pre><code>npm install pm2 -g</code></pre><p>使用 pm2 start。 start 后跟 verdaccio 全局安装的启动地址：</p><pre><code>pm2 start {/home/david/.nvm/versions/node/v12.6.0/lib/node_modules/verdaccio/bin/verdaccio}</code></pre><p>如果不知道自己 mpnjs 全局安装的 package 的位置，输入<code>npm config ls -l</code>；找到参数 prefix.</p><p>例如我的就是<code>prefix = &quot;/home/david/.nvm/versions/node/v12.6.0&quot;</code>.那么我的 start 的路径就是：<code>/home/david/.nvm/versions/node/v12.6.0/lib/node_modules/verdaccio/bin/verdaccio</code>，如下图：</p><p><img alt="pm2启动verdaccio" data-src="/../images/TechnicalEssays/verdaccio-private-registry/pm2%E5%90%AF%E5%8A%A8verdaccio.png" class="lazyload"></p><h2 id="浏览器显示公共包"><a href="#浏览器显示公共包" class="headerlink" title="浏览器显示公共包"></a>浏览器显示公共包</h2><p>之前有说明，如果你把 verdaccio 私有仓库设为默认仓库，如果某个 package 在私有仓库没有找到，可以设定在链接的外部仓库去寻找，例如我全局安装了一个 doctoc 工具，<code>npm install -g doctoc</code>。</p><pre><code>david@ubuntu:~$ npm i -g doctoc/home/david/.nvm/versions/node/v12.6.0/bin/doctoc -&gt; /home/david/.nvm/versions/node/v12.6.0/lib/node_modules/doctoc/doctoc.js+ doctoc@1.4.0updated 1 package in 7.961sdavid@ubuntu:~$</code></pre><p>因为我最开始，已经把 npm 的默认仓库地址改为私有地址了，又在配置文件中默认连接了 npmjs，所以执行这一句之后，<strong>首先在 verdaccio 的 storage 的位置找，找不到 doctoc，然后会去 npmjs (配置文件中的 uplinks 参数)去寻找，找到之后下载下来，也存放了一份到 storage 的位置。</strong></p><p>现在去配置文件设置的 storage 的地址，应该是可以看到 doctoc 工具包，同样可以看到之前上传的 privatepackage 私有包：</p><p><img alt="私有仓库下的私有包和公有包" data-src="/../images/TechnicalEssays/verdaccio-private-registry/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E4%B8%8B%E7%9A%84%E7%A7%81%E6%9C%89%E5%8C%85%E5%92%8C%E5%85%AC%E6%9C%89%E5%8C%85.png" class="lazyload"></p><p>当然，从安装结果可以看到，只是个索引，真实位置还是在 npm 全局安装的位置。</p><p>但是访问<code>http://localhost:4873</code>默认是不会显示的，一定程度来讲，共有的包也不必要显示在自家私有仓库内。</p><p>如果非要显示，也是可以的，修改显示的列表文件。</p><p>找到<code>.verdaccio-db.json</code>文件，默认就在私有仓库的设定 storage 的位置，verdaccio 默认位置<code>~/.local/share/verdaccio/storage/.verdaccio-db.json</code>.打开之后，把需要显示的包名，添加到 list 变量的对象中，<br>如下图：</p><p><img alt="修改.verdaccio-db.json文件" data-src="/../images/TechnicalEssays/verdaccio-private-registry/%E4%BF%AE%E6%94%B9.verdaccio-db.json%E6%96%87%E4%BB%B6.png" class="lazyload"></p><p>然后在重启 verdaccio。如果使用了 pm2，按上述说明作业，直接 <code>pm2 restart verdaccio</code>即可。如果还没有使用 pm2，直接关闭 verdaccio 的命令窗口在启动就好。</p><p>再访问<code>http://localhost:4873</code>，就可以看到 doctoc 包了，如下图：</p><p><img alt="公共包可见" data-src="/../images/TechnicalEssays/verdaccio-private-registry/%E5%85%AC%E5%85%B1%E5%8C%85%E5%8F%AF%E8%A7%81.png" class="lazyload"></p><p>以上实践有效，如果有问题，可提出交流，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> verdaccio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular Schematics 简明教程</title>
      <link href="/2019/12/12/TechnicalEssays/angular-schematics-tutorial/"/>
      <url>/2019/12/12/TechnicalEssays/angular-schematics-tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="angular-schematics-101-基本内容说明"><a href="#angular-schematics-101-基本内容说明" class="headerlink" title="angular schematics 101 :基本内容说明"></a>angular schematics 101 :基本内容说明</h1><h2 id="基础三问-angular-schematics-是什么-有什么用-怎么用"><a href="#基础三问-angular-schematics-是什么-有什么用-怎么用" class="headerlink" title="基础三问:angular schematics 是什么?有什么用?怎么用?"></a>基础三问:angular schematics 是什么?有什么用?怎么用?</h2><a id="more"></a><h3 id="angular-schematics-是什么"><a href="#angular-schematics-是什么" class="headerlink" title="angular schematics 是什么?"></a>angular schematics 是什么?</h3><p>首先要知道什么是 schematics(原理图):<br>angular 官方文档说明:</p><blockquote><p>①: 原理图是一个基于模板的支持复杂逻辑的代码生成器。它是一组通过生成代码或修改代码来转换软件项目的指令。 原理图会打包成集合（collection）并用 npm 安装。<br>②: 原理图的集合可以作为一个强大的工具，以创建、修改和维护任何软件项目，特别是当要自定义 Angular 项目以满足你自己组织的特定需求时。例如，你可以借助原理图来用预定义的模板或布局生成常用的 UI 模式或特定的组件。你也可以使用原理图来强制执行架构规则和约定，让你的项目保持一致性和互操作性。</p></blockquote><p>所以 <strong>简单来讲,angular schematics 就是 angular 生态圈中,针对 angular 项目的代码生成器。</strong></p><h3 id="所以-angular-schematics-只是模板代码生成器"><a href="#所以-angular-schematics-只是模板代码生成器" class="headerlink" title="所以 angular schematics 只是模板代码生成器?"></a>所以 angular schematics 只是模板代码生成器?</h3><p>不可否则,schematics 最主要的作用就是代码生成器.有很多模板代码结构内容都是一样的,例如 component,每次新建一个 component,都需要复制上一份的代码进行修改.</p><p>angular-cli 默认有一些可以按照模板生成的组件,例如 componet、router、service、interceptor 等等，这也是很多插件工具一键生成模板代码的依据。但是并不是所有代码都适合所有开发者。例如有些使用者常与 CURD 打交道，所以希望生成的 service 直接包含所有的 CRUD 函数，输入不同的名称对应生成不同产品。等等各自自适应、自构建的模板。</p><p>除此之外，它还能用于按照一定规则修改程式代码、快速按照所需模块等，就如引用的 angular 官方文档说明的第 ② 点。毕竟至少对应到了 ng generate 、 ng add 和 ng update 指令。</p><h3 id="简单上手-angular-schematics：创建一个-hello"><a href="#简单上手-angular-schematics：创建一个-hello" class="headerlink" title="简单上手 angular schematics：创建一个 hello"></a>简单上手 angular schematics：创建一个 hello</h3><p>1、全局安装 schematics cli（需要 node 6.9 以上版本）</p><pre><code>npm install -g @angular-devkit/schematics-cli</code></pre><p>安装完成之后，可以在终端输入<code>schmatics</code>命令，能显示 schematics 的指令说明则表示安装成功。</p><p>2、创建一个空的原理图</p><pre><code>schematics blank --name=hello</code></pre><p>生成的原理图中基本内容结构可参看官网说明<a href="https://angular.cn/guide/schematics-authoring#collection-contents" target="_blank" rel="noopener">集合的内容</a>和<a href="https://angular.cn/guide/schematics-authoring#named-schematics" target="_blank" rel="noopener">命名原理图</a><br>简单说明如下：<br><img alt="schematics說明.png" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/schematics%E8%AF%B4%E6%98%8E.png" class="lazyload"><br><img alt="保持一致" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4.png" class="lazyload"></p><p>collection.json 配置一般一个原理图就只配置一次，所以大部分内容都是在 index.ts 中实现，所以，一定先清楚这个文件的内容：<br>具体可以参看官方说明<a href="https://angular.cn/guide/schematics-authoring#schematics-concepts" target="_blank" rel="noopener">原理图的概念</a><br>简单说明如下：<br><img alt="原理图基本概念說明" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/%E5%8E%9F%E7%90%86%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E.png" class="lazyload"></p><p>3、运行原理图<br>因为创建的是一个空白原理图，运行是不会有任何输出显示的。</p><p>3.1 在当前位置运行：<br>先构建：</p><pre><code>npm run build</code></pre><p>再运行</p><pre><code>schematics .:hello</code></pre><p>简单说明：<br>ts 代码在编译之后转换成 js 代码才能运行，在原理图中，在执行<code>npm run build</code>之后，<br>会出现其他的 XXX.d.ts、XXX.js、XXX.js.map。<br>运行时，<code>.:hello</code>的<code>.</code>是当前位置，<code>hello</code>则是在 collection.json 中配置的原理图的名字。<br>当然，一份 collection.json 中可以配置多个原理图，所以要指定使用的是哪一个。</p><p>“Nothing to be done.”显然没有任何意义，我们可以在 index.ts 中加入一句打印，看看效果：</p><pre><code>export function hello(_options: any): Rule {  return (tree: Tree, _context: SchematicContext) =&gt; {    console.log(&quot;hello&quot;);    return tree;  };}</code></pre><p>那么再次编译运行之后，就可以看到输入的是：</p><pre><code>david@ubuntu:~/TTT/hello$ schematics .:hellohelloNothing to be done.david@ubuntu:~/TTT/hello$</code></pre><p>3.2 在相对路劲下运行<br>如果现在不在 hello 下运行了，那么就不能直接.:<schematics-name>了，需要找到该原理图的 collection.json 文件，并指定使用哪一个。<br>例如在 hello 同级目录下新建个 test 文件夹，在 test 中运行则是：</schematics-name></p><pre><code>david@ubuntu:~/TTT/test$ schematics ../hello/src/collection.json:hellohelloNothing to be done.david@ubuntu:~/TTT/test$</code></pre><p>以上就是 angular schematics 的基础说明和运行，是不是毫无实际意义？没错。接下来，我们开始进入有点实际作用的内容。</p><h1 id="angular-schematics-实现-ng-generator-使用模板生成组件"><a href="#angular-schematics-实现-ng-generator-使用模板生成组件" class="headerlink" title="angular schematics 实现 ng generator 使用模板生成组件"></a>angular schematics 实现 ng generator 使用模板生成组件</h1><p>本节会实现，在 angular 项目中，使用 ng generator 指令生成一个通用的 component 组件，和一般向后台请求数据需要包含 CRUD 函数的 service 组件。here we go。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>新建一个空白 schematics，如下：</p><pre><code>schematics blank --name=angular-schematics-tutorial</code></pre><p>将原本的内容：</p><p><img alt="空白項目修改前" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/%E7%A9%BA%E7%99%BD%E9%A0%85%E7%9B%AE%E4%BF%AE%E6%94%B9%E5%89%8D.png" class="lazyload"></p><p>修改为：</p><p><img alt="修改后" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/%E4%BF%AE%E6%94%B9%E5%90%8E.png" class="lazyload"><br>为了方便，不用每次修改都运行 build，在此项目的 package.json 的 script 加入一行：</p><pre><code>&quot;build:watch&quot;: &quot;tsc -p tsconfig.json --watch&quot;</code></pre><p>使得该项目一致在 watch 状态下，然后运行</p><pre><code>npm run build:watch</code></pre><p>准备工作完成，进入正题。</p><h2 id="实现创建通用-component-组件"><a href="#实现创建通用-component-组件" class="headerlink" title="实现创建通用 component 组件"></a>实现创建通用 component 组件</h2><p>一般每个命令原理图都包含以下内容：</p><blockquote><p>index.ts： 定义命名原理图中转换逻辑的代码。<br>schema.json： 原理图变量定义。<br>schema.d.ts： 原理图变量。<br>files/： 要复制的可选组件/模板文件。</p></blockquote><p>我们的也不例外。</p><h3 id="创建-component-文件模板-template"><a href="#创建-component-文件模板-template" class="headerlink" title="创建 component 文件模板 template"></a>创建 component 文件模板 template</h3><p>一般 angular component 会包含 4 个文件：XXX.html，XXX.scss，XXX.spec.ts，XXX.ts。所以，先准备好这些模板。</p><p>在/component 文件夹下新建 files 文件夹，并创建以下 4 个文件，效果如下：</p><p><img alt="component的模板文件" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/component%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6.png" class="lazyload"></p><p>简单说明两个函数：</p><blockquote><p>classify() 方法接受一个值，并返回标题格式（title case）的值。比如，如果提供的名字是 my service，它就会返回 MyService。<br>dasherize() 方法接受一个值，并以中线分隔并小写的形式返回值。比如，如果提供的名字是 MyService，它就会返回 “my-service” 的形式。</p></blockquote><p>此 component 模块的效果就是，在新建一个 component 时，输入 component 的名字，例如 apple，则会在该 angular 项目的 src/app/下，新建一个文件夹 apple，下面 4 个文件 apple.component.html， apple.component.scss，apple.component.spec.ts，apple.component.ts。</p><p>模板内容分别如下：<br><code>__name@dasherize__.component.html.template文件：</code></p><pre><code>&lt;p&gt;  &lt;%= dasherize(name) %&gt; works!&lt;/p&gt;</code></pre><p><code>__name@dasherize__.component.spec.ts.template文件：</code></p><pre><code>/* tslint:disable:no-unused-variable */import { async, ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;import { By } from &#39;@angular/platform-browser&#39;;import { DebugElement } from &#39;@angular/core&#39;;import { &lt;%= classify(name) %&gt;Component } from &#39;./&lt;%= dasherize(name) %&gt;.component&#39;;describe(&#39;&lt;%= classify(name) %&gt;Component&#39;, () =&gt; {  let component: &lt;%= classify(name) %&gt;Component;  let fixture: ComponentFixture&lt;&lt;%= classify(name) %&gt;Component&gt;;  beforeEach(async(() =&gt; {    TestBed.configureTestingModule({      declarations: [&lt;%= classify(name) %&gt;Component]    })      .compileComponents();  }));  beforeEach(() =&gt; {    fixture = TestBed.createComponent(&lt;%= classify(name) %&gt;Component);    component = fixture.componentInstance;    fixture.detectChanges();  });  it(&#39;should create&#39;, () =&gt; {    expect(component).toBeTruthy();  });});</code></pre><p><code>__name@dasherize__.component.ts.template文件：</code></p><pre><code>import { Component, OnInit } from &#39;@angular/core&#39;;@Component({  selector: &#39;app-&lt;%= dasherize(name) %&gt;&#39;,  templateUrl: &#39;./&lt;%= dasherize(name) %&gt;.component.html&#39;,  styleUrls: [&#39;./&lt;%= dasherize(name) %&gt;.component.scss&#39;]})export class &lt;%=classify(name)%&gt;Component implements OnInit {  constructor() { }  ngOnInit() {  }}</code></pre><p>scss 部分就没有必要了。<br>此部分内容，可参考 angular-cli 源代码内容：<a href="https://github.com/angular/angular-cli/tree/master/packages/schematics/angular/component/files/__name%40dasherize%40if-flat__" target="_blank" rel="noopener">angular-cli component 组件模板</a></p><h3 id="配置-schema-json-定义该原理图可用选项"><a href="#配置-schema-json-定义该原理图可用选项" class="headerlink" title="配置 schema.json,定义该原理图可用选项"></a>配置 schema.json,定义该原理图可用选项</h3><p>在 component 文件夹下新建 schema.json，并输入以下内容：</p><pre><code>{    &quot;$schema&quot;: &quot;http://json-schema.org/schema&quot;,    &quot;id&quot;: &quot;componentSchema&quot;,    &quot;title&quot;: &quot;component options schema.&quot;,    &quot;type&quot;: &quot;object&quot;,    &quot;descripiton&quot;: &quot;创建一个component范本&quot;,    &quot;properties&quot;: {        &quot;name&quot;: {            &quot;description&quot;: &quot;component的名字.&quot;,            &quot;type&quot;: &quot;string&quot;,            &quot;$default&quot;: {                &quot;$source&quot;: &quot;argv&quot;,                &quot;index&quot;: 0            },            &quot;x-prompt&quot;: &quot;你想创建的component的名字:&quot;        }    },    &quot;required&quot;: [        &quot;name&quot;    ]}</code></pre><p>属性说明：</p><blockquote><p>id：这个模式定义在集合中的唯一 id。<br>title：一个人类可读的模式描述。<br>type：由这些属性提供的类型描述符。<br>properties：一个定义该原理图可用选项的对象。<br>required：必填的选项</p></blockquote><p>注意属性(proerties)选项：<br>　　$default 的设定，上面的表示，如果没有指定输入的选项，那么输入的第一个就是 name<br>　　 x-prompt：如果没有输入选项，则提示语提示输入</p><p><strong>创建好 schema.json 之后，一定要记得在 collection.json 中配置 schema 属性</strong></p><p><img alt="在collection中配置schema" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/%E5%9C%A8collection%E4%B8%AD%E9%85%8D%E7%BD%AEschema.png" class="lazyload"></p><h3 id="创建-schema-d-ts-定义的各个选项的值"><a href="#创建-schema-d-ts-定义的各个选项的值" class="headerlink" title="创建 schema.d.ts,定义的各个选项的值"></a>创建 schema.d.ts,定义的各个选项的值</h3><p>一般的，可以手动创建 schema.d.ts，如本生成 component 的原理图，它的 schema.json 中属性只有一个必填的 name，那么编写的 schema.d.ts 内容就如下：</p><pre><code>export interface Schema {    name: string;}</code></pre><p>实际上，这个文件可以使用指令生成，在 schema.json 的同级目录下，开启终端输入指令，如下：</p><pre><code>npx -p dtsgenerator dtsgen schema.json -o schema.d.ts</code></pre><p>效果如下<br><img alt="自动生成schema.d.ts文件.png" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90schema.d.ts%E6%96%87%E4%BB%B6.png" class="lazyload"></p><p>但注意，<strong>生成之后把 declare 改成 export</strong>，因为需要把这接口导出使用。</p><h3 id="编写规则工厂逻辑代码"><a href="#编写规则工厂逻辑代码" class="headerlink" title="编写规则工厂逻辑代码"></a>编写规则工厂逻辑代码</h3><p>以上都定义完之后，便到了最重要的环节，编写逻辑代码实现 componet 组件的生成。</p><p>简单分析，至少我们有以下几步工作需要完成：<br>第一步：判断目标项目是不是 angular 项目。如果不在 angular 项目中去生成 angular 的 componet，那就没什么意义。这一步可以提出来通用。<br>　　同理，@schematics 对 angular 有很多的已有支持，我们这里可以用到一些便捷的方法，所以需要先安装@schematics/angular，输入指令如下：</p><pre><code>npm install @schematics/angular -S</code></pre><p>第二步：读取预设的模板 template 文件，并将使用者输入选项应用到模板。<br>第三步：合并模板文件，返回新的 tree。</p><p>修改 index.ts 代码具体如下：</p><pre><code>import {  Rule, SchematicContext, Tree,  apply, mergeWith, url,  move,  applyTemplates, SchematicsException} from &#39;@angular-devkit/schematics&#39;;import { strings } from &#39;@angular-devkit/core&#39;;import { ComponentSchema as Schema } from &#39;./schema&#39;import { buildDefaultPath } from &#39;@schematics/angular/utility/project&#39;;import { parseName } from &#39;@schematics/angular/utility/parse-name&#39;;export function genComponent(_options: Schema): Rule {  return (tree: Tree, _context: SchematicContext) =&gt; {    // 获取到在angular cli工作区下的 路劲和要生成的组件 前缀name    const { name, path } = getParsePath(tree, _options);    // 读取模板文件    const sourceTemplates = url(&#39;./files&#39;);    // 应用模板文件    const sourceParametrizedTemplates = apply(sourceTemplates, [      applyTemplates({        ..._options,        ...strings,        name      }),      move(path)    ]);    // 将传入的值(option)与模板文件合并(传入值替代模板变量值)    return mergeWith(sourceParametrizedTemplates)(tree, _context);  };}function getParsePath(tree: Tree, options: any): any {  // 读取angular.json文件并存为buffer  const workspaceConfigBuffer = tree.read(&quot;angular.json&quot;)  // 判断是不是在一个angular-cli工作区  if (!workspaceConfigBuffer) {    throw new SchematicsException(&#39;不在angular cli工作区,请在angular项目中执行!&#39;)  }  // 读取并整理angular配置  const workspaceConfig = JSON.parse(workspaceConfigBuffer.toString());  // 有传入project属性或者是默认project  const projectName = options.project || workspaceConfig.defaultProject;  // 获取project定义  const project = workspaceConfig.projects[projectName];  // 获取默认project路径  const defaultProjectPath = buildDefaultPath(project);  // parseName()可以把路径和文件名拆开,取得path和name  // 例如 src/feartures/login,会被拆分为 path:src/features 和 name:login  const parsePath = parseName(defaultProjectPath, options.name);  return parsePath;}</code></pre><p>像上述的<code>buildDefaultPath</code>，<code>parseName</code>方法就是@schematics/angular 中提供的。</p><h3 id="编写测试用例测试代码"><a href="#编写测试用例测试代码" class="headerlink" title="编写测试用例测试代码"></a>编写测试用例测试代码</h3><p>这个测试方面的内容也是个大项，这里就不多说明，简单说一下我们的测试用例。<br>我的测试就是模拟生成一个 angular 项目，然后看看是否在里面生成了 component 的那 4 个文件，若有生成，那么通过，否则就失败。<br>修改 index_spec.ts 代码如下：</p><pre><code>import * as path from &#39;path&#39;;import { SchematicTestRunner, UnitTestTree } from &#39;@angular-devkit/schematics/testing&#39;;import { Schema as ApplicationOptions, Style } from &#39;@schematics/angular/application/schema&#39;;import { Schema as WorkspaceOptions } from &#39;@schematics/angular/workspace/schema&#39;;import { strings } from &#39;@angular-devkit/core&#39;;const collectionPath = path.join(__dirname, &#39;../collection.json&#39;);describe(&#39;component&#39;, () =&gt; {  // 选项 --name的值  const name = &#39;apple&#39;;  const runner = new SchematicTestRunner(&#39;schematics&#39;, collectionPath);  // 模拟ng new创建angular项目，主要对workspace和application进行配置  // angular项目的配置  const workspaceOptions: WorkspaceOptions = {    name: &#39;workspace&#39;,              // 不重要的名字，随意取，不影响测试结果    newProjectRoot: &#39;projects&#39;,     // 项目app的根目录，可以随意取，但是验证会用到    version: &#39;6.0.0&#39;,               // 版本号，随意，不影响测试  };  const appOptions: ApplicationOptions = {    name: &#39;component&#39;,              // 项目名称    inlineStyle: false,             // 以下是项目属性，随意true/false，不影响测试结果    inlineTemplate: false,    routing: false,    style: Style.Css,    skipTests: false,    skipPackageJson: false,  };  // 调用 SchematicTestRunner 的 runExternalSchematicAsync 方法，并以给出的参数生成angular项目  let appTree: UnitTestTree;  beforeEach(async () =&gt; {    appTree = await runner.runExternalSchematicAsync(      &#39;@schematics/angular&#39;,      &#39;workspace&#39;,      workspaceOptions    ).toPromise();    appTree = await runner.runExternalSchematicAsync(      &#39;@schematics/angular&#39;,      &#39;application&#39;,      appOptions,      appTree    ).toPromise();  });  // 最基本的判断,如果生成的文件名和预期生成的文件名一致,就验证成功  it(&#39;works&#39;, async () =&gt; {    // runSchematicAsync()参数：项目名、参数、Tree    const tree = await runner.runSchematicAsync(&#39;component&#39;, { name }, appTree).toPromise();    const dasherizeName = strings.dasherize(name);    /* 以下其实可以直接4个toContain代替*/    // 预期生成的文件    const expectFiles = [      `/projects/component/src/app/${dasherizeName}/${dasherizeName}.component.ts`,      `/projects/component/src/app/${dasherizeName}/${dasherizeName}.component.html`,      `/projects/component/src/app/${dasherizeName}/${dasherizeName}.component.scss`,      `/projects/component/src/app/${dasherizeName}/${dasherizeName}.component.spec.ts`,    ]    // 如果实际模拟的angular项目中拥有预期生成的文件,则将它从expectFiles中移除    for (const v of tree.files) {      for (let i = 0; i &lt; expectFiles.length; i++) {        const e = expectFiles[i];        if (v.toString() === e) {          expectFiles.splice(i, 1);        }      }    }    //如果预期生成的文件都有生成,那么预期的应该是0=0成立    expect(0).toEqual(expectFiles.length);  });});</code></pre><p>运行测试用例就很简单了，直接<code>npm run test</code>，如果测试成功，终端应该如下输出：</p><pre><code>david@ubuntu:~/TTT/angular-schematics-tutorial$ npm run test&gt; angular-schematics-tutorial@0.0.0 test /home/david/TTT/angular-schematics-tutorial&gt; npm run build &amp;&amp; jasmine src/**/*_spec.js&gt; angular-schematics-tutorial@0.0.0 build /home/david/TTT/angular-schematics-tutorial&gt; tsc -p tsconfig.jsonRandomized with seed 66156Started.1 spec, 0 failuresFinished in 0.369 secondsRandomized with seed 66156 (jasmine --random=true --seed=66156)david@ubuntu:~/TTT/angular-schematics-tutorial$</code></pre><h3 id="实际-angular-项目运行"><a href="#实际-angular-项目运行" class="headerlink" title="实际 angular 项目运行"></a>实际 angular 项目运行</h3><p>测试用例通过可能很好，但最好还是去实际项目中测试一下，向生成一个 angular 项目：</p><pre><code>ng new angular-demo</code></pre><p>在该 angular-demo 项目中运行指令<code>angular-demo$ schematics ../angular-schematics-tutorial/src/</code>，可以看到结果如下：</p><pre><code>david@ubuntu:~/TTT/angular-demo$ schematics ../angular-schematics-tutorial/src/collection.json:component --debug=false? 你想创建的component的名字: comp/appleCREATE /src/app/comp/apple/apple.component.html (23 bytes)CREATE /src/app/comp/apple/apple.component.scss (0 bytes)CREATE /src/app/comp/apple/apple.component.spec.ts (755 bytes)CREATE /src/app/comp/apple/apple.component.ts (607 bytes)david@ubuntu:~/TTT/angular-demo$</code></pre><p>简单说明：<br><strong>其中指令 –debug=false 是为了实际生成文件，如果不加这一句，不会生成实际的文件。</strong><br>因为没有直接输入<code>--name=comp/apple</code>或者直接<code>comp/apple</code>,所以出现了输入提示语。直接输入 <code>schematics ../angular-schematics-tutorial/src/collection.json:component --name=comp/apple --debug=false</code>则不会出现提示语。</p><p>注意：如果已有同位置同名文件，再次生成会报错，提示<code>already exists.</code>。</p><p>我们查看生成的 component 组件模块内容：<br><img alt="生成的componet组件内容" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/%E7%94%9F%E6%88%90%E7%9A%84component%E7%BB%84%E4%BB%B6%E5%85%A7%E5%AE%B9.png" class="lazyload"></p><p>可以看到，文件有实际生成，模板内容有被替换。</p><p>恭喜，如果到这里都正确，那么已经完成了自定义原理图的制作和使用了。</p><p>所以，想要生成一个具有 CRUD 函数的 service 步骤效果就是一样的，不再赘述，具体可参看代码。</p><p>理论上，一个原理图项目(schematics)可以有很多个原理图(schematic)，但是要在 collection 中统一指定配置。</p><p>总结制作原理图的一般步骤：<br>　　 1、新建原理图使用模板文件；<br>　　 2、创建该原理图需要的 schema.json 并将该原理图配置到 collection.json；<br>　　 3、依照 schema.json 创建接口 schema.d.ts；<br>　　 4、在 index.ts 中编写实现该原理图目的的逻辑代码；<br>　　 5(非必须)、编写测试用例进行测试；<br>　　 6(测试)、利用测试用例或实际项目进行测试。</p><h1 id="angular-schematics-实现-ng-add-指令安装模块"><a href="#angular-schematics-实现-ng-add-指令安装模块" class="headerlink" title="angular schematics 实现 ng add 指令安装模块"></a>angular schematics 实现 ng add 指令安装模块</h1><p>ng add 有什么用？</p><blockquote><p>将对外部库的支持添加到您的项目中。</p></blockquote><p>如何使用？</p><blockquote><p>ng add <collection> [options]</collection></p></blockquote><p>但是实际上，这个能够直接使用 ng add 也是应该这个需要添加的库，内部实现了对此原理图的功能。</p><p>举个例子，众所周知，angular material 可以直接使用 ng add 添加到已有的 angular 专案。执行<code>ng add @angular/material</code>。</p><p>效果如下：</p><p><img alt="添加angular material到angular项目" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/%E6%B7%BB%E5%8A%A0angular-material%E5%88%B0%E9%A1%B9%E7%9B%AE.gif" class="lazyload"></p><p>但是，如果我想添加 Font Awesome 到 angular 项目，你就需要</p><pre><code>npm install @fortawesome/fontawesome-svg-corenpm install @fortawesome/free-solid-svg-iconsnpm install @fortawesome/angular-fontawesome@&lt;version&gt;</code></pre><p>然后手动引入模块,声明使用等等操作。</p><p>为什么不能使用 ng add？<br>你看：  </p><p><img alt="沒有schematics的库只执行了安裝" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/%E6%B2%92%E6%9C%89schematics%E7%9A%84%E5%BA%93%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%BA%86%E5%AE%89%E8%A3%9D.png" class="lazyload"></p><p>font awesome 不支持直接的 ng add,因为 package 中没有实现导入等作业，所以只执行了安装。</p><p>所以本节的目标，就是编写一个原理图，实现 ng add 的时候<br>1、一次性安装以上 3 个 package，<br>2、在 app.module.ts 中引入 FontAwesomeModule<br>3、在 app.component.ts 声明并在 app.component.html 实例化。</p><h2 id="创建-ng-add-的-schema-json-并配置"><a href="#创建-ng-add-的-schema-json-并配置" class="headerlink" title="创建 ng add 的 schema.json 并配置"></a>创建 ng add 的 schema.json 并配置</h2><p>在与之前 component 文件夹同级的路径下，创建 ng-add 文件夹。</p><p>在 ng-add 文件夹下创建 schema.json 文件，并编写如下内容：</p><pre><code>{    &quot;$schema&quot;: &quot;http://json-schema.org/schema&quot;,    &quot;id&quot;: &quot;NgAddSchema&quot;,    &quot;title&quot;: &quot;Ng-Add Schema&quot;,    &quot;type&quot;: &quot;object&quot;,    &quot;description&quot;: &quot;给angular项目添加 Font-Awesome。&quot;,    &quot;properties&quot;: {        &quot;project&quot;: {            &quot;type&quot;: &quot;string&quot;,            &quot;description&quot;: &quot;给angular项目添加 Font-Awesome。&quot;        }    }}</code></pre><p>在 collection.json 中的 “schematics”添加子项，内容如下：</p><pre><code>&quot;ng-add&quot;: {  &quot;description&quot;: &quot;给angular项目中添加 Font-Awesome库。&quot;,  &quot;factory&quot;: &quot;./ng-add&quot;,  &quot;schema&quot;: &quot;./ng-add/schema.json&quot;}</code></pre><p>注意名称保持 ng-add。</p><h2 id="生成并导出-schema-d-ts-文件"><a href="#生成并导出-schema-d-ts-文件" class="headerlink" title="生成并导出 schema.d.ts 文件"></a>生成并导出 schema.d.ts 文件</h2><p>schema.d.ts 文件内容大概如下：</p><pre><code>/** * Ng-Add Schema * 给angular项目添加 Font-Awesome。 */export interface NgAddSchema {    /**     * 给angular项目添加 Font-Awesome。     */    project?: string;}</code></pre><h2 id="编写规则工厂实现逻辑代码"><a href="#编写规则工厂实现逻辑代码" class="headerlink" title="编写规则工厂实现逻辑代码"></a>编写规则工厂实现逻辑代码</h2><p>在文件夹 ng-add 下新建 index.ts 文件，并写入以下代码：</p><pre><code>import { Rule, SchematicContext, Tree, SchematicsException } from &#39;@angular-devkit/schematics&#39;;import { buildDefaultPath } from &#39;@schematics/angular/utility/project&#39;;import { NodePackageInstallTask } from &#39;@angular-devkit/schematics/tasks&#39;;import { NgAddSchema } from &#39;./schema&#39;;import { addImportToModule } from &#39;@schematics/angular/utility/ast-utils&#39;;import { InsertChange } from &#39;@schematics/angular/utility/change&#39;;import * as ts from &#39;@schematics/angular/third_party/github.com/Microsoft/TypeScript/lib/typescript&#39;;export default function (_options: NgAddSchema): Rule {    return (_tree: Tree, _context: SchematicContext) =&gt; {        // 如果不是 Angular 项目则抛出错误        const workspaceConfigBuffer = _tree.read(&#39;angular.json&#39;);        if (!workspaceConfigBuffer) {            throw new SchematicsException(&#39;Not an Angular CLI workspace&#39;);        }        // 取得 project 的根目录        const workspaceConfig = JSON.parse(workspaceConfigBuffer.toString());        const projectName = _options.project || workspaceConfig.defaultProject;        const project = workspaceConfig.projects[projectName];        const defaultProjectPath = buildDefaultPath(project);        //将 FortAwesomeModule 加入 AppModule        const modulePath = `${defaultProjectPath}/app.module.ts`;        const sourceFile = readIntoSourceFile(_tree, modulePath);        const importPath = &#39;@fortawesome/angular-fontawesome&#39;;        const moduleName = &#39;FontAwesomeModule&#39;;        const declarationChanges = addImportToModule(sourceFile, modulePath, moduleName, importPath);        const declarationRecorder = _tree.beginUpdate(modulePath);        for (const change of declarationChanges) {            if (change instanceof InsertChange) {                declarationRecorder.insertLeft(change.pos, change.toAdd);            }        }        _tree.commitUpdate(declarationRecorder);        // 将某个 icon 引入到 app.component.ts，再到 app.component.html 中使用它。（声明并实例化）        // 获取 app.component.ts 的 AST        const componentPath = `${defaultProjectPath}/app.component.ts`;        const componentSourceFile = readIntoSourceFile(_tree, componentPath);        // 取得所有的 ImpotDeclaration        const allImports = componentSourceFile.statements.filter(node =&gt; ts.isImportDeclaration(node))! as ts.ImportDeclaration[];        // 找到最后一个 ImpotDeclaration        let lastImport: ts.Node | undefined;        for (const importNode of allImports) {            if (!lastImport || importNode.getStart() &gt; lastImport.getStart()) {                lastImport = importNode;            }        }        // 找到 ClassDeclaration        const classDeclaration = componentSourceFile.statements.find(node =&gt; ts.isClassDeclaration(node))! as ts.ClassDeclaration;        // 取得所有的 property        const allProperties = classDeclaration.members.filter(node =&gt; ts.isPropertyDeclaration(node))! as ts.PropertyDeclaration[];        // 取得最后一个 propery        let lastProperty: ts.Node | undefined;        for (const propertyNode of allProperties) {            if (!lastProperty || propertyNode.getStart() &gt; propertyNode.getStart()) {                lastProperty = propertyNode;            }        }        const componentRecorder = _tree.beginUpdate(componentPath);        const importFaCoffee = &#39;\nimport { faCoffee } from \&#39;@fortawesome/free-solid-svg-icons\&#39;;&#39;;        componentRecorder.insertLeft(lastImport!.end, importFaCoffee);        // 添加声明部分的代码        const faCoffeeProperty = &#39;faCoffee = faCoffee;&#39;        const changeText = lastProperty ? lastProperty.getFullText() : &#39;&#39;;        let toInsert = &#39;&#39;;        if (changeText.match(/^\r?\r?\n/)) {            toInsert = `${changeText.match(/^\r?\n\s*/)![0]}${faCoffeeProperty}`;        } else {            toInsert = `\n  ${faCoffeeProperty}\n`;        }        // 插入字串        if (lastProperty) {            componentRecorder.insertLeft(lastProperty!.end, toInsert);        } else {            componentRecorder.insertLeft(classDeclaration.end - 1, toInsert);        }        _tree.commitUpdate(componentRecorder);        //在 app.component.html 里面加上 &lt;fa-icon [icon]=&quot;faCoffee&quot;&gt;&lt;/fa-icon&gt; ：        const htmlPath = `${defaultProjectPath}/app.component.html`;        const htmlStr = `\n&lt;fa-icon [icon]=&quot;faCoffee&quot;&gt;&lt;/fa-icon&gt;\n`;        const htmlSourceFile = readIntoSourceFile(_tree, htmlPath);        const htmlRecorder = _tree.beginUpdate(htmlPath);        htmlRecorder.insertLeft(htmlSourceFile.end, htmlStr);        _tree.commitUpdate(htmlRecorder);        // 修改 package.json        const dependencies = [            { name: &#39;@fortawesome/fontawesome-svg-core&#39;, version: &#39;~1.2.25&#39; },            { name: &#39;@fortawesome/free-solid-svg-icons&#39;, version: &#39;~5.11.2&#39; },            { name: &#39;@fortawesome/angular-fontawesome&#39;, version: &#39;~0.5.0&#39; }        ];        dependencies.forEach(dependency =&gt; {            addPackageToPackageJson(                _tree,                dependency.name,                dependency.version            );        });        // 使用 Schematic安装3个依赖 Package 。        // 使用Angular Schematics 的 API - NodePackageInstallTask 。        _context.addTask(            new NodePackageInstallTask({                packageName: dependencies.map(d =&gt; d.name).join(&#39; &#39;)            })        );        return _tree;    };};//读取文件function readIntoSourceFile(host: Tree, modulePath: string): ts.SourceFile {    const text = host.read(modulePath);    if (text === null) {        throw new SchematicsException(`File ${modulePath} does not exist.`);    }    const sourceText = text.toString(&#39;utf-8&#39;);    return ts.createSourceFile(modulePath, sourceText, ts.ScriptTarget.Latest, true);}// 给package.json添加依赖包function addPackageToPackageJson(host: Tree, pkg: string, version: string): Tree {    if (host.exists(&#39;package.json&#39;)) {        const sourceText = host.read(&#39;package.json&#39;)!.toString(&#39;utf-8&#39;);        const json = JSON.parse(sourceText);        if (!json.dependencies) {            json.dependencies = {};        }        if (!json.dependencies[pkg]) {            json.dependencies[pkg] = version;            json.dependencies = sortObjectByKeys(json.dependencies);        }        host.overwrite(&#39;package.json&#39;, JSON.stringify(json, null, 2));    }    return host;}// 对象key排序function sortObjectByKeys(obj: any) {    return Object.keys(obj).sort().reduce((result, key) =&gt; (result[key] = obj[key]) &amp;&amp; result, {} as any);}</code></pre><p>代码不用细读，大约做了以下几件事：</p><p>1、判断是不是 angular 项目<br>2、获取 angular.json 中参数配置<br>3、在 app.module.ts 中引入 FontAwesomeModule<br>4、在 app.component.ts 声明一个 Font<br>5、在 app.component.html 实例化。<br>6、修改模板项目 package.json 依赖列表，加入那 3 个库；<br>7、实现那 3 个库的安装。<br>……</p><h2 id="测试并使用"><a href="#测试并使用" class="headerlink" title="测试并使用"></a>测试并使用</h2><p>如果需要写测试用例，那么可以 ng-add 文件夹下添加 index_spec.ts 并写代码(可参看源码)</p><p>直接在 angular 项目中实践：<br><img alt="ng add的效果" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/ngadd%E7%9A%84%E6%95%88%E6%9E%9C.png" class="lazyload"></p><p>如果到这里都正常，那么恭喜你，自定义原理库实现 ng add 也成功了！</p><h1 id="angular-schematics-实现-ng-update-更新模块时修改指定组件内容"><a href="#angular-schematics-实现-ng-update-更新模块时修改指定组件内容" class="headerlink" title="angular schematics 实现 ng update 更新模块时修改指定组件内容"></a>angular schematics 实现 ng update 更新模块时修改指定组件内容</h1><p>上面 2 节分别实现了 ng generator 和 ng add，那么接下来就是 ng update 了。<br>关于 angular schematics 自定义 ng update 的实践目前网上找的示例都比较少，还不是很清晰。我们这里也会做个实例，但是不会深究。</p><p>ng update 有什么用？</p><blockquote><p>更新您的应用程序及其依赖项。</p></blockquote><p>如何使用？</p><blockquote><p>ng update [options]</p></blockquote><p>一般的，如果你的 angular 项目是老旧版本的，运行<code>ng update</code>指令，可能就会出现类似以下的内容：</p><pre><code>Using package manager: &#39;npm&#39;Collecting installed dependencies...Found 33 dependencies.    We analyzed your package.json, there are some packages to update:      Name                               Version                  Command to update     --------------------------------------------------------------------------------      @angular/cdk                       8.1.4 -&gt; 8.2.3           ng update @angular/cdk      @angular/cli                       8.3.0 -&gt; 8.3.20          ng update @angular/cli      @angular/core                      8.2.3 -&gt; 8.2.14          ng update @angular/core      @angular/material                  8.1.4 -&gt; 8.2.3           ng update @angular/material      rxjs                               6.4.0 -&gt; 6.5.3           ng update rxjs</code></pre><p>大家可以仔细看看，这份分析结果说明了什么？<br>一共有 33 个依赖，但是只有 5 个可以使用 ng update 升级？<br>从哪里看出哪些依赖能用 ng update 升级？各个依赖包的 package.json</p><p>ug update 的原理逻辑还是比较复杂了，其实直接看 angular-cli 的升级，比较容易看出端倪。</p><p>访问<code>https://github.com/angular/angular-cli/tree/master/packages/schematics/angular/migrations</code>，  查看 migration-collection.json 文件，随意选一个，例如以下：</p><pre><code>// 上略   &quot;migration-07&quot;: {      &quot;version&quot;: &quot;8.0.0-beta.12&quot;,      &quot;factory&quot;: &quot;./update-8&quot;,      &quot;description&quot;: &quot;Update an Angular CLI project to version 8.&quot;    },// 下略</code></pre><p>看起来大概意思就是，ug update 将 angular 升级到 8.0.0-beta.12 版本时，就会执行<code>migration-07</code>的升级相关命令，其工厂函数内容就在 update-8 的文件夹中。</p><p>有兴致可以细研究 ng update 到 8.0.0-beta.12 具体做了什么。我们只需要简单知道<code>migration-07</code>他会依照相关规则去执行一些动作。</p><p>那么，这份<code>migration-collection.json</code>是在哪里使用的呢？</p><p>可以看到，在这里：<code>https://github.com/angular/angular-cli/blob/master/packages/angular/cli/package.json</code>，在 angular-cli 的 package.json 文件中被定义的。</p><p>以上只是一些我在知道结果之后抛出来给大家看的关键点，大家可以深入研究。我在这里，就简单写个示例，供分析。</p><p><strong>注意：为了后续 ng update 实际使用效果，在此时进行后续作业前，可将现在的代码备份一下，作为 0.0.1 版本。</strong> 版本号的更改当然在 package.json 中。</p><p><strong>本节需要实现的目标是：<br>1、本 angular-schematics-tutorial package 在 angular 项目中使用时，可以使用 ng update 进行升级<br>2、在升级到指定版本时，能够按照升级需求修改已有 angular 项目中部分规则内容。</strong></p><p>这也是在使用 ng update 升级 angular 项目时，可以看到很多旧版本的写法，他会自动纠正成新版本的写法。</p><p>不过，依照我的简单总结，使用 ng update 升级，其实有几点要做：</p><h2 id="创建-migration-json-文件"><a href="#创建-migration-json-文件" class="headerlink" title="创建 migration.json 文件"></a>创建 migration.json 文件</h2><p>在 src/文件夹下，与 collection.json 同级目录，新建 migration.json 文件(名字虽然不限制，但是以便识别)，并写入以下内容：</p><pre><code>{    &quot;$schema&quot;: &quot;../node_modules/@angular-devkit/schematics/collection-schema.json&quot;,    &quot;schematics&quot;: {        &quot;migration002&quot;: {            &quot;version&quot;: &quot;0.0.2&quot;,            &quot;description&quot;: &quot;更新angular-schematics-tutorial到0.0.2版本时执行的更新&quot;,            &quot;factory&quot;: &quot;./ng-update/index#update&quot;        }    }}</code></pre><p>此份说明，当后续把这个 schematics 项目打包之后，其他 angular 项目中使用了这个包，升级到 0.0.2 版本时，就要执行在/ng-update/index.ts 文件中的逻辑规则更新代码了。</p><h2 id="在-package-json-中声明-ug-update-配置"><a href="#在-package-json-中声明-ug-update-配置" class="headerlink" title="在 package.json 中声明 ug-update 配置"></a>在 package.json 中声明 ug-update 配置</h2><p>在 package.json 中，添加以下项目：</p><pre><code>  &quot;ng-update&quot;: {    &quot;migrations&quot;: &quot;./src/migration.json&quot;  },</code></pre><p>其作用，就是在执行 ng update 时，能够找到对应的配置文件</p><h2 id="编写更新执行的规则工厂逻辑代码"><a href="#编写更新执行的规则工厂逻辑代码" class="headerlink" title="编写更新执行的规则工厂逻辑代码"></a>编写更新执行的规则工厂逻辑代码</h2><p>因为只是简单示例，我简单的实现，如果把此 angular-schematics-tutorial 包升级到了 0.0.2 版本，那么一并更新 app.component.ts 里面的 title 变量的值，为<code>AngularSchematicsTutorial002</code>，如果在我之前使用的测试 angular-demo 中运行，可以先看到，目前的 title 值应该是<code>title = &#39;angular-demo&#39;;</code>。</p><p>在 component 同级文件夹路径下新建 ng-update 文件夹，并添加 index.ts 文件，并添加以下代码：</p><pre><code>import { Rule, Tree, SchematicContext, SchematicsException } from &#39;@angular-devkit/schematics&#39;;import { buildDefaultPath } from &#39;@schematics/angular/utility/project&#39;;import * as ts from &#39;typescript&#39;;export function update(): Rule {    return (_tree: Tree, _context: SchematicContext) =&gt; {        // 解析angular项目        const workspaceConfigBuffer = _tree.read(&#39;angular.json&#39;);        if (!workspaceConfigBuffer) {            throw new SchematicsException(&#39;Not an Angular CLI workspace&#39;);        }        const workspaceConfig = JSON.parse(workspaceConfigBuffer.toString());        const projectName = workspaceConfig.defaultProject;        const project = workspaceConfig.projects[projectName];        const defaultProjectPath = buildDefaultPath(project);        // 把 app.component.ts 转成 Typescript AST        const componentPath = `${defaultProjectPath}/app.component.ts`;        const componentSourceFile = readIntoSourceFile(_tree, componentPath);        // 找出 title 变量        const classDeclaration = componentSourceFile.statements.find(node =&gt; ts.isClassDeclaration(node))! as ts.ClassDeclaration;        const allProperties = classDeclaration.members.filter(node =&gt; ts.isPropertyDeclaration(node))! as ts.PropertyDeclaration[];        const titleProperty = allProperties.find(node =&gt; node.name.getText() === &#39;title&#39;);        // 如果有找到 title 变量，则修改它的值        if (titleProperty) {            const initialLiteral = titleProperty.initializer as ts.StringLiteral;            const componentRecorder = _tree.beginUpdate(componentPath);            const startPos = initialLiteral.getStart();            componentRecorder.remove(startPos, initialLiteral.getWidth());            componentRecorder.insertRight(startPos, &#39;\&#39;AngularSchematicsTutorial002\&#39;&#39;);            _tree.commitUpdate(componentRecorder);        }        return _tree;    }}function readIntoSourceFile(host: Tree, modulePath: string): ts.SourceFile {    const text = host.read(modulePath);    if (text === null) {        throw new SchematicsException(`File ${modulePath} does not exist.`);    }    const sourceText = text.toString(&#39;utf-8&#39;);    return ts.createSourceFile(modulePath, sourceText, ts.ScriptTarget.Latest, true);}</code></pre><p>内容可不细看，就是找到 angular 项目中的 app.component.ts，把 title 的值改为 AngularSchematicsTutorial002。</p><h2 id="测试并使用-1"><a href="#测试并使用-1" class="headerlink" title="测试并使用"></a>测试并使用</h2><p>当然，再次在 ng-update/index.ts 下创建 index_spec.ts 编写测试用例也是 ok 的，源代码中会给出。<br>若不用这个麻烦，可以直接在之前的 angular-demo 专案的测试，不过因为是相对路径，则不能直接使用 ng update 了，因为它不知道去哪里判断是不是新版本的更新。</p><p>在 angular-demo 中运行：</p><pre><code>schematics ../angular-schematics-tutorial/src/migration.json:migration002 --debug=false</code></pre><p>执行之后，应该会得到以下结果：</p><pre><code>david@ubuntu:~/TTT/angular-demo$ schematics ../angular-schematics-tutorial/src/migration.json:migration002 --debug=falseUPDATE /src/app/app.component.ts (318 bytes)david@ubuntu:~/TTT/angular-demo$</code></pre><p>并且，app.component.ts 中<code>title = &#39;angular-demo&#39;;</code>变成了<code>title = &#39;AngularSchematicsTutorial002&#39;;</code></p><p>如果能够运行成功，说明 angular schematics 构建 ng update 原理图也学习完成。</p><h1 id="将原理图-package-发布并使用"><a href="#将原理图-package-发布并使用" class="headerlink" title="将原理图 package 发布并使用"></a>将原理图 package 发布并使用</h1><p>以上在执行时，都是使用相对路径在项目中运行，一点都不专业？那么我们可以把这个 schematics 工具包发布，后续直接使用 ng 指令运行。</p><h2 id="使用-npm-link-本地调试"><a href="#使用-npm-link-本地调试" class="headerlink" title="使用 npm link 本地调试"></a>使用 npm link 本地调试</h2><p>可以在我们的 angular-schematics-tutorial 项目目录下，运行<code>npm link</code>指令。<br>npm link 指令细节可参看<a href="https://docs.npmjs.com/cli/link.html" target="_blank" rel="noopener">https://docs.npmjs.com/cli/link.html</a><br>。主要作用就是创建一个全局可访问链接符号。<br>执行之后得到的效果应该如下：</p><pre><code>david@ubuntu:~/TTT/angular-schematics-tutorial$ npm linknpm WARN angular-schematics-tutorial@0.0.2 No repository field.audited 78 packages in 1.031sfound 0 vulnerabilities/home/david/.nvm/versions/node/v12.6.0/lib/node_modules/angular-schematics-tutorial -&gt; /home/david/TTT/angular-schematics-tutorialdavid@ubuntu:~/TTT/angular-schematics-tutorial$</code></pre><p>然后在模板 angular 项目中，链接刚刚的全局 angular-schematics-tutorial 链接。<br><code>npm link angular-schematics-tutorial</code>，相当于在当前项目安装了之前 link 的包，然后就可以在 angular 项目中直接使用 ng g <collection> 或 ng add <collection>了。</collection></collection></p><p>例如在 angular-demo 项目中 link angular-schematics-tutorial ，应该如下：</p><pre><code>david@ubuntu:~/TTT/angular-demo$ npm link angular-schematics-tutorial/home/david/TTT/angular-demo/node_modules/angular-schematics-tutorial -&gt; /home/david/.nvm/versions/node/v12.6.0/lib/node_modules/angular-schematics-tutorial -&gt; /home/david/TTT/angular-schematics-tutorialdavid@ubuntu:~/TTT/angular-demo$</code></pre><p>然后使用 ng generator：</p><pre><code>david@ubuntu:~/TTT/angular-demo$ ng g angular-schematics-tutorial:component? 你想创建的component的名字: comp/pieCREATE src/app/comp/pie/pie.component.html (21 bytes)CREATE src/app/comp/pie/pie.component.scss (0 bytes)CREATE src/app/comp/pie/pie.component.spec.ts (741 bytes)CREATE src/app/comp/pie/pie.component.ts (259 bytes)david@ubuntu:~/TTT/angular-demo$</code></pre><p><strong>注意：现在不用设置 –debug=false 属性，一样会直接真实创建了。</strong></p><p>同理，使用 ng add angular-schematics-tutorial：</p><pre><code class="shell">david@ubuntu:~/TTT/angular-demo$ ng add angular-schematics-tutorialSkipping installation: Package already installedUPDATE src/app/app.module.ts (407 bytes)UPDATE src/app/app.component.ts (302 bytes)UPDATE src/app/app.component.html (25506 bytes)UPDATE package.json (1439 bytes)npm WARN axobject-query@2.1.1 requires a peer of eslint@^5 || ^6 but none is installed. You must install peer dependencies yourself.……省略了一些npm WARN……npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.2: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;})+ @fortawesome/free-solid-svg-icons@5.11.2+ @fortawesome/fontawesome-svg-core@1.2.25+ @fortawesome/angular-fontawesome@0.5.0added 4 packages from 25 contributors, removed 1 package and audited 18882 packages in 11.067sfound 0 vulnerabilitiesdavid@ubuntu:~/TTT/angular-demo$</code></pre><p>注意：如果之前执行过，最好撤销后再试。<br>看到上面显示这一句<code>Skipping installation: Package already installed</code>，这里 already installed 的 package 指的是 angular-schematics-tutorial，原因在于我们使用 npm link angular-schematics-tutorial 已经做了链接了。</p><p><strong>那么，能否直接测试 ng update 呢？目前我是没有成功的。</strong> 因为 npm link 无法同时测试两个版本？这点可请大家指出。</p><p>注意，测试完了请使用 npm unlink 去清除那些链接，避免混乱等情况。</p><h2 id="将原理图-package-发布到仓库并使用"><a href="#将原理图-package-发布到仓库并使用" class="headerlink" title="将原理图 package 发布到仓库并使用"></a>将原理图 package 发布到仓库并使用</h2><p>写在前面：如果觉得这样的糟粕不想自己发布用于测试，可以直接使用我已发布的进行测试。<br>先安装 0.0.1 版本：<code>npm i angular-schematics-tutorial@0.0.1</code><br>然后执行<code>ng update</code>，查看是否生效。</p><p>一般如果公司有自己内部的包管理系统，那么就可以直接发布到内部去。<br>如何搭建私有 npm 仓库？我之前有文件，使用 verdaccio。</p><p>我们这里示例将包发布到公网的 npmjs.com 去。既然是 npmjs，那可能你要去注册个帐号了。</p><p>记得前面我们有备份一个 0.0.1 版本的 angular-schematics-tutorial 吗？我们先来发布它。</p><h3 id="添加帐号，在终端输入-adduser，按提示填写"><a href="#添加帐号，在终端输入-adduser，按提示填写" class="headerlink" title="添加帐号，在终端输入 adduser，按提示填写"></a>添加帐号，在终端输入 adduser，按提示填写</h3><pre><code>david@ubuntu:~/TTT/angular-schematics-tutorial$ npm adduserUsername: davidsuPassword:Email: (this IS public) 183318××××@qq.comLogged in as davidsu on https://registry.npmjs.org/.david@ubuntu:~/TTT/angular-schematics-tutorial$</code></pre><p>logged in 表示成功</p><h3 id="在根目录执行npm-publish"><a href="#在根目录执行npm-publish" class="headerlink" title="在根目录执行npm publish"></a>在根目录执行<code>npm publish</code></h3><p>得到结果如下：</p><pre><code>david@ubuntu:~/TTT/angular-schematics-tutorial$ npm publishnpm noticenpm notice 📦  angular-schematics-tutorial@0.0.1npm notice === Tarball Contents ===……略一大部分 npm notice 内容……npm notice === Tarball Details ===npm notice name:          angular-schematics-tutorialnpm notice version:       0.0.1npm notice package size:  11.3 kBnpm notice unpacked size: 41.2 kBnpm notice shasum:        9f80b36542065cafb2eb06a5eceb068d5aa9db44npm notice integrity:     sha512-oZcVhqatHlU9K[...]Qz7Deicn1f3oA==npm notice total files:   34npm notice+ angular-schematics-tutorial@0.0.1david@ubuntu:~/TTT/angular-schematics-tutorial$</code></pre><p>那么没有添加 ng update 的 0.0.1 版本就发布了，可以在 npmjs 网站自己的账户下查看自己发布的包。</p><h3 id="发布-0-0-2-版本的包"><a href="#发布-0-0-2-版本的包" class="headerlink" title="发布 0.0.2 版本的包"></a>发布 0.0.2 版本的包</h3><p>重复以上动作(npm publish)，把 angular-schematics-tutorial 的 0.0.2 版本的包也发布了，那么就可以看到自己两个版本的包了。<br><img alt="npmjs下自己发布的包" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/npmjs%E8%87%AA%E5%B7%B1%E5%8F%91%E5%B8%83%E7%9A%84%E5%8C%85.png" class="lazyload"></p><h3 id="实际测试使用"><a href="#实际测试使用" class="headerlink" title="实际测试使用"></a>实际测试使用</h3><p>现在，我们的 angular-schematics-tutorial 就是一个可以被所有人访问的原理图工具包了，那么我们就可以像实际使用包一样去测试它了。</p><p>为了避免干扰，可以删除之前的 angular-demo 测试项目，新建一个 angular-test 的新项目</p><pre><code>ng new angular-test</code></pre><p>我们先测试 ug update 的效果。</p><p>先安装 0.0.1 版本：</p><pre><code>npm i angular-schematics-tutorial@0.0.1</code></pre><p>然后运行<code>ng update</code>指令，应该看到以下内容</p><pre><code>david@ubuntu:~/TTT/angular-test$ ng updateUsing package manager: &#39;npm&#39;Collecting installed dependencies...Found 31 dependencies.    We analyzed your package.json, there are some packages to update:      Name                               Version                  Command to update     --------------------------------------------------------------------------------      angular-schematics-tutorial        0.0.1 -&gt; 0.0.2           ng update angular-schematics-tutorial      rxjs                               6.4.0 -&gt; 6.5.3           ng update rxjsdavid@ubuntu:~/TTT/angular-test$</code></pre><p>现在，我们可以直接使用 ng update 去升级我们的工具包了。<br><strong>注意：使用 ng update 升级前，要提交所有变更。</strong><br>运行<code>ng update angular-schematics-tutorial</code>，注意查看 app.component.ts 中 title 变量是否变化：</p><pre><code>david@ubuntu:~/TTT/angular-test$ ng update angular-schematics-tutorialUsing package manager: &#39;npm&#39;Collecting installed dependencies...Found 31 dependencies.Fetching dependency metadata from registry...    Updating package.json with dependency angular-schematics-tutorial @ &quot;0.0.2&quot; (was &quot;0.0.1&quot;)...UPDATE package.json (1329 bytes)npm WARN axobject-query@2.1.1 requires a peer of eslint@^5 || ^6 but none is installed. You must install peer……省略一些npm WARN……npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.2: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;})updated 1 package and audited 18955 packages in 8.615sfound 0 vulnerabilities    ** Executing migrations for package &#39;angular-schematics-tutorial&#39; **UPDATE src/app/app.component.ts (233 bytes)david@ubuntu:~/TTT/angular-test$</code></pre><p>从最后一行，看到，应该是修改了，实际也如此。</p><p><img alt="ngupdate成功" data-src="/../images/TechnicalEssays/angular-schematics-tutorial/screenshots/ngupdate%E6%88%90%E5%8A%9F.png" class="lazyload"></p><p>其他的 ng generator 的原理图和 ng add 的原理图也是可以的，可以自行测试。<br>例如：<code>ng g angular-schematics-tutorial:crudService</code>或者<code>ng add angular-schematics-tutorial</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>花费了如此大量的篇幅，基本上讲清楚了 angular schematics 的基本使用内容。虽然看起来很鸡肋，但是如果是 angular 技术栈并且长期有重复大量相同工作的开发，不免可以试一下使用它来重构下作业流程。虽然不一定比 ctrl+c ctrl+v 快，但是至少逼格更高了。</p><p>总结一下使用 angular schematics 的步骤重点。</p><p>制作 ng generator 或 ng add 原理图：<br>1、新建原理图使用模板文件；<br>2、创建该原理图需要的 schema.json 并将该原理图配置到 collection.json；<br>3、依照 schema.json 创建接口 schema.d.ts；<br>4、在 index.ts 中编写实现该原理图目的的逻辑代码；<br>5(非必须)、编写测试用例进行测试；<br>6(测试)、利用测试用例或实际项目进行测试。</p><p>添加 ng update<br>1、创建并编写 migration.json 文件；<br>2、在 package.json 中声明 ug-update 配置；<br>3、编写更新执行的规则工厂逻辑代码；<br>4、测试并使用。</p><p>以上内容亲测有效，有问题可提出交流，谢谢。</p><p>主要参考：<br><a href="https://ithelp.ithome.com.tw/articles/10222826" target="_blank" rel="noopener">https://ithelp.ithome.com.tw/articles/10222826</a><br><a href="https://medium.com/@tomastrajan/total-guide-to-custom-angular-schematics-5c50cf90cdb4" target="_blank" rel="noopener">https://medium.com/@tomastrajan/total-guide-to-custom-angular-schematics-5c50cf90cdb4</a><br>和 angular 官方文档：<a href="https://angular.cn/guide/schematics" target="_blank" rel="noopener">https://angular.cn/guide/schematics</a></p>]]></content>
      
      
      <categories>
          
          <category> angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
            <tag> schematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只言片语——angular material input输入框可以辅助下拉选择</title>
      <link href="/2019/12/12/TechnicalEssays/snippets-angular-input-with-select/"/>
      <url>/2019/12/12/TechnicalEssays/snippets-angular-input-with-select/</url>
      
        <content type="html"><![CDATA[<p>在 angular 使用 material 开发时，如果需要一个输入框，既可以自行输入值，还可以点击下拉选择预设的选项输入值，可以使用 autocomplete 标签。</p><a id="more"></a><p>需要引入 MatAutocompleteModule 模块</p><pre><code>import {MatAutocompleteModule} from &#39;@angular/material/autocomplete&#39;;</code></pre><p>在 xxx.ts 中定义了下拉选项，例如：</p><pre><code>  options = [    { value: &#39;00:30:00&#39;, column: &#39;30分钟&#39; },    { value: &#39;01:00:00&#39;, column: &#39;1小时&#39; },    { value: &#39;01:30:00&#39;, column: &#39;90分钟&#39; },    { value: &#39;02:00:00&#39;, column: &#39;2小时&#39; },    { value: &#39;05:00:00&#39;, column: &#39;5小时&#39; }  ];</code></pre><p>在 xxx.html 中使用示例如下：</p><pre><code>  &lt;span&gt;持续时间：&lt;/span&gt;  &lt;mat-form-field style=&quot;width:150px&quot;&gt;    &lt;input placeholder=&quot;自行输入或下拉选择&quot; matInput [matAutocomplete]=&quot;auto&quot;&gt;    &lt;mat-autocomplete #auto=&quot;matAutocomplete&quot;&gt;      &lt;mat-option *ngFor=&quot;let option of options&quot; [value]=&quot;option.value&quot;&gt;        {{option.column}}      &lt;/mat-option&gt;    &lt;/mat-autocomplete&gt;  &lt;/mat-form-field&gt;</code></pre><p>得到的效果如下：</p><p><img alt="INPUT可下拉可直接输入" data-src="/../images/TechnicalEssays/snippets-angular-input-with-select/pics/INPUT%E5%8F%AF%E4%B8%8B%E6%8B%89%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5.gif" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只言片语——angular ngFor遍历显示2个数组值</title>
      <link href="/2019/12/12/TechnicalEssays/snippets-angular-ngfor/"/>
      <url>/2019/12/12/TechnicalEssays/snippets-angular-ngfor/</url>
      
        <content type="html"><![CDATA[<p>angular 的*ngFor 只能遍历 1 个数组，但是能够获取到 index，所以以第一个数组的 index 带出第二个数组的值显示即可。</p><a id="more"></a><p>例如，在 xxx.ts 中有声明两个数组：</p><pre><code>names = [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;, &#39;马六&#39;];ages = [32, 34, 54, 25];</code></pre><p>在 xxx.html 中如此使用：</p><pre><code>&lt;div&gt;  &lt;li *ngFor=&quot;let name of names; let i=index &quot;&gt;    &lt;label&gt;{{name}} ~ {{ages[i]}}岁&lt;/label&gt;  &lt;/li&gt;&lt;/div&gt;</code></pre><p>得到的效果图如下：</p><p><img alt="ngFor显示两个数组的内容" data-src="/../images/TechnicalEssays/snippets-angular-ngfor/pics/ngFor%E6%98%BE%E7%A4%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AE%B9.png" class="lazyload"></p><p>当然，如果两个数组的长度不一致，要么显示空白(ngFor 遍历的数组长度值大)，要么不显示值(ngFor 遍历的数组长度值小。)</p>]]></content>
      
      
      <categories>
          
          <category> angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04下docker基本指令和使用docker安装mysql</title>
      <link href="/2019/12/12/TechnicalEssays/ubuntu-mysql-docker/"/>
      <url>/2019/12/12/TechnicalEssays/ubuntu-mysql-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-基本指令"><a href="#docker-基本指令" class="headerlink" title="docker 基本指令"></a>docker 基本指令</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><pre><code class="shell">sudo sh -c &quot;$(curl -fsSL https://get.docker.com)&quot;  sudo usermod -aG docker $USER</code></pre><p>第一行用docker官方提供的script快速安装<br>第二行将现有的使用者加入docker群组，否则会没有权限操作docker命令。<br>记得注销账号重登，以获取docker操作权限。  </p><a id="more"></a><p>执行<code>sudo docker run hello-world</code>查看是否安装成功。<br>如果出现以下画面则安装成功：<br><img alt="测试docker安装成功" data-src="/../images/TechnicalEssays/ubuntu-mysql-docker/%E6%B5%8B%E8%AF%95docker%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" class="lazyload"></p><h2 id="常用docker基本指令"><a href="#常用docker基本指令" class="headerlink" title="常用docker基本指令"></a>常用docker基本指令</h2><p>1 启动/关闭 docker服务</p><pre><code>service docker start 或者 systemctl start docker // 启动service docker stop 或者 systemctl stop docker // 关闭</code></pre><p>2 创建一个新的容器并运行一个命令</p><pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><p>常用OPTIONS说明：<br>　　-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；<br>　　-d: 后台运行容器，并返回容器ID；<br>　　-i: 以交互模式运行容器，通常与 -t 同时使用；<br>　　-P: 随机端口映射，容器内部端口随机映射到主机的高端口;<br>　　-p: 指定端口映射，格式为：主机(宿主)端口:容器端口;<br>　　-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>　　-e &lt;环境变量名&gt;=”&lt;值&gt;”: 设置环境变量；<br>　　–name=”<container-name>“: 为容器指定一个名称；  </container-name></p><p>例如:<br>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</p><pre><code>docker run --name mynginx -d nginx:latest</code></pre><p>3 只创建而不运行容器(选项同option)</p><pre><code>docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><p>4 删除一个或多个容器</p><pre><code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code></pre><p>OPTIONS说明：<br>　　-f :通过SIGKILL信号强制删除一个运行中的容器<br>　　-l :移除容器间的网络连接，而非容器本身<br>　　-v :-v 删除与容器关联的卷</p><p>例如：<br>强制删除容器db01、db02</p><pre><code>docker rm -f db01 db02</code></pre><p>5 在运行的容器中执行命令</p><pre><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></pre><p>OPTIONS说明：<br>　　 -d :分离模式: 在后台运行<br>　　-i :即使没有附加也保持STDIN 打开<br>　　-t :分配一个伪终端  </p><p>6 查看已有下载镜像(images)</p><pre><code>docker images</code></pre><h1 id="使用docker安装mysql"><a href="#使用docker安装mysql" class="headerlink" title="使用docker安装mysql"></a>使用docker安装mysql</h1><p>1 下载最新mysql镜像</p><pre><code>docker pull mysql:latest</code></pre><p>2 运行容器</p><pre><code>docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</code></pre><p>部分参数说明：<br>　　mysql-test：容器名<br>　　-p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。<br>　　MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。<br>3 配置mysql 使用者(user)<br>　　3.1 进入容器  </p><pre><code>　　docker exec -it mysql-test bash</code></pre><p>　　3.2 登录mysql并修改root密码  </p><pre><code>　　mysql -u root -p　　ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><p>　　3.3 添加远程登录用户 –&gt; ‘用户名‘@’主机’,%表任意都行</p><pre><code>　　CREATE USER &#39;&lt;username&gt;&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;&lt;password&gt;&#39;;　　GRANT ALL PRIVILEGES ON *.* TO &#39;&lt;username&gt;&#39;@&#39;%&#39;;</code></pre><h1 id="备份docker中mysql的数据"><a href="#备份docker中mysql的数据" class="headerlink" title="备份docker中mysql的数据"></a>备份docker中mysql的数据</h1><p>　　使用docker安装mysql可能遇到一个问题,就是如果不做其他处理,docker容器损坏,那么里面的数据就可能丢了再也找不回. 所以应当养成定时备份的好习惯。<br>　　使用以下指令，将docker容器中的mysql数据备份到宿主主机指定位置：</p><pre><code>docker exec [CONTAINER] //usr/bin/mysqldump -u [USER] --password=[PASSWORD] --routines --triggers test_db &gt; /home/user/test_db_backup.sql</code></pre><p>说明：<br>　　test_db是docker中mysql的数据库名<br>　　/home/user/test_db_backup.sql 备份到宿主主机的地址和文件名</p><p>将上面指令写入宿主主机的cron定时任务中就可定时将docker中mysql数据备份到本机，避免docker损坏数据就丢失了。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> mysql </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象数组按对象指定属性排序</title>
      <link href="/2019/12/12/TechnicalEssays/object-array-sort/"/>
      <url>/2019/12/12/TechnicalEssays/object-array-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>&emsp;&emsp;<strong>说明：使用语言为javascript。</strong><br>&emsp;&emsp;对象数组，即数组中存放的元素是一个个对象。例如</p><pre><code>let objArr = [    { name: &quot;张三&quot;, sex: &#39;female&#39;, age: 30, birthday: &quot;1994/10/11&quot; },    { name: &quot;李四&quot;, sex: &#39;male&#39;, age: 20, birthday: &quot;2001/08/11&quot; },    { name: &quot;王五&quot;, sex: &#39;female&#39;, age: 40, birthday: &quot;2001/01/15&quot; }];</code></pre><p>&emsp;&emsp;但是我们可能需要对该对数组中对象的指定属性进行排序，例如上述对象数组中的age，birthday。如何操作？<strong>方法之一，就是数组的sort()方法。</strong><br>&emsp;&emsp;下面，就一步步去分析，实现一份简单通用的对象数组排序方法。</p><a id="more"></a><h1 id="实现对象数组排序"><a href="#实现对象数组排序" class="headerlink" title="实现对象数组排序"></a>实现对象数组排序</h1><h2 id="第一步：简单排序number属性"><a href="#第一步：简单排序number属性" class="headerlink" title="第一步：简单排序number属性"></a>第一步：简单排序number属性</h2><p>&emsp;&emsp;因为Array.sort()的“默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的”。好在是sort()方法接受一个用来指定按某种顺序进行排列的函数作为可选参数，即<code>arr.sort([compareFunction])</code>，<strong>如果 compareFunction(a, b) 小于0，那么a会被排列到b之前；</strong>所以可以在此实现自己想要的排序方法。<br><strong>注意，sort方法会改变原数组。（sort() 方法用原地算法对数组的元素进行排序，并返回数组。）</strong></p><p>&emsp;&emsp;话不多说，直接看。<br>&emsp;&emsp;例如上述objArr，按照age升序排序：</p><pre><code>// 指定排序的比较函数function compare(property) {    return function (object1, object2) {        let value1 = object1[property];        let value2 = object2[property];        // 升序        return value1 - value2;    }}let sortObj = objArr.sort(compare(&quot;age&quot;));console.log(sortObj); </code></pre><p>&emsp;&emsp;应该会得到如下结果：<br><img alt="按照age排序" data-src="/../images/TechnicalEssays/object-array-sort/pics/%E6%8C%89%E7%85%A7age%E6%8E%92%E5%BA%8F.png" class="lazyload"></p><h2 id="第二阶段：可以排序string属性"><a href="#第二阶段：可以排序string属性" class="headerlink" title="第二阶段：可以排序string属性"></a>第二阶段：可以排序string属性</h2><p>&emsp;&emsp;但是这个写法只能对age这个number类型的属性其作用，如果换成name或者birthday等，就不行，因为string不能直接用’-‘比较得出大小。<br>&emsp;&emsp;例如，运行<code>console.log(&#39;male&#39; - &#39;female&#39;);</code>，应该会看到得出的是NaN。<br>&emsp;&emsp;string，就应该使用localeCompare() 方法，它返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。完整语法：<code>referenceStr.localeCompare(compareString[, locales[, options]])</code>。</p><p>&emsp;&emsp;所以需要简单修改一下compare()方法，修改如下：</p><pre><code>function compare(property) {    return function (object1, object2) {        let value1 = object1[property];        let value2 = object2[property];        if (typeof (value1) == typeof (value2)) {            if (typeof (value1) === &#39;number&#39;) {                return value1 - value2;            }            if (typeof (value1) === &#39;string&#39;) {                // 升序                return value1.toString().localeCompare(value2);            }        }    }}let sortObj = objArr.sort(compare(&quot;birthday&quot;));console.log(sortObj); </code></pre><p>&emsp;&emsp;结果应当如下：  </p><p><img alt="按照birthday排序.png" data-src="/../images/TechnicalEssays/object-array-sort/pics/%E6%8C%89%E7%85%A7birthday%E6%8E%92%E5%BA%8F.png" class="lazyload"></p><h2 id="第三阶段：可以指定升序-降序"><a href="#第三阶段：可以指定升序-降序" class="headerlink" title="第三阶段：可以指定升序/降序"></a>第三阶段：可以指定升序/降序</h2><p>&emsp;&emsp;既然已经到了这个程度，那可以再加一个是按照升序或者降序排列。<br>&emsp;&emsp;简单修改如下：</p><pre><code>function compare(property, sortType = &quot;asc&quot;) {    return function (object1, object2) {        let value1 = object1[property];        let value2 = object2[property];        // 判断 传入的属性值 是number还是 string        if (typeof (value1) == typeof (value2)) {            if (typeof (value1) === &#39;number&#39;) {                // 如果是升序                if (sortType === &quot;asc&quot;) {                    return value1 - value2;                } else if (sortType === &quot;desc&quot;) {                    // 如果是降序                    return value2 - value1;                }            }            if (typeof (value1) === &#39;string&#39;) {                // 如果是升序                if (sortType === &quot;asc&quot;) {                    return value1.toString().localeCompare(value2);                } else if (sortType === &quot;desc&quot;) {                    // 如果是降序                    return value2.toString().localeCompare(value1);                }            }        }    }}// 生日，降序let sortObj = objArr.sort(compare(&quot;birthday&quot;, &#39;desc&#39;));console.log(sortObj); </code></pre><p>&emsp;&emsp;得到的结果应该如下：<br><img alt="按birthday降序排序.png" data-src="/../images/TechnicalEssays/object-array-sort/pics/%E6%8C%89birthday%E9%99%8D%E5%BA%8F%E6%8E%92%E5%BA%8F.png" class="lazyload"></p><h2 id="第四阶段：封裝成通用方法"><a href="#第四阶段：封裝成通用方法" class="headerlink" title="第四阶段：封裝成通用方法"></a>第四阶段：封裝成通用方法</h2><p>&emsp;&emsp;反正都这样了，再简单封装一下，导出成一个方法，后续直接使用。</p><p>&emsp;&emsp;新建一个objArraySort.js,放入以下代码：</p><pre><code>// sort使用的排序方法// 传入对象数组用于排序的对象的属性,升序/降序function compare(property, sortType = &quot;asc&quot;) {    // 如果不是 asc,desc,不做下一步比较    if (!(sortType === &quot;desc&quot; || sortType === &quot;asc&quot;)) {        return;    }    return function (object1, object2) {        // 取得对象属性值        let value1 = object1[property];        let value2 = object2[property];        // 如果该对象不存在这个属性,也不做后续比较        if (!value1 || !value2) {            return;        }        // 如果两个属性取得的值不是一个类型的就不用比较了        if (typeof (value1) == typeof (value2)) {            // 判断 传入的属性值 是number还是 string            if (typeof (value1) === &#39;number&#39;) {                // 如果是升序                if (sortType === &quot;asc&quot;) {                    return value1 - value2;                } else {                    // 如果是降序                    return value2 - value1;                }            } else if (typeof (value1) === &#39;string&#39;) {                // 如果是升序                if (sortType === &quot;asc&quot;) {                    return value1.toString().localeCompare(value2);                } else {                    // 如果是降序                    return value2.toString().localeCompare(value1);                }            } else {                // 其它类型就不排序了                return;            }        } else {            return;        }    }}// 通用方法，需要传入 需要排序的对象数组、对象属性、排序方式function objectArraySort(array, property, sortType) {    // 如果不是对象数组用这个方法,返回的是undefined    if (!(array instanceof Array)) {        return;    }    return array.sort(compare(property, sortType));}// 导出module.exports = {    objectArraySort: objectArraySort,}</code></pre><p>&emsp;&emsp;再将刚刚的objArr按照age降序排序：</p><pre><code>// 引入模块const oas = require(&quot;./objectArraySort&quot;);// 调用方法，传入需要排序的对象数组、对象属性、排序方式let sortObj = oas.objectArraySort(objArr, &#39;age&#39;, &#39;desc&#39;);console.log(sortObj); </code></pre><p>&emsp;&emsp;应该会得到以下结果：<br><img alt="按照age降序排序.png" data-src="/../images/TechnicalEssays/object-array-sort/pics/%E6%8C%89%E7%85%A7age%E9%99%8D%E5%BA%8F%E6%8E%92%E5%BA%8F.png" class="lazyload"></p><p>&emsp;&emsp;至此，一个简单通用的对象数组按照其对象指定属性排序的模块就完成了。实践有效，如果有问题，可提出交流，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express+multer 文件上传,并在 router 中指定文件存放路径</title>
      <link href="/2019/12/12/TechnicalEssays/express-multer-demo/"/>
      <url>/2019/12/12/TechnicalEssays/express-multer-demo/</url>
      
        <content type="html"><![CDATA[<p>Express+multer 文件上传,并在 router 中指定文件存放路径</p><h1 id="内容简单说明"><a href="#内容简单说明" class="headerlink" title="内容简单说明"></a>内容简单说明</h1><p>&emsp;&emsp;文件上传是 web 开发中比较常见的一个功能虽然说起来是文件上传，实际上，可以看做是对 multipart/form-data 数据的处理。在 npm 中,有很多处理类似数据的库，包括周下载量近 2kw 的 form-data，周下载量近 3mw 的 formidable。</p><p>&emsp;&emsp;不过，如果 nodejs 后端使用的 express 框架，其官方也有一个自己的文件上传中间件，用它自己的话来说就是：“Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据，它主要用于上传文件。”</p><a id="more"></a><p>&emsp;&emsp;使用 multer 比较简单，一般就是<br>&emsp;&emsp;&emsp;&emsp;1、导入 multer，<br>&emsp;&emsp;&emsp;&emsp;2、指定文件上传地址（如果有必要的话，不指定只是写到内存中），<br>&emsp;&emsp;&emsp;&emsp;3、在 router 的路径后，回调函数前，写一个<code>upload.single(photo)</code>（单文件）或者<code>upload.array(&#39;photos&#39;, 12)</code>（多文件），在 router 的回调中，就可以使用<code>req.file 或者 req.files</code>获取文件了。</p><p>&emsp;&emsp;在这里，因为指定的上传地址是在 multer(opts)中的 opts 配置，所以 opts 配置号一个地址之后，后续修改就不是那么方便。如果需要对不同文件不同路由路径指定不同的文件上传地址，那应该如何处理？</p><p>&emsp;&emsp;multer 的简单使用后文会给个示例，但是最终的目的，<strong>是想要在 express 的 router 回调函数中，可以指定文件上传的路径，而不是所有的文件都上传到唯一指定的路径。</strong>例如，路由是“testUpload”，我在 router 处理时指定存放到测试使用的上传路径。路由是“formalUpload”，我在处理时可以指定存放到正式的上传路径。</p><h1 id="express-multer-基本文件上传示例"><a href="#express-multer-基本文件上传示例" class="headerlink" title="express+multer 基本文件上传示例"></a>express+multer 基本文件上传示例</h1><p>&emsp;&emsp;因为主要是测试 multer 内容，所以一切从简，就在一个简单的 express 项目中测试就好</p><h2 id="1、创建一个-express-项目（前提：已安装-express-generator），并安装-multer"><a href="#1、创建一个-express-项目（前提：已安装-express-generator），并安装-multer" class="headerlink" title="1、创建一个 express 项目（前提：已安装 express-generator），并安装 multer"></a>1、创建一个 express 项目（前提：已安装 express-generator），并安装 multer</h2><pre><code>express --view=ejs express-mutler-demo// 进入项目根目录npm i multer</code></pre><h2 id="2、上传页面编写"><a href="#2、上传页面编写" class="headerlink" title="2、上传页面编写"></a>2、上传页面编写</h2><p>&emsp;&emsp;修改 views/index.ejs 的<body>标签内容如下：</body></p><pre><code class="javascript">  &lt;div&gt;    &lt;h3&gt;Express + multer 簡陋上傳文件&lt;/h3&gt;    &lt;form method=&quot;post&quot; action=&quot;/upload&quot; id=&quot;upload-form&quot; encType=&quot;multipart/form-data&quot;&gt;      &lt;input id=&#39;upload&#39; type=&quot;file&quot; name=&quot;file&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;上傳&quot;&gt;    &lt;/form&gt;    &lt;!-- 进度条 --&gt;    &lt;progress id=&quot;uploadprogress&quot; min=&quot;0&quot; max=&quot;100&quot; value=&quot;0&quot;&gt;0&lt;/progress&gt;    &lt;p id=&#39;msg&#39;&gt;&lt;/p&gt;  &lt;/div&gt;  &lt;!-- 引入jquery.js --&gt;  &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;    integrity=&quot;sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;  &lt;script&gt;    let form = $(&quot;#upload-form&quot;);    form.on(&#39;submit&#39;, function (event) {      // 清除提交结果显示信息      $(&quot;#msg&quot;).html(&quot;&quot;);      // 在原页面处理，不跳转      event.preventDefault();      // 检查是否支持FormData      if (window.FormData) {        let formData = new FormData();        // 建立一个file表单项，值为上传的文件        formData.append(&#39;file&#39;, $(&#39;#upload&#39;).get(0).files[0]);        let xhr = new XMLHttpRequest();        xhr.open(&#39;POST&#39;, $(this).attr(&#39;action&#39;));        // 进度条占比计算        xhr.upload.onprogress = function (event) {          if (event.lengthComputable) {            let complete = (event.loaded / event.total * 100 | 0);            $(&quot;#uploadprogress&quot;).val(complete);            $(&quot;#uploadprogress&quot;).innerHTML = complete;          }        };        // 定义上传完成后的回调函数        xhr.onload = function (e) {          if (xhr.status === 200) {            $(&quot;#msg&quot;).html(&quot;上传成功!&quot;);            // alert(&#39;上传成功！&#39;);          } else {            // alert(&#39;文件上传出错了！&#39;)            $(&quot;#msg&quot;).html(&quot;上传失败!&quot;);          }        };        // 发送表单数据        xhr.send(formData);      }    });  &lt;/script&gt;</code></pre><p>&emsp;&emsp;代码内容很简单，就是一个 form 用来模拟文件上传，为了最简单，直接使用的 XMLHttpRequest 实现上传，还没事整了个进度条。<br>&emsp;&emsp;本来想用原始的方法，还是引入了 jquery。更简略类似下面也 ok。</p><pre><code>&lt;script&gt;    function PostData() {        $.ajax({            type: &quot;POST&quot;,            url: &quot;XXX&quot;,            data : &quot;&quot;,            success: function(msg) {            }        });        return false;    }&lt;/script&gt;&lt;form onsubmit=&quot;return PostData()&quot;&gt;    &lt;input type=&quot;text&quot; value=&quot;&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;</code></pre><p>&emsp;&emsp;依旧以第一个为准，页面大概是这个样子（运行 express 项目，在 localhost:3000 看到）：</p><p><img alt="input画面" data-src="/../images/TechnicalEssays/express-multer-demo/pic/input%E7%94%BB%E9%9D%A2.png" class="lazyload"></p><h2 id="3、multer-的简单配置"><a href="#3、multer-的简单配置" class="headerlink" title="3、multer 的简单配置"></a>3、multer 的简单配置</h2><p>&emsp;&emsp;新建一个 util/Upload.js，编写 multer 配置并导出：</p><pre><code>const multer = require(&#39;multer&#39;);// 文件上传配置const fileStorage = multer.diskStorage({    destination: function (req, file, callback) {        callback(null, &quot;/defaultUploadDir&quot;);    },    filename: function (req, file, callback) {        callback(null, file.originalname);    }});// 导出配置module.exports = {    fileUpdate: multer({ &#39;storage&#39;: fileStorage }),}</code></pre><p><strong>注意：上传地址 “/defaultUploadDir”要先手动创建，否则报错。</strong></p><h2 id="4、在对应-router-中使用-multer"><a href="#4、在对应-router-中使用-multer" class="headerlink" title="4、在对应 router 中使用 multer"></a>4、在对应 router 中使用 multer</h2><p>&emsp;&emsp;在 routes/index.js 中，添加以下 router 代码：</p><pre><code>router.post(&#39;/upload&#39;, upload.fileUpdate.single(&#39;file&#39;), function (req, res, next) {  const file = req.file;  console.log(file);  //如果得到了文件，就返回上传成功  if (file) {    return res.status(200).json({ success: true });  } else {    return res.status(500).json({ success: false });  }});</code></pre><p>&emsp;&emsp;记得在最上面引入 multer 配置：</p><pre><code>const upload = require(&#39;../util/Upload&#39;);</code></pre><p>&emsp;&emsp;几个简单注意点：<br>&emsp;&emsp;&emsp;&emsp;1、这个路由路径和路由方法，要和前台页面中的 action 和 method 一致；<br>&emsp;&emsp;&emsp;&emsp;2、多文件就要 upload.array(),单文件就用 upload.single()（后续都是单文件示例中说明）;<br>&emsp;&emsp;&emsp;&emsp;3、第二点()里面的标志字符串要和前台页面中的<code>&lt;input id=&#39;upload&#39; type=&quot;file&quot; name=&quot;file&quot; /&gt;</code>name 属性一致。</p><p>&emsp;&emsp;如果步骤都正确，成功上传，应该可以看到前台页面如下：<br><img alt="上传成功" data-src="/../images/TechnicalEssays/express-multer-demo/pic/%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F.png" class="lazyload"></p><p>&emsp;&emsp;router 的回调中取得上传文件的信息，如下：<br><img alt="上传成功router取得文件信息" data-src="/../images/TechnicalEssays/express-multer-demo/pic/%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9Frouter%E5%8F%96%E5%BE%97%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF.png" class="lazyload"></p><p>&emsp;&emsp;文件上传的位置：<br><img alt="第一次上传成功后台地址" data-src="/../images/TechnicalEssays/express-multer-demo/pic/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F%E5%90%8E%E5%8F%B0%E5%9C%B0%E5%9D%80.png" class="lazyload"></p><h1 id="关于使用-multer-文本域数据"><a href="#关于使用-multer-文本域数据" class="headerlink" title="关于使用 multer 文本域数据"></a>关于使用 multer 文本域数据</h1><p>&emsp;&emsp;multer 的 readme 所说：”Multer 会添加一个 body 对象 以及 file 或 files 对象 到 express 的 request 对象中。 body 对象包含表单的文本域信息，file 或 files 对象包含对象表单上传的文件信息。“<br>&emsp;&emsp;实际测试，在前台页面 index.ejs 创建 formData 后，append 一个文本数据：</p><pre><code>let formData = new FormData();// 补入此句formData.append(&#39;dest&#39;, &#39;file_upload&#39;);</code></pre><p>&emsp;&emsp;刷新页面之后，重新上传，可以在 multer 配置中，在 diskStorage 的 destination 的 callback 中，可以得到 req.body 包含了 dest 属性。如下图：<br><img alt="req.body获取文本域数据" data-src="/../images/TechnicalEssays/express-multer-demo/pic/req.body%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E5%9F%9F%E6%95%B0%E6%8D%AE.png" class="lazyload"></p><p>&emsp;&emsp;这是好事，很好的，这样，在前台上传文件时，就可以把需要上传的地址放到这里，那么不同的文件上传就可以存放的不同的地址了。<br>&emsp;&emsp;那么会有哪些问题呢？<br>&emsp;&emsp;&emsp;&emsp;1、前端需要知道后台的上传路径，不合理。<br>&emsp;&emsp;&emsp;&emsp;2、并不是所有使用 formData.append()添加的属性都能在文件上传 destination 生成前，在 req.body 中获取到。</p><p>&emsp;&emsp;&emsp;&emsp;这是一个实际遇到的问题，我在使用 angular 时，使用 HttpClient 实现文件上传操作，类似：</p><pre><code>  upload(file: any) {    // 文件使用FormData发送    const formData: FormData = new FormData();    formData.append(&#39;file&#39;, file, file.name);    formData.append(&#39;file_name&#39;, file, file.name);    return this.http.post(this.URL + &#39;/upload&#39;, formData );  }</code></pre><p>&emsp;&emsp;后台的 req.body 在获取到上传的文件前并不会有 file_name 属性的值，即在 multer 配置在 diskStorage 的 destination 的 callback 中，可以得到 req.body 是空，在对应 upload 的 router 回调中，才取得 req.body 的 file_name 属性。</p><h1 id="在-router-的回调中，指定文件上传的路径。"><a href="#在-router-的回调中，指定文件上传的路径。" class="headerlink" title="在 router 的回调中，指定文件上传的路径。"></a>在 router 的回调中，指定文件上传的路径。</h1><p>&emsp;&emsp;在”关于使用 multer 文本域数据“这部分有讲到，前台直接传入文件上传的路径不合理，在接受到上传的文件前得到指定的上传路径也不一定成功，而直接使用配置好的 multer，其文件上传目的地 destination 又只有固定一个。该如何实现？</p><p>&emsp;&emsp;<strong>把 multer 的配置，封装到一个返回 promise 的函数，指定传入一个文件路径参数，并在 router 的回调中使用该函数，传入上传路径。</strong></p><p>&emsp;&emsp;修改 utils/Upload.js 文件，补入以下内容：</p><pre><code>// multer文件上传,可指定上传路径,不在router参数里直接用let uploadFunction = (req, res, dest) =&gt; {    let storage = multer.diskStorage({        destination: function (req, file, cb) {            let newDestination = dest;            let stat = null;            try {                // 检查传入的路径是否存在，不存在则创件                stat = fs.statSync(newDestination);            } catch (err) {                fs.mkdirSync(newDestination);            }            if (stat &amp;&amp; !stat.isDirectory()) {                throw new Error(&#39;文件目录： &quot;&#39; + dest + &#39;已存在！&quot;&#39;);            }            cb(null, newDestination);        },        filename: function (req, file, callback) {            callback(null, file.originalname);        }    });    let upload = multer({        storage: storage    }).single(&#39;file&#39;);    return new Promise((resolve, reject) =&gt; {        upload(req, res, (err) =&gt; {            if (err) {                return reject(err);            }            resolve();        })    })};</code></pre><p>&emsp;&emsp;记得导出：</p><pre><code>module.exports = {    fileUpdate: multer({ &#39;storage&#39;: fileStorage }),    uploadFunction,}</code></pre><p>&emsp;&emsp;在 router 中使用，修改原 routes/index.js 的 upload 路由如下：</p><pre><code>router.post(&#39;/upload&#39;, /*upload.fileUpdate.single(&#39;file&#39;), */ async function (req, res, next) {  // 指定文件上传路径  let uploadPath = &#39;test_upload&#39;;  // 等到文件上传完成  await upload.uploadFunction(req, res, uploadPath);  const file = req.file;  console.log(req.file);  //如果得到了文件，就返回上传成功  if (file) {    return res.status(200).json({ success: true });  } else {    return res.status(500).json({ success: false });  }});</code></pre><p>&emsp;&emsp;当然，await 需要在 async 函数中使用，也最好放到 trycatch 中。</p><p>&emsp;&emsp;如果步骤正确，结果应该和第一步中的一样，文件上传成功。在后台的项目中会新建一个 test_upload 文件夹，并有上传的文件。<br><img alt="第二次文件上传成功位置" data-src="/../images/TechnicalEssays/express-multer-demo/pic/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F%E4%BD%8D%E7%BD%AE.png" class="lazyload"></p><p>&emsp;&emsp;代码已放到 <a href="https://github.com/Sanotsu/express-multer-demo" target="_blank" rel="noopener">github</a>，有需求可查阅。</p><p>&emsp;&emsp;以上内容，全部亲测有效，如果有问题，请提出交流，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> multer </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
